{
  "stats": {
    "totalSolutions": 245,
    "languages": [
      "C#",
      "Java",
      "Python",
      "Bash",
      "Go",
      "SQL",
      "JavaScript"
    ],
    "tags": [
      "ASCII",
      "Arithmetic Sequence",
      "Array",
      "Array Sorting",
      "Async/Await",
      "Binary Search",
      "Bit Manipulation",
      "Brute Force",
      "Character Manipulation",
      "Class Design",
      "Combinatorics",
      "Counting",
      "Design",
      "Dictionary",
      "Distance Calculation",
      "Divide and Conquer",
      "Error Handling",
      "Frequency Count",
      "Geometry",
      "Greedy",
      "Hash Table",
      "Hash-Table",
      "Higher-Order Functions",
      "Iteration",
      "JavaScript",
      "Math",
      "Method Chaining",
      "Modular Arithmetic",
      "OOP",
      "Object Manipulation",
      "Object Methods",
      "Pattern Recognition",
      "Prefix Sum",
      "Promises",
      "Rest Parameters",
      "Simulation",
      "Sliding Window",
      "String",
      "String Manipulation",
      "Two Pointers"
    ],
    "lastUpdated": "2025-12-14T12:42:23.388Z"
  },
  "solutions": [
    {
      "problemNumber": "0001",
      "title": "Two Sum",
      "language": "C#",
      "filename": "0001-TwoSum.cs",
      "path": "LeetCode/C#/0001-TwoSum.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0001-TwoSum.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public int[] TwoSum(int[] nums, int target)\n        {\n            int[] result = new int[2];\n            Dictionary<int,int> keyvalue = new Dictionary<int,int>();\n            int index = 0;\n            foreach (int num in nums)\n            {\n                if (keyvalue.ContainsKey(target - num))\n                {\n                    result[0] = index;\n                    result[1] = keyvalue[target - num]; \n                }\n                else\n                {\n                    keyvalue.TryAdd(num,index);\n                }\n\n                index++;\n            }\n            return result;\n        }\n}"
    },
    {
      "problemNumber": "0001",
      "title": "Two Sum",
      "language": "Java",
      "filename": "0001-TwoSum.java",
      "path": "LeetCode/Java/0001-TwoSum.java",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Java/0001-TwoSum.java",
      "approach": "Using HashMap",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/**\n * Solution: https://leetcode.com/problems/two-sum/solutions/6550757/simplest-solution-java-time-on-spacen-pl-cxpv/\n * Approach: Using HashMap\n * 1. Create a HashMap to store the number and its index.\n * 2. Iterate through the array and check if the target - num is present in the HashMap.\n * 3. If it is present, return the index of the target - num and the current index.\n * 4. If it is not present, add the number and its index to the HashMap.\n * 5. If no such pair is found, return result.\n *\n * Time Complexity: O(n)\n * Space Complexity: O(n)\n */\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> hmap = new HashMap<Integer,Integer>(); // Declare a HashMap\n        int index = 0;                                                  // Declare a variable to store the index\n        int[] result = new int[2];                                      // Declare a result array to store the indices\n        for(int num : nums) {                                           // Iterate through the array\n            if(!hmap.containsKey(target-num)) {                         // Check if the target - num is present in the HashMap\n                hmap.put(num,index);                                    // If not present, add the number and its index to the HashMap\n            }\n            else {\n                result[0]=hmap.get(target-num);                         // If present, return the index of the target - num\n                result[1]= index;                                       // and the current index\n                return result;                                          // Return the result\n            }\n            index++;                                                    // Increment the index\n        }                                                               // End of loop\n        return result;                                                  // Return the result if no such pair is found\n    }\n}"
    },
    {
      "problemNumber": "0001",
      "title": "Two Sum",
      "language": "Python",
      "filename": "0001-TwoSum.py",
      "path": "LeetCode/Python/0001-TwoSum.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/0001-TwoSum.py",
      "approach": "1. Create a hashmap to store the index of the elements.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n) - We iterate through the list of numbers once.",
      "spaceComplexity": "O(n) - We store the indices of the numbers in the hashmap.",
      "solutionLink": "",
      "code": "'''\nApproach:\n1. Create a hashmap to store the index of the elements.\n2. Iterate through the list of numbers.\n3. For each number, calculate the difference between the target and the number.\n4. If the difference is already present in the hashmap, return the indices of the current number and the difference.\n5. Else, store the current number and its index in the hashmap.\n6. If no such pair is found, return an empty list.\n\nTime complexity:\nO(n) - We iterate through the list of numbers once.\n\nSpace complexity:\nO(n) - We store the indices of the numbers in the hashmap.\n\n'''\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i, num in enumerate(nums):\n            diff = target - num\n            if diff in hashmap:\n                return [i, hashmap[diff]]\n            hashmap[num] = i\n        return []"
    },
    {
      "problemNumber": "0002",
      "title": "Add Two Numbers",
      "language": "C#",
      "filename": "0002-AddTwoNumbers.cs",
      "path": "LeetCode/C#/0002-AddTwoNumbers.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0002-AddTwoNumbers.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution\n{\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2)\n    {\n        // corner case\n        \n        ListNode head, temp, prev;\n        int num1,num2,carry =0,sum;\n\n        head = new ListNode();\n        prev =  head;\n        while(l1 != null || l2 != null) {\n              \n            num1 = l1 != null ? l1.val : 0;\n            num2 = l2 != null ? l2.val : 0;\n            \n            sum = num1 + num2 + carry;\n            \n            if (sum >= 10) {\n                sum = sum % 10;\n                carry = 1;\n            }\n            else {\n                carry = 0;\n            }\n            \n            temp = new ListNode();\n            temp.val = sum;\n            temp.next = null;\n            prev.next = temp;\n            prev = temp;\n            \n            \n            \n            l1 = l1 == null ? l1 : l1.next;\n            l2 = l2 == null ? l2 : l2.next;           \n        \n        }\n        if(carry > 0) {\n            temp = new ListNode();\n            temp.val = 1;\n            temp.next = null;\n            prev.next = temp;\n            prev = temp;\n        }\n        return head.next; \n    }\n\n}\n"
    },
    {
      "problemNumber": "0003",
      "title": "Longest Sub String Without Repeating Characters",
      "language": "C#",
      "filename": "0003-LongestSubStringWithoutRepeatingCharacters.cs",
      "path": "LeetCode/C#/0003-LongestSubStringWithoutRepeatingCharacters.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0003-LongestSubStringWithoutRepeatingCharacters.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Animation https://www.interviewbit.com/blog/wp-content/uploads/2021/10/Image-1-7-768x633.png\n// Test Cases\n// \"abcabcbb\"\n// \"bbbbb\"\n// \"pwwkew\"\n// \"dvdf\"\n// \"xxzqi\"\n\n\n// Solution only one loop\npublic class Solution {\n    public int LengthOfLongestSubstring(string s) {\n        \n        if(s.Length==0)\n            return 0;\n        int currentMax = 0;\n        int max = 0;\n        int startSlidingWindow = 0;\n        int endSlidingWindow = 0;\n        int charIndex = 0;\n        Dictionary<char,int> uniqueCharacters = new Dictionary<char,int>();\n        while(endSlidingWindow >= startSlidingWindow && charIndex < s.Length) {\n            if(!uniqueCharacters.ContainsKey(s[charIndex])) {\n                uniqueCharacters.TryAdd(s[charIndex],1);\n                endSlidingWindow++;\n                currentMax++;\n            }\n            else {\n                startSlidingWindow++;\n                endSlidingWindow = startSlidingWindow;\n                uniqueCharacters.Clear();\n                if(max < currentMax) {\n                    max = currentMax;\n                }\n                currentMax = 0;\n                charIndex = startSlidingWindow -1;\n            }\n            charIndex++;\n        }\n        \n        return max > currentMax ? max : currentMax; // special case to handle \" \"\n    }\n}\n\n// public class Solution\n// {\n//     public int LengthOfLongestSubstring(string s)\n//     {\n//         if (s.Length == 0) {\n//             return 0;\n//         }\n        \n//          if (s.Length == 1) {\n//             return 1;\n//         }\n        \n//         int startWindow = 0;\n//         int endWindow = 0;\n//         int max = 0 ;\n//         Dictionary<char,int> map = new Dictionary<char,int>();\n\n//         while(endWindow < s.Length) {\n            \n//             if(!map.ContainsKey(s[endWindow])) {\n//                 map.Add(s[endWindow],1);                            \n//             }\n//             else{\n//                 int valueKey = map[s[endWindow]];\n//                 map[s[endWindow]] = valueKey + 1;\n//             }\n            \n//             while(map.ContainsKey(s[endWindow]) && map[s[endWindow]] > 1 ) {\n\n//                 int valueKey = map[s[startWindow]];\n//                 map[s[startWindow]] = valueKey - 1;\n\n//                 startWindow++;\n//             }            \n                \n//              max = Math.Max(max,endWindow - startWindow + 1);\n//              endWindow++;     \n//         }\n//         return max;\n//     }               \n// }\n\n\n// Better Space InterviewBit Solution.\n// public class Solution\n// {\n//     public int LengthOfLongestSubstring(string s)\n//     {\n//         int[] chars = new int[128];\n \n//         int left = 0;\n//         int right = 0;\n \n//         int res = 0;\n//         while (right < s.Length) {\n//             char r = s[right];\n//             chars[r]++;\n \n//             while (chars[r] > 1) {\n//                 char l = s[left];\n//                 chars[l]--;\n//                 left++;\n//             }\n \n//             res = Math.Max(res, right - left + 1);\n \n//             right++;\n//         }\n//         return res;\n//     }               \n// }\n"
    },
    {
      "problemNumber": "0009",
      "title": "Palindrome Number",
      "language": "C#",
      "filename": "0009-PalindromeNumber.cs",
      "path": "LeetCode/C#/0009-PalindromeNumber.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0009-PalindromeNumber.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public bool IsPalindrome(int x) {\n        if ( x < 0) {\n            return false;\n        }\n        \n        string num = x.ToString();\n        for(int index = 0 ; index <= num.Length/2 ; index++ ) {\n            if(num[index] != num[num.Length - 1 - index]) {\n                return false;\n            }\n        }\n        return true;\n        \n    }\n}"
    },
    {
      "problemNumber": "0011",
      "title": "Container With Most Water",
      "language": "C#",
      "filename": "0011-ContainerWithMostWater.cs",
      "path": "LeetCode/C#/0011-ContainerWithMostWater.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0011-ContainerWithMostWater.cs",
      "approach": "1) Initialize the area, left and right pointers",
      "tags": [],
      "steps": [
        "1) Initialize the area, left and right pointers",
        "2) Iterate through the array",
        "3) Calculate the area using the formula: area = Math.Max( (right - left) * (Math.Min(height[right],height[left])) ,area)",
        "4) If the height of the left pointer is less than the height of the right pointer, increment the left pointer",
        "5) If the height of the left pointer is greater than the height of the right pointer, decrement the right pointer",
        "6) Return the area"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize the area, left and right pointers\n2) Iterate through the array\n3) Calculate the area using the formula: area = Math.Max( (right - left) * (Math.Min(height[right],height[left])) ,area)\n4) If the height of the left pointer is less than the height of the right pointer, increment the left pointer\n5) If the height of the left pointer is greater than the height of the right pointer, decrement the right pointer\n6) Return the area\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n*/\npublic class Solution {\n    public int MaxArea(int[] height) {\n        int left, right, area;                                                                      // Initialize the area, left and right pointers\n        area = left = 0;                                                                            // Initialize the area and left pointer\n        right = height.Length - 1;                                                                  // Initialize the right pointer\n\n        while(left < right) {                                                                       // Iterate through the array\n            area = Math.Max( (right - left) * (Math.Min(height[right],height[left])) ,area);        // Calculate the area\n            if (height[left] < height[right])                                                       // If the height of the left pointer is less than the height of the right pointer, increment the left pointer\n                left++;\n            else\n                right--;\n        }\n        return area;                                                                                // Return the area\n    }\n}"
    },
    {
      "problemNumber": "0014",
      "title": "Longest Common Prefix",
      "language": "C#",
      "filename": "0014-LongestCommonPrefix.cs",
      "path": "LeetCode/C#/0014-LongestCommonPrefix.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0014-LongestCommonPrefix.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Check all strings char by char.\npublic class Solution {\n    public string LongestCommonPrefix(string[] strs) {\n\n        StringBuilder result = new StringBuilder();\n\n        for (int i=0; i<strs[0].Length; i++) { // randomly first string taken, any string can be taken best would be smallest.\n\n            foreach(string s in strs) {\n\n                if(i == s.Length || strs[0][i] != s[i]) { //  First condition will check if any other string is less than first string.\n                    return result.ToString();\n                }\n            }\n            result.Append(strs[0][i]);\n        }\n\n        return result.ToString();        \n    }\n}\n"
    },
    {
      "problemNumber": "0015",
      "title": "3 Sum",
      "language": "C#",
      "filename": "0015-3Sum.cs",
      "path": "LeetCode/C#/0015-3Sum.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0015-3Sum.cs",
      "approach": "1. Sort the array",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Sort the array\n2. Iterate through the array\n3. For each element, use two pointers to find the other two elements\n4. If the sum of the three elements is greater than 0, decrement the right pointer\n5. If the sum of the three elements is less than 0, increment the left pointer\n\nTime complexity: O(n^2)\nSpace complexity: O(1)\n\n*/\npublic class Solution {\n    public IList<IList<int>> ThreeSum(int[] nums) {\n\n        IList<IList<int>> result = new List<IList<int>>();                                              // List to store the result\n        int  left, right;                                                                               // Pointers to find the other two elements\n        Array.Sort(nums);                                                                               // Sort the array\n\n        for(int i=0; i< nums.Length; i++) {                                                             // Iterate through the array\n            if(i > 0 && nums[i] == nums[i-1])                                                           // Skip the duplicate elements. num1\n                continue;\n            left = i+1;                                                                                 // Initialize the left pointer\n            right = nums.Length - 1;                                                                    // Initialize the right pointer\n\n            while(left< right) {                                                                        // Iterate through the array\n                if( (nums[i] + nums[left] + nums[right]) > 0) {                                         // If the sum of the three elements is greater than 0, decrement the right pointer\n                    right--;\n                }\n                else if( (nums[i] + nums[left] + nums[right]) < 0) {                                    // If the sum of the three elements is less than 0, increment the left pointer\n                    left++;\n                }\n                else {                                                                                  // If the sum of the three elements is equal to 0, add the elements to the result\n                    result.Add(new List<int>{nums[i],nums[left],nums[right]});\n                    left++;                                                                             // Increment the left pointer\n\n                    while(nums[left] == nums[left-1] && left < right) {                                 // Skip the duplicate elements. left num. No need to skip right num as it will be decremented next iteration\n                        left++;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}"
    },
    {
      "problemNumber": "0019",
      "title": "Remove Nth Node From Endof List",
      "language": "C#",
      "filename": "0019-RemoveNthNodeFromEndofList.cs",
      "path": "LeetCode/C#/0019-RemoveNthNodeFromEndofList.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0019-RemoveNthNodeFromEndofList.cs",
      "approach": "1. Create a dummy node and assign it to the head of the list.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a dummy node and assign it to the head of the list.\n2. Create two pointers left and right and assign them to the dummy node.\n3. Move the right pointer n times.\n4. Move both the pointers until the right pointer reaches the end of the list.\n5. The left pointer will be at the node before the node to be deleted.\n6. Remove the node by assigning left.next to left.next.next.\n7. Return the dummy node's next.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        ListNode left, right, temp;         // Create two pointers left and right and a temporary node.\n        right = head;                       // Assign right to the head of the list.\n        temp = new ListNode(-1, head);      // Create a dummy node and assign it to the head of the list.\n        left = temp;                        // Assign left to the dummy node.\n        while(n > 0) {                      // Move the right pointer n times.\n            right = right.next;             // Move the right pointer.\n            n--;                            // Decrement n.\n        }\n        while(right != null) {              // Move both the pointers until the right pointer reaches the end of the list.\n            left = left.next;               // Move the left pointer.\n            right = right.next;             // Move the right pointer.\n        }\n        left.next = left.next.next;         // Remove the node by assigning left.next to left.next.next.\n        return temp.next;                   // Return the dummy node's next.\n    }\n}"
    },
    {
      "problemNumber": "0020",
      "title": "Valid Parentheses",
      "language": "C#",
      "filename": "0020-ValidParentheses.cs",
      "path": "LeetCode/C#/0020-ValidParentheses.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0020-ValidParentheses.cs",
      "approach": "1. Create a stack to store the opening brackets.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a stack to store the opening brackets.\n2. Iterate through the string.\n3. If the character is an opening bracket, push it to the stack.\n4. If the character is a closing bracket, check if the stack is empty. If it is, return false.\n5. If the stack is not empty, check if the top of the stack is the corresponding opening bracket. If it is not, return false.\n6. If the top of the stack is the corresponding opening bracket, pop it from the stack.\n7. If the stack is empty after the iteration, return true. Otherwise, return false.\n\nTime complexity: O(n)\n\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public bool IsValid(string s) {\n        Stack<char> pstack = new Stack<char>();\n        foreach(var c in s) {\n            switch(c) {\n                case '(':\n                case '[':\n                case '{':\n                    pstack.Push(c);\n                    break;\n                case ')':\n                    if (pstack.Count() == 0) return false;\n                    if (pstack.Peek() != '(') return false;\n                    pstack.Pop();\n                    break;\n                case ']':\n                    if (pstack.Count() == 0) return false;\n                    if (pstack.Peek() != '[') return false;\n                    pstack.Pop();\n                    break;\n                case '}':\n                    if (pstack.Count() == 0) return false;\n                    if (pstack.Peek() != '{') return false;\n                    pstack.Pop();\n                    break;\n            }\n        }\n        return pstack.Count() == 0 ? true : false;\n    }\n}\n"
    },
    {
      "problemNumber": "0021",
      "title": "Merge Two Sorted Lists",
      "language": "C#",
      "filename": "0021-MergeTwoSortedLists.cs",
      "path": "LeetCode/C#/0021-MergeTwoSortedLists.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0021-MergeTwoSortedLists.cs",
      "approach": "1. Create a dummy node and a node to keep track of the current node.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n + m) where n is the number of nodes in the first list and m is the number of nodes in the second list.",
      "spaceComplexity": "O(1) as we are not using any extra space.",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a dummy node and a node to keep track of the current node.\n2. Traverse through both the lists and compare the values of the nodes.\n3. If the value of the first list is less than the value of the second list, then add the first list node to the current node and move the first list node to the next node.\n4. If the value of the first list is greater than the value of the second list, then add the second list node to the current node and move the second list node to the next node.\n5. Move the current node to the next node.\n6. If the first list is not null, then add the remaining nodes of the first list to the current node.\n7. If the second list is not null, then add the remaining nodes of the second list to the current node.\n8. Return the next node of the dummy node.\n\nTime Complexity: O(n + m) where n is the number of nodes in the first list and m is the number of nodes in the second list.\nSpace Complexity: O(1) as we are not using any extra space.\n\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);           // Create a dummy node\n        ListNode node = dummy;                      // Create a node to keep track of the current node\n\n        while(list1 != null && list2 != null) {     // Traverse through both the lists\n            if(list1.val < list2.val) {             // Compare the values of the nodes\n                node.next = list1;                  // If the value of the first list is less than the value of the second list, then add the first list node to the current node\n                list1 = list1.next;                 // Move the first list node to the next node\n            }\n            else {\n                node.next = list2;                  // If the value of the first list is greater than the value of the second list, then add the second list node to the current node\n                list2 = list2.next;                 // Move the second list node to the next node\n            }\n            node = node.next;                       // Move the current node to the next node\n        }\n        if(list1 != null) {                         // If the first list is not null, then add the remaining nodes of the first list to the current node\n            node.next = list1;                      // Add the remaining nodes of the first list to the current node\n        }\n        else {                                      // If the second list is not null, then add the remaining nodes of the second list to the current node\n            node.next = list2;                      // Add the remaining nodes of the second list to the current node\n        }\n        return dummy.next;                          // Return the next node of the dummy node\n    }\n}"
    },
    {
      "problemNumber": "0027",
      "title": "Remove Element",
      "language": "C#",
      "filename": "0027-RemoveElement.cs",
      "path": "LeetCode/C#/0027-RemoveElement.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0027-RemoveElement.cs",
      "approach": "1) Initialize left and right pointers to 0 and nums.Length - 1 respectively.",
      "tags": [],
      "steps": [
        "1) Initialize left and right pointers to 0 and nums.Length - 1 respectively.",
        "2) Iterate through the array until the left pointer is less than the right pointer.",
        "3) If the value at the right pointer is equal to the target value, decrement the right pointer.",
        "4) If the value at the right pointer is not equal to the target value, swap the values at the left and right pointers and increment the left pointer.",
        "5) Return the left pointer if the value at the left pointer is equal to the target value, otherwise return left pointer + 1."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize left and right pointers to 0 and nums.Length - 1 respectively.\n2) Iterate through the array until the left pointer is less than the right pointer.\n3) If the value at the right pointer is equal to the target value, decrement the right pointer.\n4) If the value at the right pointer is not equal to the target value, swap the values at the left and right pointers and increment the left pointer.\n5) Return the left pointer if the value at the left pointer is equal to the target value, otherwise return left pointer + 1.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n\n*/\npublic class Solution {\n    public int RemoveElement(int[] nums, int val) {\n\n        int left, right, temp;\n        left = temp = 0;\n        right = nums.Length - 1;\n\n        if (nums== null || nums.Length == 0) return 0;\n\n        while (left < right) {\n            while(nums[right] == val && left < right) {\n                right--;\n            }\n\n            if(nums[right] != val) {\n                temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] = temp;\n                left++;\n            }\n        }\n\n        return nums[left] == val ? left : left + 1;\n    }\n}"
    },
    {
      "problemNumber": "0033",
      "title": "Searchin Rotated Sorted Array",
      "language": "C#",
      "filename": "0033-SearchinRotatedSortedArray.cs",
      "path": "LeetCode/C#/0033-SearchinRotatedSortedArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0033-SearchinRotatedSortedArray.cs",
      "approach": "Modified Binary Search",
      "tags": [
        "Array",
        "Binary Search",
        "Divide and Conquer"
      ],
      "steps": [
        "1) Use binary search with left and right pointers.",
        "2) Check if mid element equals target, return index if found.",
        "3) Determine which half of the array is sorted (left or right).",
        "4) Check if target lies within the sorted half's range.",
        "5) If target is in sorted half, search that half; otherwise search the other half.",
        "6) Return -1 if target is not found after exhausting search space."
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/7042000/simplest-solution-c-time-olog-n-space1-p-5knq/\nApproach: Modified Binary Search\nTags: Array, Binary Search, Divide and Conquer\n1) Use binary search with left and right pointers.\n2) Check if mid element equals target, return index if found.\n3) Determine which half of the array is sorted (left or right).\n4) Check if target lies within the sorted half's range.\n5) If target is in sorted half, search that half; otherwise search the other half.\n6) Return -1 if target is not found after exhausting search space.\n\nTime Complexity: O(log n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int Search(int[] nums, int target) {\n        int left = 0;                                               // Left pointer for binary search\n        int right = nums.Length - 1;                                // Right pointer for binary search\n\n        while (left <= right) {                                     // Continue while search space exists\n            int mid = left + (right - left) / 2;                    // Calculate mid point to avoid overflow\n\n            if (nums[mid] == target)                                // If target found at mid\n                return mid;                                         // Return the index\n\n            // Left half is sorted\n            if (nums[left] <= nums[mid]) {                          // Check if left half is sorted\n                if (nums[left] <= target && target < nums[mid]) {   // If target is in left sorted half\n                    right = mid - 1;                                // Search left half\n                } else {                                            // Target is not in left half\n                    left = mid + 1;                                 // Search right half\n                }\n            }\n            // Right half is sorted\n            else {                                                  // Right half must be sorted\n                if (nums[mid] < target && target <= nums[right]) {  // If target is in right sorted half\n                    left = mid + 1;                                 // Search right half\n                } else {                                            // Target is not in right half\n                    right = mid - 1;                                // Search left half\n                }\n            }\n        }\n\n        return -1;                                                  // Target not found, return -1\n    }\n}\n\n // [4,5,6,7,0,1,2] target = 0\n\n//[6,8,9,34,45,67,1] target = 1\n\n// [67,1,2,3,4,5,6] target = 67"
    },
    {
      "problemNumber": "0035",
      "title": "Search Insert Position",
      "language": "C#",
      "filename": "0035-SearchInsertPosition.cs",
      "path": "LeetCode/C#/0035-SearchInsertPosition.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0035-SearchInsertPosition.cs",
      "approach": "Binary Search",
      "tags": [],
      "steps": [
        "1) Initialize the left and right pointers",
        "2) Iterate through the array",
        "3) Calculate the mid",
        "4) If the mid element is equal to the target, return the mid",
        "5) If the mid element is less than the target, increment the left pointer",
        "6) If the mid element is greater than the target, decrement the right pointer",
        "7) Return the left pointer"
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Binary Search\n1) Initialize the left and right pointers\n2) Iterate through the array\n3) Calculate the mid\n4) If the mid element is equal to the target, return the mid\n5) If the mid element is less than the target, increment the left pointer\n6) If the mid element is greater than the target, decrement the right pointer\n7) Return the left pointer\nTime complexity: O(log n)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int SearchInsert(int[] nums, int target) {\n        int left = 0;                   // Initialize the left pointer\n        int right = nums.Length - 1 ;   // Initialize the right pointer\n        int mid = (right+left)/2;       // Calculate the mid\n\n        while(left<=right) {            // Iterate through the array\n            mid =(right+left)/2;        // Calculate the mid\n\n            if(nums[mid] == target) {   // If the mid element is equal to the target, return the mid\n                return mid;             // Return the mid\n            }\n\n            if (nums[mid] > target) {   // If the mid element is greater than the target, decrement the right pointer\n                right = mid - 1;        // Decrement the right pointer\n            }\n            else {                      // If the mid element is less than the target, increment the left pointer\n                left = mid + 1;         // Increment the left pointer\n            }\n        }\n\n        return left;                    // Return the left pointer if the target is not found\n    }\n}"
    },
    {
      "problemNumber": "0036",
      "title": "Valid Sudoku",
      "language": "C#",
      "filename": "0036-ValidSudoku.cs",
      "path": "LeetCode/C#/0036-ValidSudoku.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0036-ValidSudoku.cs",
      "approach": "1. Check if the rows are valid.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Check if the rows are valid.\n2. Check if the columns are valid.\n3. Check if the boxes are valid.\n4. If all the above conditions are satisfied, return true.\n5. Otherwise, return false.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution\n{\n    public bool IsValidSudoku(char[][] board)\n    {\n        return CheckRows(board) && CheckColumns(board) && CheckBoxes(board);\n    }\n\n    static bool CheckBoxes(char[][] board)\n    {\n        int startRow = 0;\n        int startColumn = 0;\n        for (int i = 0; i < 3; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                bool isCompliant = CheckBox(board, startRow, startColumn);\n                if (!isCompliant) return false;\n                startColumn = startColumn + 3;\n            }\n            startColumn = 0;\n            startRow = startRow + 3;\n        }\n        return true;\n    }\n\n    static bool CheckBox(char[][] board, int startRow, int startColumn)\n    {\n        HashSet<char> set = new HashSet<char>();\n        for (int i = startRow; i < startRow + 3; i++)\n        {\n            for (int j = startColumn; j < startColumn + 3; j++)\n            {\n                if (board[i][j] == '.') continue;\n\n                if (set.Contains(board[i][j]))\n                {\n                    return false;\n                }\n                else\n                {\n                    set.Add(board[i][j]);\n                }\n            }\n        }\n        return true;\n    }\n\n    static bool CheckColumns(char[][] board)\n    {\n        HashSet<char> set = new HashSet<char>();\n\n        for (int column = 0; column < board.Length; column++)\n        {\n            for (int row = 0; row < board[column].Length; row++)\n            {\n                if (board[row][column] == '.') continue;\n\n                if (set.Contains(board[row][column]))\n                {\n                    return false;\n                }\n                else\n                {\n                    set.Add(board[row][column]);\n                }\n            }\n            set.Clear();\n        }\n        return true;\n    }\n\n    static bool CheckRows(char[][] board)\n    {\n        HashSet<char> set = new HashSet<char>();\n        for (int row = 0; row < board.Length; row++)\n        {\n            for (int column = 0; column < board[row].Length; column++)\n            {\n                if (board[row][column] == '.') continue;\n\n                if (set.Contains(board[row][column]))\n                {\n                    return false;\n                }\n                else\n                {\n                    set.Add(board[row][column]);\n                }\n            }\n            set.Clear();\n        }\n        return true;\n    }\n\n}"
    },
    {
      "problemNumber": "0041",
      "title": "First Missing Positive",
      "language": "C#",
      "filename": "0041-FirstMissingPositive.cs",
      "path": "LeetCode/C#/0041-FirstMissingPositive.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0041-FirstMissingPositive.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/**\nApproach 1:\nUse Sorting and then find first missing number\n\nApproach 2:\nUse HashSet to insert the numbers and then in second iteration check which number is missing\n\nApproach 3:\nUse the array itself to store which number is present\n    1) Replace all negative numbers to zero\n    2) Replace numbers if lies between (absolute value from 1 to Len(A))\n        if gt 0\n            num = -1*num\n        if eq 0\n            num = -1* Len(A+1)\n    3) return first value greater than zero\n\n\n*/\npublic class Solution {\n    public int FirstMissingPositive(int[] nums) {\n        for (int i=0; i<nums.Length; i++) {\n            if(nums[i] < 0) {\n                nums[i] = 0;\n            }\n        }\n\n        for (int i=0; i<nums.Length; i++) {\n            int val = Math.Abs(nums[i]);\n            if(val >=1 && val <= nums.Length) { //if current num lies between [1 to Len(Num)]\n                if (nums[val-1] > 0)\n                    nums[val-1] *= -1;\n                else if(nums[val-1] ==0) // value is zero it's corner case\n                    nums[val-1] = -1 * (nums.Length+1);\n            }\n\n        }\n\n        for(int i=1; i<nums.Length+1 ;i++) {\n            if(nums[i-1] >= 0)\n                return i;\n        }\n        return nums.Length + 1;\n    }\n}"
    },
    {
      "problemNumber": "0049",
      "title": "Group Anagrams",
      "language": "C#",
      "filename": "0049-GroupAnagrams.cs",
      "path": "LeetCode/C#/0049-GroupAnagrams.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0049-GroupAnagrams.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "\n// Approach 1\n// Use Dictionary to insert array sorted element as key and all elements as values.\npublic class Solution {\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\n        Dictionary<string,IList<string>> dict = new Dictionary<string,IList<string>>();\n        foreach(string s in strs) {\n            var key = new string(s.OrderBy(c=>c).ToArray());\n            if(dict.ContainsKey(key)) {\n                dict[key].Add(s);\n            }\n            else{\n                dict.Add(key,new List<string>(){s});\n            }\n        }\n        return dict.Values.ToList();\n    }\n}"
    },
    {
      "problemNumber": "0058",
      "title": "Lengthof Last Word",
      "language": "C#",
      "filename": "0058-LengthofLastWord.cs",
      "path": "LeetCode/C#/0058-LengthofLastWord.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0058-LengthofLastWord.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public int LengthOfLastWord(string s) {        \n        int result = 0;\n        int fspace = 0;\n        int index = s.Length - 1;\n        while (s[index] == ' ') {\n            index--;\n        }\n        while (index >= 0 && s[index] != ' ' ) {\n            index--;\n            result++;\n        }        \n        return result;\n    }\n}\n"
    },
    {
      "problemNumber": "0061",
      "title": "Rotate List",
      "language": "C#",
      "filename": "0061-RotateList.cs",
      "path": "LeetCode/C#/0061-RotateList.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0061-RotateList.cs",
      "approach": "1. Find the length of the list.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Find the length of the list.\n2. Find the new head of the list.\n3. Break the list at the new head.\n4. Connect the end of the list to the original head.\n5. Return the new head.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RotateRight(ListNode head, int k) {\n\n        if (head == null || head.next == null || k == 0)            // if list is empty or has only one node or k is zero\n            return head;                                            // return null\n\n        // Find Length of the list\n        ListNode ptr , prev, newHead;                               // pointers for finding the length of the list\n        int lengthList = 0;                                         // length of the list\n        ptr = head;                                                 // starting from the head of the list\n        prev = null;                                                // previous node of the current node\n        while(ptr != null) {                                        // until the end of the list\n            prev = ptr;                                             // updating the previous node\n            ptr = ptr.next;                                         // moving to the next node\n            lengthList++;                                           // updating the length of the list\n        }\n        k = k % lengthList;                                         // finding the actual value of k\n        if (k==0)                                                   // if k is zero\n            return head;                                            // return the original list\n\n        int newHeadPosition = lengthList - k - 1;                   // position of the new head\n        ptr = head;                                                 // starting from the head of the list\n        while(newHeadPosition > 0) {                                // until the new head position\n            ptr = ptr.next;                                         // moving to the next node\n            newHeadPosition--;                                      // updating the new head position\n        }\n\n        newHead = ptr.next;                                         // new head of the list\n        ptr.next = null;                                            // breaking the list at the new head\n        prev.next = head;                                           // connecting the end of the list to the original head\n\n        return newHead;                                             // return the new head\n\n\n    }\n}"
    },
    {
      "problemNumber": "0070",
      "title": "Climbing Stairs",
      "language": "C#",
      "filename": "0070-ClimbingStairs.cs",
      "path": "LeetCode/C#/0070-ClimbingStairs.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0070-ClimbingStairs.cs",
      "approach": "Recursion with Memoization",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursion with Memoization\n1. If n is 0, then there is only 1 way to climb the stairs.\n2. If n is less than 0, then there is no way to climb the stairs.\n3. If dp[n] is not -1, then return dp[n].\n4. Otherwise, return FindClimbStairs(n-1,dp) + FindClimbStairs(n-2,dp).\n5. FindClimbStairs is a recursive function which calculates the number of ways to climb the stairs.\n6. If n is 0, then there is only 1 way to climb the stairs.\n7. If n is less than 0, then there is no way to climb the stairs.\n8. If dp[n] is not -1, then return dp[n].\n9. Otherwise, return FindClimbStairs(n-1,dp) + FindClimbStairs(n-2,dp).\n10. dp[n] is set to FindClimbStairs(n-1,dp) + FindClimbStairs(n-2,dp).\n11. Return dp[n].\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int ClimbStairs(int n) {\n        if (n==0) {                                                     // base case you reached the top\n            return 1;                                                   // there is only 1 way to reach the top\n        }\n        if (n < 0) {                                                    // base case you went above the top\n            return 0;                                                   // there is no way to reach the top\n        }\n        int[] dp = new int[n+1];                                        // create a dp array of size n+1\n        for(int i=0;i<dp.Length;i++) {                                  // iterate through the dp array\n            dp[i] = -1;                                                 // set all the values to -1\n        }\n        if(dp[n] != -1) {                                               // if dp[n] is not -1\n            return dp[n];                                               // return dp[n]\n        }\n        return FindClimbStairs(n-1,dp) + FindClimbStairs(n-2,dp);       // return the number of ways to climb the stairs\n    }\n\n    public static int FindClimbStairs(int n, int[] dp) {                // recursive function to calculate the number of ways to climb the stairs\n        if (n==0) {                                                     // base case you reached the top\n            return 1;                                                   // there is only 1 way to reach the top\n        }\n        if (n < 0) {                                                    // base case you went above the top\n            return 0;                                                   // there is no way to reach the top\n        }\n        if(dp[n] != -1) {                                               // if dp[n] is not -1\n            return dp[n];                                               // return dp[n]\n        }\n        dp[n] = FindClimbStairs(n-1,dp) + FindClimbStairs(n-2,dp);      // set dp[n] to the number of ways to climb the stairs\n        return dp[n];                                                   // return dp[n]\n    }\n}"
    },
    {
      "problemNumber": "0073",
      "title": "Set Mtarix Zeroes",
      "language": "C#",
      "filename": "0073-SetMtarixZeroes.cs",
      "path": "LeetCode/C#/0073-SetMtarixZeroes.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0073-SetMtarixZeroes.cs",
      "approach": "Iterative",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/set-matrix-zeroes/solutions/6768863/simplest-solution-c-time-omn-space1-plea-wpzy/\nApproach: Iterative\n1. Check if the first row and first column need to be set to zero.\n2. Use the first row and first column to mark which rows and columns need to be set to zero.\n3. Set the elements in the marked rows and columns to zero.\n4. Finally, set the first row and first column to zero if they were marked.\n\nTime Complexity: O(m*n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public void SetZeroes(int[][] matrix) {\n        bool firstColumnImpacted = false;                               // declare a boolean variable to check if the first column is impacted\n        bool firstRowImpacted = false;                                  // declare a boolean variable to check if the first row is impacted\n\n        int rows = matrix.Length;                                       // get the number of rows\n        int columns = matrix[0].Length;                                 // get the number of columns\n\n        for(int i=0; i<rows; i++) {                                     // check if the first column is impacted\n            if (matrix[i][0] == 0) {                                    // if the first column is impacted\n                firstColumnImpacted = true;                             // if the first column is impacted, set the boolean variable to true\n                break;                                                  // break the loop\n            }\n        }\n\n        for(int i=0; i<columns; i++) {                                  // check if the first row is impacted\n            if (matrix[0][i] == 0) {                                    // if the first row is impacted\n                firstRowImpacted = true;                                // if the first row is impacted, set the boolean variable to true\n                break;                                                  // break the loop\n            }\n        }\n\n        for(int i=1; i<rows; i++) {                                     // check if the first row and first column need to be set to zero\n            for(int j=1; j<columns; j++) {                              // check if the first row and first column need to be set to zero\n\n                if(matrix[i][j] == 0) {                                 // if the element is zero\n                    matrix[i][0] = 0;                                   // set the first column to zero\n                    matrix[0][j] = 0;                                   // set the first row to zero\n                }\n            }\n        }\n\n        for(int i=1; i<rows; i++) {                                     // set the elements in the marked rows and columns to zero\n            for(int j=1; j<columns; j++) {                              // set the elements in the marked rows and columns to zero\n\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {            // if the first column or first row is zero\n                    matrix[i][j] = 0;                                   // set the element to zero\n                }\n            }\n        }\n\n        if(firstRowImpacted) {                                          // check if the first row is impacted\n            for(int i=0; i<columns; i++) {                              // set the first row to zero\n                matrix[0][i] = 0;                                       // set the first row to zero\n            }\n        }\n\n        if(firstColumnImpacted) {                                       // check if the first column is impacted\n            for(int i=0; i<rows; i++) {                                 // set the first column to zero\n                matrix[i][0] = 0;                                       // set the first column to zero\n            }\n        }\n    }\n}"
    },
    {
      "problemNumber": "0075",
      "title": "Sort Colors",
      "language": "C#",
      "filename": "0075-SortColors.cs",
      "path": "LeetCode/C#/0075-SortColors.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0075-SortColors.cs",
      "approach": "Two Pointers",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n), where n is the length of the input array.",
      "spaceComplexity": "O(1), as we are sorting the array in place without using any additional data structures.",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/sort-colors/solutions/6869499/simplest-solution-c-time-on-space1-pleas-83hk/\nApproach: Two Pointers\n1. Initialize three pointers: `start` at the beginning, `mid` at the beginning, and `end` at the last index of the array.\n2. Iterate through the array using the `mid` pointer:\n   - If `nums[mid]` is 0, swap it with `nums[start]`, increment both `start` and `mid`.\n   - If `nums[mid]` is 1, just increment `mid`.\n   - If `nums[mid]` is 2, swap it with `nums[end]` and decrement `end`.\n   - Continue this process until `mid` exceeds `end`.\nTime Complexity: O(n), where n is the length of the input array.\nSpace Complexity: O(1), as we are sorting the array in place without using any additional data structures.\n*/\npublic class Solution\n{\n    public void SortColors(int[] nums)\n    {\n        int start = 0;                              // Pointer for the next position of 0\n        int mid = 0;                                // Pointer for the current element being evaluated\n        int end = nums.Length - 1;                  // Pointer for the next position of 2\n\n        while (mid <= end)                          // Continue until mid pointer exceeds end pointer\n        {\n            switch (nums[mid])                      // Check the value at the mid pointer\n            {\n                case 0:                             // If the value is 0, swap it with the value at the start pointer\n                    swap(nums, start, mid);         // Swap the values at start and mid\n                    start++;                        // Increment the start pointer\n                    mid++;                          // Increment the mid pointer to evaluate the next element\n                    break;                          // break;\n                case 1:                             // If the value is 1, just move the mid pointer forward\n                    mid++;                          // Increment the mid pointer to evaluate the next element\n                    break;                          // break;\n                case 2:                             // If the value is 2, swap it with the value at the end pointer\n                    swap(nums, end, mid);           // Swap the values at end and mid\n                    end--;                          // Decrement end pointer\n                    break;                          // break;\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j)     // Helper method to swap two elements in the array\n    {\n        int temp = nums[i];                         // Store the value at index i in a temporary variable\n        nums[i] = nums[j];                          // Assign the value at index j to index i\n        nums[j] = temp;                             // Assign the value of temp (originally nums[i]) to index j\n    }\n}"
    },
    {
      "problemNumber": "0076",
      "title": "Minimum Window Substring",
      "language": "C#",
      "filename": "0076-MinimumWindowSubstring.cs",
      "path": "LeetCode/C#/0076-MinimumWindowSubstring.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0076-MinimumWindowSubstring.cs",
      "approach": "Two Pointers (Sliding Window)",
      "tags": [
        "String",
        "Hash Table",
        "Sliding Window",
        "Two Pointers"
      ],
      "steps": [
        "1) Use a dictionary to count characters in target string t.",
        "2) Use two pointers (left and right) to maintain a sliding window.",
        "3) Expand the window by moving right pointer until all characters are included.",
        "4) Contract the window by moving left pointer while maintaining validity.",
        "5) Track the minimum window that contains all characters of t.",
        "6) Return the minimum window substring or empty string if no valid window exists."
      ],
      "timeComplexity": "O(|s| + |t|)",
      "spaceComplexity": "O(|t|)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/minimum-window-substring/solutions/7027291/simplest-solution-c-time-on-spacen-pleas-3bvj/\nApproach: Two Pointers (Sliding Window)\nVideo: https://www.youtube.com/watch?v=3Bp3OVD1EGc\nTags: String, Hash Table, Sliding Window, Two Pointers\n1) Use a dictionary to count characters in target string t.\n2) Use two pointers (left and right) to maintain a sliding window.\n3) Expand the window by moving right pointer until all characters are included.\n4) Contract the window by moving left pointer while maintaining validity.\n5) Track the minimum window that contains all characters of t.\n6) Return the minimum window substring or empty string if no valid window exists.\n\nTime Complexity: O(|s| + |t|)\nSpace Complexity: O(|t|)\n*/\npublic class Solution {\n    public string MinWindow(string s, string t) {\n\n        if (s.Length == 0 || t.Length==0 || t.Length > s.Length)    // Handle edge cases\n            return string.Empty;\n\n        int left = 0;                                               // Left pointer for sliding window\n        int right = 0;                                              // Right pointer for sliding window\n        int minLeft = 0;                                            // Starting position of minimum window\n        int minWindowLength = int.MaxValue;                         // Length of minimum window found\n        int need = t.Length;                                        // Count of characters still needed\n        Dictionary<char,int> dict = new Dictionary<char, int>();    // Dictionary to store character counts\n\n        // Count Chars\n        foreach (char c in t) {                                     // Iterate through each character in t\n            if (!dict.ContainsKey(c))                               // If character not in dictionary\n                dict.Add(c,1);                                      // Add character with count 1\n            else                                                    // If character already in dictionary\n                dict[c]++;                                          // Increment the count\n        }\n\n        // Slide\n        while (right < s.Length) {                                  // Expand the window by moving right pointer\n\n            char rightCh = s[right];                                // Get character at right pointer\n\n            if (dict.ContainsKey(rightCh)) {                        // If character is in target string\n                dict[rightCh]--;                                    // Decrease the count needed\n                if (dict[rightCh] >= 0) {                           // If we fulfilled a requirement\n                    need--;                                         // Decrease total characters needed\n                }\n            }\n\n            while (need == 0) {                                         // While we have a valid window\n                if ((right - left + 1) < minWindowLength) {            // If current window is smaller\n                    minWindowLength = right - left + 1;                // Update minimum window length\n                    minLeft = left;                                     // Update minimum window start position\n                }\n                char leftCh = s[left];                                  // Get character at left pointer\n                if (dict.ContainsKey(leftCh)) {                         // If character is in target string\n                    dict[leftCh]++;                                     // Increase the count needed\n                    if (dict[leftCh] > 0) {                             // If we broke a requirement\n                        need++;                                         // Increase total characters needed\n                    }\n                }\n                left++;                                                 // Move left pointer to shrink window\n            }\n            right++;                                                    // Move right pointer to expand window\n        }\n\n        return minWindowLength == int.MaxValue ? string.Empty : s.Substring(minLeft,minWindowLength);    // Return minimum window or empty string if no valid window found\n    }\n}"
    },
    {
      "problemNumber": "0083",
      "title": "Remove Duplicatesfrom Sorted List",
      "language": "C#",
      "filename": "0083-RemoveDuplicatesfromSortedList.cs",
      "path": "LeetCode/C#/0083-RemoveDuplicatesfromSortedList.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0083-RemoveDuplicatesfromSortedList.cs",
      "approach": "1. Traverse the linked list from the head node.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n), where n is the number of nodes in the linked list.",
      "spaceComplexity": "O(1).",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/6177565/simplest-solution-c-time-on-space1-pleas-y9vp/\nApproach:\n1. Traverse the linked list from the head node.\n2. If the current node and the next node have the same value, update the next pointer of the current node to the node next to the next node.\n3. Repeat the process until the current node is the last node of the linked list.\n4. Return the head node.\n\nTime complexity: O(n), where n is the number of nodes in the linked list.\nSpace complexity: O(1).\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        ListNode curr = head;                           // Declare the current node to head\n        while (curr != null && curr.next != null) {     // Traverse the linked list\n            if(curr.val == curr.next.val) {             // If the current node and the next node have the same value\n                curr.next = curr.next.next;             // Update the next pointer of the current node to the node next to the next node\n            }\n            else {\n                curr = curr.next;                       // Move to the next node\n            }\n        }\n        return head;                                    // Return the head node\n    }\n}"
    },
    {
      "problemNumber": "0094",
      "title": "Binary Tree Inorder Traversal",
      "language": "C#",
      "filename": "0094-BinaryTreeInorderTraversal.cs",
      "path": "LeetCode/C#/0094-BinaryTreeInorderTraversal.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0094-BinaryTreeInorderTraversal.cs",
      "approach": "Recursive",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursive\n1. Create a list of integers to store the result\n2. Call the Traverse method with the root and the result list\n3. Return the result list\n4. Traverse method:\n    a. Check if the root is null\n    b. Call the Traverse method with the left child of the root and the result list\n    c. Add the value of the root to the result list\n    d. Call the Traverse method with the right child of the root and the result list\n\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> InorderTraversal(TreeNode root) {\n        IList<int> result = new List<int>();                        // declare the result list\n        Traverse(root, result);                                     // call the Traverse method with the root and the result list\n        return result;                                              // return the result list\n    }\n    public static void Traverse(TreeNode root, IList<int> result) { // declare a Traverse method\n        if(root == null) {                                          // check if the root is null\n            return ;                                                // return\n        }\n        Traverse(root.left, result);                                // call the Traverse method with the left child of the root\n        result.Add(root.val);                                       // add the value of the root to the result list\n        Traverse(root.right, result);                               // call the Traverse method with the right child of the root\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\nApproach: Iterative\nTODO\n*/"
    },
    {
      "problemNumber": "0098",
      "title": "Validate Binary Search Tree",
      "language": "C#",
      "filename": "0098-ValidateBinarySearchTree.cs",
      "path": "LeetCode/C#/0098-ValidateBinarySearchTree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0098-ValidateBinarySearchTree.cs",
      "approach": "Recursive",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursive\n1. Check if the root is null, return true\n2. Check if the root value is greater than the left value and less than the right value\n3. Recursively check the left and right nodes\n4. If all the nodes satisfy the above conditions, return true\n5. Otherwise, return false\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsValidBST(TreeNode root) {\n        return IsValidNode(root, long.MinValue, long.MaxValue);                                 // Check if the root is a valid node\n    }\n\n    public bool IsValidNode(TreeNode node, long left, long right) {\n        if (node == null)                                                                       // Check if the root is null, return true\n            return true;                                                                        // If the root is null, return true\n\n        if (!(left < node.val && node.val < right))                                             // Check if the root value is greater than the left value and less than the right value\n            return false;                                                                       // If the root value is not greater than the left value and less than the right value, return false\n\n        return IsValidNode(node.left,left,node.val) && IsValidNode(node.right,node.val,right);  // Recursively check the left and right nodes\n    }\n}"
    },
    {
      "problemNumber": "0100",
      "title": "Same Tree",
      "language": "C#",
      "filename": "0100-SameTree.cs",
      "path": "LeetCode/C#/0100-SameTree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0100-SameTree.cs",
      "approach": "Recursion",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n), where n is the number of nodes in the tree.",
      "spaceComplexity": "O(n), where n is the number of nodes in the tree. The space complexity is O(n) because the maximum depth of the recursion is the height of the tree, which is O(n) in the worst case and O(logn) in the best case.",
      "solutionLink": "",
      "code": "/*\nApproach: Recursion\n1. If both the nodes are null, then they are same, so return true.\n2. If both the nodes are not null and their values are same, then check for left and right subtrees.\n3. If any of the above conditions are not met, then return false.\n\nTime complexity: O(n), where n is the number of nodes in the tree.\nSpace complexity: O(n), where n is the number of nodes in the tree. The space complexity is O(n) because the maximum depth of the recursion is the height of the tree, which is O(n) in the worst case and O(logn) in the best case.\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSameTree(TreeNode p, TreeNode q) {\n        return IsTreeSame(p, q);                                                    // Call the helper function.\n    }\n\n    public static bool IsTreeSame(TreeNode p, TreeNode q) {                         // Helper function to check if the trees are same.\n        if (p == null && q == null) {                                               // If both the nodes are null, then they are same, so return true.\n            return true;                                                            // Return true.\n        }\n        if (p != null && q != null && q.val == p.val) {                             // If both the nodes are not null and their values are same, then check for left and right subtrees.\n             return (IsTreeSame(p.left, q.left) && IsTreeSame(p.right, q.right));   // Check for left and right subtrees.\n        }\n        else {\n            return false;                                                           // If any of the above conditions are not met, then return false.\n        }\n    }\n}"
    },
    {
      "problemNumber": "0101",
      "title": "Symmetric Tree",
      "language": "C#",
      "filename": "0101-SymmetricTree.cs",
      "path": "LeetCode/C#/0101-SymmetricTree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0101-SymmetricTree.cs",
      "approach": "1. Check if the tree is symmetric or not.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Check if the tree is symmetric or not.\n2. If the tree is null, return true.\n3. Call the helper function IsInverted with left and right nodes of the root.\n4. In the helper function, check if both left and right nodes are null, return true.\n5. If any one of the left or right nodes is null, return false.\n6. Check if the values of left and right nodes are equal.\n7. Call the helper function recursively with left.right and right.left nodes.\n8. Call the helper function recursively with left.left and right.right nodes.\n9. Return the result of the above two recursive calls.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSymmetric(TreeNode root) {\n        return IsInverted(root.left, root.right);                   // Call the helper function with left and right nodes of the root.\n    }\n\n    public bool IsInverted(TreeNode left, TreeNode right) {\n\n        if (left == null && right == null)                          // If both left and right nodes are null, return true.\n            return true;\n\n        if (left == null || right == null)                          // If any one of the left or right nodes is null,\n            return false;                                           // return false.\n\n        return left.val == right.val &&                             // Check if the values of left and right nodes are equal.\n                IsInverted(left.right,right.left) &&                // Call the helper function recursively with left.right and right.left nodes.\n                IsInverted(left.left, right.right);                 // Call the helper function recursively with left.left and right.right nodes.\n\n    }\n}"
    },
    {
      "problemNumber": "0102",
      "title": "Binary Tree Level Order Traversal",
      "language": "C#",
      "filename": "0102-BinaryTreeLevelOrderTraversal.cs",
      "path": "LeetCode/C#/0102-BinaryTreeLevelOrderTraversal.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0102-BinaryTreeLevelOrderTraversal.cs",
      "approach": "1. Initialize the result list",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Initialize the result list\n2. If the root is null, return the result list\n3. Initialize the queue\n4. Enqueue the root node\n5. Iterate through the queue\n6. Initialize the level list\n7. Iterate through the queue\n8. Dequeue the current node\n9. Add the current node value to the level list\n10. If the left child is not null, enqueue the left child\n11. If the right child is not null, enqueue the right child\n12. Add the level list to the result list\n13. Return the result list\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<IList<int>> LevelOrder(TreeNode root) {\n        IList<IList<int>> result = new List<IList<int>>();  // Initialize the result list\n        if (root == null) return result;                    // If the root is null, return the result list\n\n        Queue<TreeNode> queue = new Queue<TreeNode>();      // Initialize the queue\n        queue.Enqueue(root);                                // Enqueue the root node\n\n        while (queue.Count > 0) {                           // Iterate through the queue\n            IList<int> level = new List<int>();             // Initialize the level list\n            for(int i=queue.Count; i>0; i--) {              // Iterate through the queue\n                TreeNode current = queue.Dequeue();         // Dequeue the current node\n                level.Add(current.val);                     // Add the current node value to the level list\n                if(current.left != null)                    // If the left child is not null, enqueue the left child\n                    queue.Enqueue(current.left);            // Enqueue the left child\n                if(current.right != null)                   // If the right child is not null, enqueue the right child\n                    queue.Enqueue(current.right);           // Enqueue the right child\n\n            }\n            result.Add(level);                              // Add the level list to the result list\n        }\n        return result;                                      // Return the result list\n    }\n}"
    },
    {
      "problemNumber": "0104",
      "title": "Maximum Depthof Binary Tree",
      "language": "C#",
      "filename": "0104-MaximumDepthofBinaryTree.cs",
      "path": "LeetCode/C#/0104-MaximumDepthofBinaryTree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0104-MaximumDepthofBinaryTree.cs",
      "approach": "Recursive",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursive\n1. Call the MaxDepth method with the root and the result\n2. CalculateDepth method:\n    a. Check if the root is null\n    b. Call the CalculateDepth method with the left child of the root and the result\n    c. Call the CalculateDepth method with the right child of the root and the result\n    d. Return the maximum of the leftHeight and rightHeight + 1\nTime complexity: O(n)\nSpace complexity: O(1)\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MaxDepth(TreeNode root) {\n        int result = 0;                                                     // declare the result\n        result = CalculateDepth(root, result);                              // call the CalculateDepth method with the root and the result\n        return result;                                                      // return the result\n    }\n\n    public static int CalculateDepth(TreeNode root, int result) {           // declare the CalculateDepth method\n        if (root == null) {                                                 // check if the root is null\n            return 0;                                                       // return 0\n        }\n        int leftHeight = CalculateDepth(root.left, result);                 // call the CalculateDepth method with the left child of the root\n        int rightHeight = CalculateDepth(root.right, result);               // call the CalculateDepth method with the right child of the root\n        return rightHeight > leftHeight ? rightHeight + 1 : leftHeight + 1; // return the maximum of the leftHeight and rightHeight + 1\n    }\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\nApproach: Iterative\nTODO\n*/"
    },
    {
      "problemNumber": "0112",
      "title": "Path Sum",
      "language": "C#",
      "filename": "0112-PathSum.cs",
      "path": "LeetCode/C#/0112-PathSum.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0112-PathSum.cs",
      "approach": "1. If the root is null, return false.",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. If the root is null, return false.\n2. Call the recursive function HasPathSumBelow with the root, targetSum, and currentSum as 0.\n3. In the recursive function, if the node is null, return false.\n4. Add the value of the current node to the currentSum.\n5. If the node is a leaf node, check if the currentSum is equal to the targetSum. If yes, return true.\n6. Otherwise, recursively call the function for the left and right children of the node.\n7. Return the logical OR of the results from the left and right children.\n\nTime Complexity of this approach is O(n), where n is the number of nodes in the binary tree. This is because we visit each node exactly once.\nSpace Complexity is O(h), where h is the height of the binary tree. In the worst case, the height of the binary tree is O(n), so the space complexity is O(n).\n\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool HasPathSum(TreeNode root, int targetSum) {\n        if (root == null) return false;                                             // if the root is null, return false\n        return HasPathSumBelow(root, targetSum, 0);                                 // call the recursive function with the root, targetSum, and currentSum as 0\n    }\n\n    public bool HasPathSumBelow(TreeNode node, int targetSum, int currentSum) {\n        if (node == null) return false;                                             // if the node is null, return false\n\n        currentSum += node.val;                                                     // add the value of the current node to the currentSum\n\n        if (node.left == null && node.right == null) {                              // if the node is a leaf node\n            return targetSum == currentSum;                                         // check if the currentSum is equal to the targetSum\n        }\n\n        return HasPathSumBelow(node.left, targetSum, currentSum)                    // recursively call the function for the left and right children of the node\n                || HasPathSumBelow(node.right, targetSum, currentSum);              // return the logical OR of the results from the left and right children\n    }\n}"
    },
    {
      "problemNumber": "0118",
      "title": "Pascals Triangle",
      "language": "C#",
      "filename": "0118-PascalsTriangle.cs",
      "path": "LeetCode/C#/0118-PascalsTriangle.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0118-PascalsTriangle.cs",
      "approach": "1) Initialize the row and triangle lists",
      "tags": [],
      "steps": [
        "1) Initialize the row and triangle lists",
        "2) Add the first row to the triangle list",
        "3) Iterate through the rows",
        "4) Add 1 to the row list",
        "5) Iterate through the columns",
        "6) Add the sum of the previous row's jth and (j-1)th elements to the row list",
        "7) Add 1 to the row list",
        "8) Add the row list to the triangle list",
        "9) Return the triangle list"
      ],
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(n^2)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize the row and triangle lists\n2) Add the first row to the triangle list\n3) Iterate through the rows\n4) Add 1 to the row list\n5) Iterate through the columns\n6) Add the sum of the previous row's jth and (j-1)th elements to the row list\n7) Add 1 to the row list\n8) Add the row list to the triangle list\n9) Return the triangle list\n\nTime complexity: O(n^2)\nSpace complexity: O(n^2)\n\n\n*/\n\npublic class Solution {\n    public IList<IList<int>> Generate(int numRows) {\n        List<int> row = new List<int>();\n            List<IList<int>> triangle = new List<IList<int>>();\n            triangle.Add(new List<int>{1});\n\n            for(int i=1; i<numRows; i++) {\n                row.Add(1);\n                for(int j=1; j<i; j++) {\n                    row.Add( triangle[i-1][j-1] + triangle[i-1][j] );\n                }\n                row.Add(1);\n                triangle.Add(row);\n                row = new List<int>();\n            }\n\n            return triangle;\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///\npublic class Solution {\n    public IList<IList<int>> Generate(int numRows) {\n\n        IList<IList<int>> triangle = new List<IList<int>>();\n        IList<int> firstRow = new List<int>();\n        firstRow.Add(1);\n        triangle.Add(firstRow);\n\n\n        for(int i = 1; i < numRows; i++) {\n\n                IList<int> row = new List<int>();\n                row.Add(1);\n                IList<int> prevRow = triangle[i-1];\n\n               for(int j = 1;j < i; j++) {\n\n                 row.Add(prevRow[j-1] + prevRow[j]);\n\n                }\n\n                row.Add(1);\n                triangle.Add(row);\n        }\n\n        return triangle;\n\n    }\n}\n"
    },
    {
      "problemNumber": "0119",
      "title": "Pascal's Triangle I I",
      "language": "C#",
      "filename": "0119-Pascal'sTriangleII.cs",
      "path": "LeetCode/C#/0119-Pascal'sTriangleII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0119-Pascal'sTriangleII.cs",
      "approach": "1) Initialize the lastRow and currentRow lists",
      "tags": [],
      "steps": [
        "1) Initialize the lastRow and currentRow lists",
        "2) Add 1 to the currentRow list",
        "3) Iterate through the rows",
        "4) Add 1 to the currentRow list",
        "5) Iterate through the columns",
        "6) Add the sum of the lastRow's jth and (j-1)th elements to the currentRow list",
        "7) Add 1 to the currentRow list",
        "8) Set the lastRow to the currentRow",
        "9) Return the currentRow"
      ],
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize the lastRow and currentRow lists\n2) Add 1 to the currentRow list\n3) Iterate through the rows\n4) Add 1 to the currentRow list\n5) Iterate through the columns\n6) Add the sum of the lastRow's jth and (j-1)th elements to the currentRow list\n7) Add 1 to the currentRow list\n8) Set the lastRow to the currentRow\n9) Return the currentRow\n\nTime complexity: O(n^2)\nSpace complexity: O(n)\n\n*/\n\n\npublic class Solution {\n    public IList<int> GetRow(int rowIndex) {\n        List<int> lastRow = new List<int>();\n        List<int> currentRow = new List<int>();\n        currentRow.Add(1);\n        lastRow = currentRow;\n\n        for(int i=1; i<=rowIndex; i++) {\n\n            currentRow = new List<int>();\n            currentRow.Add(1);\n            for(int j=1; j<i; j++) {\n                currentRow.Add( lastRow[j-1] + lastRow[j] );\n            }\n            currentRow.Add(1);\n            lastRow = currentRow;\n        }\n\n        return currentRow;\n\n    }\n}"
    },
    {
      "problemNumber": "0121",
      "title": "Best Timeto Buyand Sell Stock",
      "language": "C#",
      "filename": "0121-BestTimetoBuyandSellStock.cs",
      "path": "LeetCode/C#/0121-BestTimetoBuyandSellStock.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0121-BestTimetoBuyandSellStock.cs",
      "approach": "1) Initialize left and right pointers to 0 and 1 respectively.",
      "tags": [],
      "steps": [
        "1) Initialize left and right pointers to 0 and 1 respectively.",
        "2) Iterate through the array until the right pointer reaches the end of the array.",
        "3) If the price at the left pointer is greater than the price at the right pointer, increment both pointers.",
        "4) Otherwise, calculate the profit and update the maximum profit if the current profit is greater than the maximum profit.",
        "5) Increment the right pointer.",
        "6) Return the maximum profit."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize left and right pointers to 0 and 1 respectively.\n2) Iterate through the array until the right pointer reaches the end of the array.\n3) If the price at the left pointer is greater than the price at the right pointer, increment both pointers.\n4) Otherwise, calculate the profit and update the maximum profit if the current profit is greater than the maximum profit.\n5) Increment the right pointer.\n6) Return the maximum profit.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\n\npublic class Solution {\n    public int MaxProfit(int[] prices) {\n        int left, right, profit;\n        left = profit = 0;\n        right = left+1;\n\n        while ((left < right) && (right < prices.Length)) {\n            if (prices[left] > prices[right]) {\n                left=right;\n            }\n            else {\n                profit = Math.Max(profit, prices[right] - prices[left]);\n            }\n            right++;\n        }\n        return profit;\n    }\n}"
    },
    {
      "problemNumber": "0122",
      "title": "Best Timeto Buyand Sell Stock I I",
      "language": "C#",
      "filename": "0122-BestTimetoBuyandSellStockII.cs",
      "path": "LeetCode/C#/0122-BestTimetoBuyandSellStockII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0122-BestTimetoBuyandSellStockII.cs",
      "approach": "1) Initialize left and right pointers to 0 and 1 respectively.",
      "tags": [],
      "steps": [
        "1) Initialize left and right pointers to 0 and 1 respectively.",
        "2) Iterate through the array until the right pointer reaches the end of the array.",
        "3) If the price at the left pointer is less than the price at the right pointer, calculate the profit and update the profit.",
        "4) Increment both pointers.",
        "5) Return the profit."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize left and right pointers to 0 and 1 respectively.\n2) Iterate through the array until the right pointer reaches the end of the array.\n3) If the price at the left pointer is less than the price at the right pointer, calculate the profit and update the profit.\n4) Increment both pointers.\n5) Return the profit.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public int MaxProfit(int[] prices) {\n        int left, right, profit;\n        left = profit = 0;\n        right = left+1;\n\n        while ((left < right) && (right < prices.Length)) {\n            if (prices[left] < prices[right]) {\n                profit = profit + prices[right] - prices[left];\n            }\n            left++;\n            right++;\n        }\n        return profit;\n    }\n}"
    },
    {
      "problemNumber": "0125",
      "title": "Valid Palindrome",
      "language": "C#",
      "filename": "0125-ValidPalindrome.cs",
      "path": "LeetCode/C#/0125-ValidPalindrome.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0125-ValidPalindrome.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Minimal Use of Built in Functions.\n// Two Pointer\npublic class Solution {\n    public bool IsPalindrome(string s) {\n        \n        s = s.ToLower();\n        \n        int i=0;\n        int j= s.Length - 1;\n\n        while(i<j) {\n\n            if( s[i] < 48 || s[i] > 57 && s[i] < 97 || s[i] > 122) { // 48 to 57 is for numbers. 97 to 122 is for letters\n                i++;\n                continue;\n            }\n\n            if( s[j] < 48 || s[j] > 57 && s[j] < 97 || s[j] > 122) {\n                j--;\n                continue;\n            }\n\n            if(s[i] != s[j]) return false;          \n\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n"
    },
    {
      "problemNumber": "0128",
      "title": "Longest Consecutive Sequence",
      "language": "C#",
      "filename": "0128-LongestConsecutiveSequence.cs",
      "path": "LeetCode/C#/0128-LongestConsecutiveSequence.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0128-LongestConsecutiveSequence.cs",
      "approach": "1. Create a hashset to store the numbers.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a hashset to store the numbers.\n2. Create a variable to store the current initial length.\n3. Create a variable to store the current initial number.\n4. Create a variable to store the current maximum length.\n5. Iterate through the numbers array and add the numbers to the hashset.\n6. Iterate through the numbers array and for each number, check if the number-1 is present in the hashset.\n7. If it is not present, then it is the starting number of a sequence.\n8. Iterate through the sequence and increment the current initial length.\n9. Update the current maximum length.\n10. Return the current maximum length.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int LongestConsecutive(int[] nums) {\n        HashSet<int> set = new HashSet<int>();\n        int currentInitialLength = 0;\n        int index = 0;\n        int currentInitial = 0;\n        int currentMax = 0;\n\n        foreach(int num in nums) {\n            set.Add(num);\n        }\n\n        while(index < nums.Length) {\n\n            if(!set.Contains(nums[index]-1)) {\n                currentInitial = nums[index];\n\n                while (set.Contains(currentInitial)) {\n                    currentInitialLength++;\n                    currentInitial++;\n                }\n\n                currentMax = Math.Max(currentMax,currentInitialLength);\n                currentInitialLength=0;\n            }\n\n            index++;\n        }\n\n        return currentMax;\n    }\n\n}"
    },
    {
      "problemNumber": "0136",
      "title": "Single Number",
      "language": "C#",
      "filename": "0136-SingleNumber.cs",
      "path": "LeetCode/C#/0136-SingleNumber.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0136-SingleNumber.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Approach 1\n// You hashset to identify if the umber is already there.\n\n// Approach 2\n// XOR operation x XOR x will be 0. X XOR y will be 1\n// n XOR 0 is n\n// so get XOR of all elements in the array and you will get the number.\n\npublic class Solution {\n    public int SingleNumber(int[] nums) {\n        int ans = 0;\n        foreach(int num in nums) {\n            ans = ans ^ num;\n        }\n        return ans;\n    }\n}"
    },
    {
      "problemNumber": "0141",
      "title": "Linked List Cycle",
      "language": "C#",
      "filename": "0141-LinkedListCycle.cs",
      "path": "LeetCode/C#/0141-LinkedListCycle.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0141-LinkedListCycle.cs",
      "approach": "1) Initialize two pointers, slow and fast, and point them to the head of the linked list.",
      "tags": [],
      "steps": [
        "1) Initialize two pointers, slow and fast, and point them to the head of the linked list.",
        "2) Traverse the linked list until the fast pointer reaches the end.",
        "3) Move the slow pointer by one step and the fast pointer by two steps.",
        "4) If the slow and fast pointers meet, then there is a cycle in the linked list.",
        "5) If the fast pointer reaches the end of the linked list, then there is no cycle.",
        "6) Return true if there is a cycle, else return false."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1) Initialize two pointers, slow and fast, and point them to the head of the linked list.\n2) Traverse the linked list until the fast pointer reaches the end.\n3) Move the slow pointer by one step and the fast pointer by two steps.\n4) If the slow and fast pointers meet, then there is a cycle in the linked list.\n5) If the fast pointer reaches the end of the linked list, then there is no cycle.\n6) Return true if there is a cycle, else return false.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public bool HasCycle(ListNode head) {\n        ListNode slow, fast;                        // Initialize two pointers\n        slow = fast = head;                         // Point both the pointers to the head of the linked list\n        while(fast != null && fast.next != null) {  // Traverse the linked list until the fast pointer reaches the end\n            slow = slow.next;                       // Move the slow pointer by one step\n            fast = fast.next.next;                  // Move the fast pointer by two steps\n            if (slow == fast)                       // If the slow and fast pointers meet, then there is a cycle\n                return true;                        // Return true\n        }\n        return false;                               // If the fast pointer reaches the end of the linked list, then there is no cycle\n    }\n}"
    },
    {
      "problemNumber": "0142",
      "title": "Linked List Cycle I I",
      "language": "C#",
      "filename": "0142-LinkedListCycleII.cs",
      "path": "LeetCode/C#/0142-LinkedListCycleII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0142-LinkedListCycleII.cs",
      "approach": "1. We will use Floyd's Tortoise and Hare algorithm to detect the cycle.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. We will use Floyd's Tortoise and Hare algorithm to detect the cycle.\n2. We will initialize two pointers slow and fast to head.\n3. We will iterate through the linked list until fast is not null and fast.next is not null.\n4. If cycle is found, we will set cycleFound to true and will set slow to head.\n5. If cycle is found, we will iterate through the linked list until slow is not equal to fast.\n6. If slow is equal to fast, we will return slow.\n7. If cycle is not found, we will return null.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DetectCycle(ListNode head) {\n        ListNode slow, fast;                        // Declare slow and fast pointers\n        slow = fast = head;                         // Initialize slow and fast pointers to head\n        bool cycleFound = false;                    // Initialize cycleFound to false\n        while(fast != null && fast.next != null) {  // Iterate through the linked list until fast is not null and fast.next is not null\n            if(cycleFound && slow == fast) {        // If cycle is found, return slow\n                return slow;                        // Return slow\n            }\n            if(cycleFound) {\n                slow = slow.next;                   // Move slow pointer by one step\n                fast = fast.next;                   // Move fast pointer by one step\n            }\n            else {\n                slow = slow.next;                   // Move slow pointer by one step\n                fast = fast.next.next;              // Move fast pointer by two steps\n                if(slow == fast) {                  // If cycle is found, set cycleFound to true and set slow to head\n                    cycleFound = true;              // Set cycleFound to true\n                    slow = head;                    // Set slow to head\n                }\n\n            }\n        }\n        return null;                                // If cycle is not found, return null\n    }\n}"
    },
    {
      "problemNumber": "0143",
      "title": "Reorder List",
      "language": "C#",
      "filename": "0143-ReorderList.cs",
      "path": "LeetCode/C#/0143-ReorderList.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0143-ReorderList.cs",
      "approach": "1. Find the middle of the list using slow and fast pointers.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Find the middle of the list using slow and fast pointers.\n2. Reverse the second half of the list.\n3. Merge the two lists.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public void ReorderList(ListNode head) {\n\n        // Finding middle of the list\n        ListNode slow, fast;                            // slow and fast pointers\n        slow = fast = head;                             // both pointers at the start of the list\n        while(fast != null && fast.next != null) {      // until fast reaches the end of the list\n            slow = slow.next;                           // slow moves one step\n            fast = fast.next.next;                      // fast moves two steps\n        }\n\n        // Reversing the second half of the list\n        ListNode head2 = slow.next;                     // head of the second half\n        slow.next = null;                               // breaking the list into two halves\n        ListNode curr, prev, temp;                      // pointers for reversing the second half\n        curr = head2;                                   // starting from the head of the second half\n        prev = null;                                    // previous node of the current node\n        while(curr != null) {                           // until the end of the list\n            temp = curr.next;                           // storing the next node of the current node\n            curr.next = prev;                           // reversing the current node\n            prev = curr;                                // updating the previous node\n            curr = temp;                                // moving to the next node\n        }\n\n        // Merging the two lists\n        ListNode list1, list2, temp1, temp2;            // pointers for merging the two lists\n        list1 = head;                                   // starting from the head of the first half\n        list2 = prev;                                   // starting from the head of the reversed second half\n\n        while(list2 != null) {                          // until the end of the second half\n            temp1 = list1.next;                         // storing the next node of the first half\n            temp2 = list2.next;                         // storing the next node of the second half\n            list1.next = list2;                         // connecting the first half to the second half\n            list2.next = temp1;                         // connecting the second half to the first half\n            list1 = temp1;                              // moving to the next node of the first half\n            list2 = temp2;                              // moving to the next node of the second half\n        }\n    }\n}"
    },
    {
      "problemNumber": "0144",
      "title": "Binary Tree Preorder Traversal",
      "language": "C#",
      "filename": "0144-BinaryTreePreorderTraversal.cs",
      "path": "LeetCode/C#/0144-BinaryTreePreorderTraversal.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0144-BinaryTreePreorderTraversal.cs",
      "approach": "Recursive",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursive\n1. Create a list of integers to store the result\n2. Call the Traverse method with the root and the result list\n3. Return the result list\n4. Traverse method:\n    a. Check if the root is null\n    b. Add the value of the root to the result list\n    c. Call the Traverse method with the left child of the root and the result list\n    d. Call the Traverse method with the right child of the root and the result list\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> PreorderTraversal(TreeNode root) {\n        IList<int> result = new List<int>();                            // declare the result list\n        Traverse(root, result);                                         // call the Traverse method with the root and the result list\n        return result;                                                  // return the result list\n    }\n\n    public static void Traverse(TreeNode root, IList<int> result) {     // declare a Traverse method\n        if (root == null) {                                             // check if the root is null\n            return;                                                     // return\n        }\n        result.Add(root.val);                                           // add the value of the root to the result list\n        Traverse(root.left, result);                                    // call the Traverse method with the left child of the root\n        Traverse(root.right, result);                                   // call the Traverse method with the right child of the root\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\nApproach: Iterative\nTODO\n*/"
    },
    {
      "problemNumber": "0145",
      "title": "Binary Tree Postorder Traversal",
      "language": "C#",
      "filename": "0145-BinaryTreePostorderTraversal.cs",
      "path": "LeetCode/C#/0145-BinaryTreePostorderTraversal.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0145-BinaryTreePostorderTraversal.cs",
      "approach": "Recursive",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursive\n1. Create a list of integers to store the result\n2. Call the Traverse method with the root and the result list\n3. Return the result list\n4. Traverse method:\n    a. Check if the root is null\n    b. Call the Traverse method with the left child of the root and the result list\n    c. Call the Traverse method with the right child of the root and the result list\n    d. Add the value of the root to the result list\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> PostorderTraversal(TreeNode root) {\n        IList<int> result = new List<int>();                            // declare list to store the result\n        Traverse(root, result);                                         // call the Traverse method with the root and the result list\n        return result;                                                  // return the result list\n    }\n    public static void Traverse(TreeNode root, IList<int> result) {     // declare a Traverse method\n        if (root == null) {                                             // check if the root is null\n            return;                                                     // return\n        }\n        Traverse(root.left, result);                                    // call the Traverse method with the left child of the root\n        Traverse(root.right, result);                                   // call the Traverse method with the right child of the root\n        result.Add(root.val);                                           // add the value of the root to the result list\n    }\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\nApproach: Iterative\nTODO\n*/"
    },
    {
      "problemNumber": "0153",
      "title": "Find Minimumin Rotated Sorted Array",
      "language": "C#",
      "filename": "0153-FindMinimuminRotatedSortedArray.cs",
      "path": "LeetCode/C#/0153-FindMinimuminRotatedSortedArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0153-FindMinimuminRotatedSortedArray.cs",
      "approach": "Modified Binary Search",
      "tags": [
        "Array",
        "Binary Search",
        "Divide and Conquer"
      ],
      "steps": [
        "1) Use binary search with left and right pointers.",
        "2) Compare mid element with right element (never compare mid with left).",
        "3) If nums[mid] > nums[right], minimum is in the right half.",
        "4) Otherwise, minimum is at mid or in the left half.",
        "5) Continue until left equals right, which points to the minimum.",
        "6) Return the element at the converged position."
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solutions/7027831/simplest-solution-c-time-olog-n-space1-p-0qor/\nApproach: Modified Binary Search\nTags: Array, Binary Search, Divide and Conquer\n1) Use binary search with left and right pointers.\n2) Compare mid element with right element (never compare mid with left).\n3) If nums[mid] > nums[right], minimum is in the right half.\n4) Otherwise, minimum is at mid or in the left half.\n5) Continue until left equals right, which points to the minimum.\n6) Return the element at the converged position.\n\nTime Complexity: O(log n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int FindMin(int[] nums) {\n        int left = 0;                                               // Left pointer for binary search\n        int right = nums.Length - 1;                                // Right pointer for binary search\n\n        while (left < right) {                                      // Continue until pointers converge\n            int mid = left + (right - left) / 2;                    // Calculate mid point to avoid overflow\n\n            if (nums[mid] > nums[right]) { // Always compare mid and right and never left with mid !important\n                // Minimum must be to the right of mid\n                left = mid + 1;                                     // Move left pointer past mid\n            } else {\n                // Minimum is at mid or to the left\n                right = mid;                                        // Move right pointer to mid (include mid)\n            }\n        }\n\n        return nums[left];                                          // Return the minimum element found\n    }\n}\n"
    },
    {
      "problemNumber": "0155",
      "title": "Min Stack",
      "language": "C#",
      "filename": "0155-MinStack.cs",
      "path": "LeetCode/C#/0155-MinStack.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0155-MinStack.cs",
      "approach": "1) Initialize the minimum value and the stack",
      "tags": [],
      "steps": [
        "1) Initialize the minimum value and the stack",
        "2) Push the value to the stack if the stack is empty",
        "3) If the value is greater than or equal to the minimum value, push the value to the stack",
        "4) If the value is less than the minimum value, push 2 * value - minimum value to the stack and update the minimum value",
        "5) Pop the value from the stack",
        "6) If the popped value is less than the minimum value, calculate the previous minimum value and update the popped value and the minimum value",
        "7) Get the top value from the stack",
        "8) If the value is greater than or equal to the minimum value, return the value",
        "9) If the value is less than the minimum value, return the minimum value",
        "10) Return the minimum value",
        "11) Make sure you cast long to int where ever required for C# :)"
      ],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize the minimum value and the stack\n2) Push the value to the stack if the stack is empty\n3) If the value is greater than or equal to the minimum value, push the value to the stack\n4) If the value is less than the minimum value, push 2 * value - minimum value to the stack and update the minimum value\n5) Pop the value from the stack\n6) If the popped value is less than the minimum value, calculate the previous minimum value and update the popped value and the minimum value\n7) Get the top value from the stack\n8) If the value is greater than or equal to the minimum value, return the value\n9) If the value is less than the minimum value, return the minimum value\n10) Return the minimum value\n11) Make sure you cast long to int where ever required for C# :)\nTime complexity: O(1)\nSpace complexity: O(n)\n\n*/\npublic class MinStack\n{\n    long _min;                                                            // Initialize the minimum value\n    Stack<long> _stack;                                                   // Initialize the stack\n\n    public MinStack()\n    {\n        _stack = new Stack<long>();                                       // Initialize the stack\n    }\n\n    public void Push(int val)\n    {\n        if (_stack.Count == 0)                                            // If the stack is empty\n        {\n            _stack.Push((long)val);                                       // Push the value to the stack\n            _min = (long)val;                                             // Update the minimum value\n        }\n        else if ((long)val >= _min)                                       // If the value is greater than or equal to the minimum value\n        {\n            _stack.Push((long)val);                                       // Push the value to the stack\n        }\n        else\n        {\n            long temp = 2 * (long)val;\n            temp = temp - _min;\n            _stack.Push(temp);                                            // Push the value to the stack\n            _min = (long)val;                                             // Update the minimum value\n        }\n    }\n\n    public void Pop()\n    {\n        long popped = _stack.Pop();                                       // Pop the value from the stack\n        if (popped < _min)                                                // If the popped value is less than the minimum value\n        {\n            long prevMin = 2 * _min;\n            prevMin = prevMin - popped;\n            popped = _min;                                                // Update the popped value\n            _min = prevMin;                                               // Update the minimum value\n        }\n        // return popped if the return type of Pop() is int\n    }\n\n    public int Top()\n    {\n        long val = _stack.Peek();                                    // Get the top value from the stack\n        if (val >= _min)                                            // If the value is greater than or equal to the minimum value\n            return (int)val;                                             // Return the value\n        else\n            return (int)_min;                                            // Return the minimum value\n    }\n\n    public int GetMin()\n    {\n        return (int)_min;                                                // Return the minimum value\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.Push(val);\n * obj.Pop();\n * int param_3 = obj.Top();\n * int param_4 = obj.GetMin();\n */"
    },
    {
      "problemNumber": "0160",
      "title": "Intersectionof Two Linked Lists",
      "language": "C#",
      "filename": "0160-IntersectionofTwoLinkedLists.cs",
      "path": "LeetCode/C#/0160-IntersectionofTwoLinkedLists.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0160-IntersectionofTwoLinkedLists.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n + m) where n is the number of nodes in the first linked list and m is the number of nodes in the second linked list.",
      "spaceComplexity": "O(n) where n is the number of nodes in the first linked list.",
      "solutionLink": "",
      "code": "/*\nApproach 1:\n1. We will use HashSet to store the nodes of the first linked list.\n2. We will iterate through the first linked list and add the nodes to the HashSet.\n3. We will iterate through the second linked list and check if the node is present in the HashSet.\n4. If the node is present in the HashSet, we will return the node.\n5. If the node is not present in the HashSet, we will move to the next node.\n6. If no intersection is found, we will return null.\n\nTime Complexity: O(n + m) where n is the number of nodes in the first linked list and m is the number of nodes in the second linked list.\nSpace Complexity: O(n) where n is the number of nodes in the first linked list.\n\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\n        HashSet<ListNode> hs = new HashSet<ListNode>(); // Declare HashSet to store list nodes\n        ListNode a = headA;                             // Declare a pointer to the head of the first linked list\n        ListNode b = headB;                             // Declare a pointer to the head of the second linked list\n        while(a!=null)                                  // Iterate through the first linked list and add the nodes to the HashSet\n        {\n            hs.Add(a);                                  // Add the node to the HashSet\n            a = a.next;                                 // Move to the next node\n        }\n        while(b!= null) {                               // Iterate through the second linked list and check if the node is present in the HashSet\n            if(!hs.Contains(b)) {                       // If the node is not present in the HashSet, move to the next node\n                b = b.next;                             // Move to the next node\n            }\n            else {                                      // If the node is present in the HashSet, return the node\n                return b;                               // Return the node\n            }\n        }\n        return null;                                    // If no intersection is found, return null\n    }\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\nApproach 2 (Efficient):\n1. We will use two pointers to traverse the linked lists.\n2. We will initialize two pointers a and b to the heads of the linked lists.\n3. We will iterate through the linked lists until a is not equal to b.\n4. If a is null, we will set a to the head of the second linked list.\n5. If b is null, we will set b to the head of the first linked list.\n6. If a is not null, we will move a to the next node.\n7. If b is not null, we will move b to the next node.\n8. If a is equal to b, we will return a.\n9. If no intersection is found, we will return null.\n\nTime Complexity: O(n + m) where n is the number of nodes in the first linked list and m is the number of nodes in the second linked list.\nSpace Complexity: O(1)\n*/\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;                     // Declare a pointer to the head of the first linked list\n        ListNode b = headB;                     // Declare a pointer to the head of the second linked list\n\n        while(a != b) {                         // Iterate through the linked lists until a is not equal to b\n            a = a == null ? headB : a.next;     // If a is null, set a to the head of the second linked list\n            b = b == null ? headA : b.next;     // If b is null, set b to the head of the first linked list\n        }\n\n        return a;                               // Return the intersection node or null\n    }\n}"
    },
    {
      "problemNumber": "0162",
      "title": "Find Peak Element",
      "language": "C#",
      "filename": "0162-FindPeakElement.cs",
      "path": "LeetCode/C#/0162-FindPeakElement.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0162-FindPeakElement.cs",
      "approach": "Binary Search",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Binary Search\n1. We can use binary search to find the peak element.\n2. We can compare the mid element with the next element.\n3. If the mid element is less than the next element, then the peak element will be on the right side of the mid element.\n4. If the mid element is greater than the next element, then the peak element will be on the left side of the mid element.\n5. We can keep on reducing the search space by moving the left and right pointers accordingly.\n6. We can return the left pointer as the peak element.\n\nTime complexity: O(log n)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int FindPeakElement(int[] nums) {\n        int left = 0;                               // left pointer\n        int right = nums.Length - 1;                // right pointer\n        while (left < right)                        // binary search\n        {\n            int mid = left + (right - left) / 2;    // calculate mid element index and avoid integer overflow\n            if (nums[mid] < nums[mid + 1]) {        // if mid element is less than the next element\n                left = mid + 1;                     // peak element will be on the right side of mid element\n            }\n            else {                                  // if mid element is greater than the next element\n                right = mid;                        // peak element will be on the left side of mid element\n            }\n        }\n        return left;                                // return left pointer as peak element\n    }\n}"
    },
    {
      "problemNumber": "0167",
      "title": "Two Sum I I- Input Array Is Sorted",
      "language": "C#",
      "filename": "0167-TwoSumII-InputArrayIsSorted.cs",
      "path": "LeetCode/C#/0167-TwoSumII-InputArrayIsSorted.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0167-TwoSumII-InputArrayIsSorted.cs",
      "approach": "1. Initialize left to 0 and right to numbers.Length - 1.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Initialize left to 0 and right to numbers.Length - 1.\n2. Initialize an array res of size 2.\n3. Iterate while left is less than right.\n4. If the sum of numbers[left] and numbers[right] is greater than target, decrement right.\n5. If the sum of numbers[left] and numbers[right] is less than target, increment left.\n6. If the sum of numbers[left] and numbers[right] is equal to target, break.\n7. Update res[0] to left + 1 and res[1] to right + 1.\n8. Return res.\n\nTime complexity: O(n)\nSpace complexity: O(1)\nwhere n is the number of elements in the array.\n\n*/\npublic class Solution {\n    public int[] TwoSum(int[] numbers, int target) {\n        int left = 0;\n        int right = numbers.Length - 1;\n        int[] res = new int[2];\n\n        while (left < right) {\n            if( (numbers[left] + numbers[right]) > target ) {\n                right--;\n            }\n\n            if( (numbers[left] + numbers[right]) < target ) {\n                left++;\n            }\n\n            if( (numbers[left] + numbers[right]) == target ) {\n                break;\n            }\n        }\n\n        res[0] = left + 1;\n        res[1] = right + 1;\n        return res;\n    }\n}"
    },
    {
      "problemNumber": "0169",
      "title": "Majority Element",
      "language": "C#",
      "filename": "0169-MajorityElement.cs",
      "path": "LeetCode/C#/0169-MajorityElement.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0169-MajorityElement.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Approach 1: Using Dictionary to store the frequency of each element in the array. Then, iterate over the dictionary to find the element with the maximum frequency.\npublic class Solution {\n    public int MajorityElement(int[] nums) {\n        Dictionary<int, int> dict = new Dictionary<int, int>();\n            int resultValue = int.MinValue;\n            int resultIndex = 0;\n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (dict.ContainsKey(nums[i]))\n                {\n                    dict[nums[i]]++;\n                    if(dict[nums[i]] > resultValue){\n                        resultValue = dict[nums[i]];\n                        resultIndex = i;\n                    }\n                }\n                else\n                {\n                    dict[nums[i]] = 1;\n                }\n            }\n            return nums[resultIndex];\n    }\n}\n// Approach 2: Using Boyer-Moore Voting Algorithm\npublic class Solution {\n    public int MajorityElement(int[] nums) {\n\n        int currentNum = nums[0];\n        int currentNumCount = 0;\n\n        for(int i=0; i<nums.Length; i++) {\n            if(nums[i] == currentNum) {\n                currentNumCount++;\n            }\n            else {\n                if(currentNumCount == 0) {\n                    currentNum = nums[i];\n                }\n                else {\n                currentNumCount--;\n                }\n            }\n        }\n\n        return currentNum;\n\n    }\n}\n"
    },
    {
      "problemNumber": "0191",
      "title": "Numberof1 Bits",
      "language": "C#",
      "filename": "0191-Numberof1Bits.cs",
      "path": "LeetCode/C#/0191-Numberof1Bits.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0191-Numberof1Bits.cs",
      "approach": "String conversion",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/number-of-1-bits/solutions/6556147/simplest-solution-c-time-o1-space1-pleas-nilu/\nApproach: String conversion\n1. Convert the given number to binary string.\n2. Count the number of 1's in the binary string.\n3. Return the count.\n\nTime complexity: O(1)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int HammingWeight(int n) {\n        string binaryString = Convert.ToString(n, 2);   // Convert the given number to binary string.\n        int count = 0;                                  // Declare a variable to store the count of 1's.\n        foreach(char ch in binaryString) {              // Iterate through the binary string.\n            count += ch == '1' ? 1 : 0;                 // If the character is '1', increment the count.\n        }\n        return count;                                   // Return the count.\n    }\n}\n\n/*\nApproach: Bit Manipulation\nTODO\n*/"
    },
    {
      "problemNumber": "0193",
      "title": "Valid Phone Numbers",
      "language": "Bash",
      "filename": "0193-ValidPhoneNumbers.sh",
      "path": "LeetCode/Bash/0193-ValidPhoneNumbers.sh",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Bash/0193-ValidPhoneNumbers.sh",
      "approach": "Regular Expression Pattern Matching with grep",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "#!/bin/bash\n# Solution: Valid Phone Numbers\n# Approach: Regular Expression Pattern Matching with grep\n# Tags: Bash, Regular Expression, Text Processing\n# 1) Use grep to filter lines matching valid phone number patterns.\n# 2) Valid formats: \"xxx-xxx-xxxx\" or \"(xxx) xxx-xxxx\" where x is a digit.\n# 3) Use -e flag for multiple patterns or -E for extended regex.\n# 4) ^ ensures pattern starts at beginning, $ ensures it ends at end of line.\n\n# Method 1: Basic regex with -e flag for multiple patterns\ngrep -e \"^[0-9]\\{3\\}\\-[0-9]\\{3\\}\\-[0-9]\\{4\\}$\" -e \"^([0-9]\\{3\\}) [0-9]\\{3\\}\\-[0-9]\\{4\\}$\" file.txt\n\n# Method 2: Extended regex with -E flag (alternation with |)\n# grep -E \"^([0-9]{3}-[0-9]{3}-[0-9]{4}|\\([0-9]{3}\\) [0-9]{3}-[0-9]{4})$\" file.txt"
    },
    {
      "problemNumber": "0195",
      "title": "Tenth Line",
      "language": "Bash",
      "filename": "0195-TenthLine.sh",
      "path": "LeetCode/Bash/0195-TenthLine.sh",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Bash/0195-TenthLine.sh",
      "approach": "Line Number Filtering with AWK/SED",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n) - reads up to line 10",
      "spaceComplexity": "O(1) - constant space",
      "solutionLink": "",
      "code": "#!/bin/bash\n# Solution: https://leetcode.com/problems/tenth-line/solutions/7413139/simplest-solution-c-time-on-space1-pleas-p83u/\n# Approach: Line Number Filtering with AWK/SED\n# Tags: Shell, Text Processing, AWK, SED\n# 1) Use AWK to filter lines by number (NR == 10).\n# 2) NR is AWK's built-in variable for current line number.\n# 3) When NR equals 10, AWK prints that line automatically.\n# 4) Alternative: Use sed with -n flag (quiet mode) and 10p (print line 10).\n# 5) Both commands read file.txt and output only the tenth line.\n#\n# Time Complexity: O(n) - reads up to line 10\n# Space Complexity: O(1) - constant space\n\n# Read from the file file.txt and output the tenth line to stdout\nawk 'NR == 10' file.txt                                             # AWK: Print when line number equals 10\n# or\n# sed -n '10p' file.txt                                             # SED: Print only the 10th line (quiet mode)"
    },
    {
      "problemNumber": "0198",
      "title": "House Robber",
      "language": "C#",
      "filename": "0198-HouseRobber.cs",
      "path": "LeetCode/C#/0198-HouseRobber.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0198-HouseRobber.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach : Recursion with Memoization\n1. Create a dp array of size nums.Length and fill it with -1\n2. Call the RobWay method with nums, 0, and dp\n3. In the RobWay method:\n    a. Check if i >= nums.Length, if yes return 0\n    b. Check if dp[i] != -1, if yes return dp[i]\n    c. Calculate the rob amount by adding the current house amount and calling the RobWay method with nums, i+2, and dp\n    d. Calculate the skip amount by calling the RobWay method with nums, i+1, and dp\n    e. Return the maximum of rob and skip\n4. Return the result\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    public int Rob(int[] nums) {\n        int[] dp = new int[nums.Length];                // create a dp array of size nums.Length\n        Array.Fill(dp,-1);                              // fill the dp array with -1\n        return RobWay(nums,0,dp);                       // call the RobWay method with nums, 0, and dp\n    }\n    public int RobWay(int[] nums, int i, int[] dp) {    // declare the RobWay method\n        if(i >= nums.Length)                            // check if i >= nums.Length\n            return 0;                                   // return 0\n        if(dp[i] != -1)                                 // check if dp[i] != -1\n            return dp[i];                               // return dp[i]\n        int rob = nums[i] + RobWay(nums, i+2, dp);      // calculate the rob amount\n        int skip = RobWay(nums, i+1, dp);               // calculate the skip amount\n        return dp[i] = Math.Max(rob, skip);             // return the maximum of rob and skip\n    }\n}\n///////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////\n/*\nApproach : Iterative with Constant Space (Optimized) (Bottom-Up)\nTBU\n*/\n"
    },
    {
      "problemNumber": "0200",
      "title": "Numberof Islands",
      "language": "C#",
      "filename": "0200-NumberofIslands.cs",
      "path": "LeetCode/C#/0200-NumberofIslands.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0200-NumberofIslands.cs",
      "approach": "DFS",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(rows*columns)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: DFS\n1. Start from the first cell of the grid.\n2. If the cell is 1, call the DFS function.\n3. In the DFS function, check if the cell is out of bounds or the cell is water.\n4. If the cell is out of bounds or the cell is water, return.\n5. Mark the cell as visited.\n6. Call the DFS function recursively with the adjacent cells.\n7. Increment the number of islands.\n8. Return the number of islands.\nTime Complexity: O(rows*columns)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    int numOfIslands = 0;                                               // Variable to store the number of islands.\n    int rows = 0;                                                       // Variable to store the number of rows.\n    int columns = 0;                                                    // Variable to store the number of columns.\n    public int NumIslands(char[][] grid) {                              // Function to find the number of islands.\n        rows = grid.Length;                                             // Get the number of rows.\n        columns = grid[0].Length;                                       // Get the number of columns.\n        for (int i=0; i<rows; i++) {                                    // Iterate through the grid.\n            for (int j=0; j<columns; j++) {                             // Iterate through the grid.\n                if (grid[i][j] == '1') {                                // If the cell is 1, call the DFS function.\n                    DFS(grid, i, j);                                    // Call the DFS function.\n                    numOfIslands++;                                     // Increment the number of islands.\n                }\n            }\n        }\n        return numOfIslands;                                            // Return the number of islands.\n    }\n\n    public void DFS(char[][] grid, int i, int j) {                      // Function to perform Depth First Search.\n        if(i>=rows || i<0 || j>=columns || j<0 || grid[i][j]!='1') {    // If the cell is out of bounds or the cell is water, return.\n            return;                                                     // Return.\n        }\n\n        grid[i][j] = '$';                                               // Mark the cell as visited.\n        DFS(grid, i+1, j);                                              // Call the DFS function recursively with the adjacent cells.\n        DFS(grid, i-1, j);                                              // Call the DFS function recursively with the adjacent cells.\n        DFS(grid, i, j+1);                                              // Call the DFS function recursively with the adjacent cells.\n        DFS(grid, i, j-1);                                              // Call the DFS function recursively with the adjacent cells.\n    }\n}\n\n/*\nApproach: BFS\nTODO\n*/"
    },
    {
      "problemNumber": "0203",
      "title": "Remove Linked List Elements",
      "language": "C#",
      "filename": "0203-RemoveLinkedListElements.cs",
      "path": "LeetCode/C#/0203-RemoveLinkedListElements.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0203-RemoveLinkedListElements.cs",
      "approach": "1) Create a dummy node and point it to the head of the linked list.",
      "tags": [],
      "steps": [
        "1) Create a dummy node and point it to the head of the linked list.",
        "2) Create two pointers, prev and curr, and point them to the dummy node.",
        "3) Traverse the linked list and check if the value of the current node is equal to the given value.",
        "4) If the value is equal, then point the next of the previous node to the next of the current node.",
        "5) If the value is not equal, then move the previous pointer to the current pointer.",
        "6) Finally, return the next of the dummy node."
      ],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Create a dummy node and point it to the head of the linked list.\n2) Create two pointers, prev and curr, and point them to the dummy node.\n3) Traverse the linked list and check if the value of the current node is equal to the given value.\n4) If the value is equal, then point the next of the previous node to the next of the current node.\n5) If the value is not equal, then move the previous pointer to the current pointer.\n6) Finally, return the next of the dummy node.\n\n*/\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveElements(ListNode head, int val) {\n        ListNode prev, curr, dummy;         // Create three pointers\n        curr = head;                        // Point the current pointer to the head of the linked list\n        prev = null;                        // Point the previous pointer to null\n        dummy = new ListNode(0);            // Create a dummy node and point it to the head of the linked list\n        dummy.next = head;                  // Point the next of the dummy node to the head of the linked list\n        prev = dummy;                       // Point the previous pointer to the dummy node\n        while(curr != null) {               // Traverse the linked list\n            if(curr.val == val) {           // Check if the value of the current node is equal to the given value\n                prev.next = curr.next;      // Point the next of the previous node to the next of the current node\n            }\n            else {\n                prev = curr;                // Move the previous pointer to the current pointer\n            }\n            curr = curr.next;               // Move the current pointer to the next node\n        }\n        return dummy.next;                  // Return the next of the dummy node\n    }\n}"
    },
    {
      "problemNumber": "0205",
      "title": "Isomorphic Strings",
      "language": "C#",
      "filename": "0205-IsomorphicStrings.cs",
      "path": "LeetCode/C#/0205-IsomorphicStrings.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0205-IsomorphicStrings.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Problem: Isomorphic Strings\n// Source: https://leetcode.com/problems/isomorphic-strings/\n// Approach 1: Using one dictionary\n// Time complexity : O(n). We traverse the entire string s once and the entire string t once.\n// Space complexity : O(n). Although we do use extra space, the space complexity is O(1) because the space used is only linear with respect to the size of the input.\n// Map each character in s to the corresponding character in t.\n// If the mapping is incorrect, return false.\n// If the mapping is correct, continue to map the rest of the characters.\n// If there is a conflict in the mapping, return false.\n// If the characters in s and t could be successfully mapped, return true.\n\n\npublic class Solution {\n    public bool IsIsomorphic(string s, string t) {\n        if (s.Length != t.Length)\n            {\n                return false;\n            }\n\n            Dictionary<char, char> map = new Dictionary<char, char>();\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                char sChar = s[i];\n                char tChar = t[i];\n\n                if (map.ContainsKey(sChar))\n                {\n                    if (map[sChar] != tChar)\n                    {\n                        return false;\n                    }\n                }\n                else\n                {\n                    if (map.ContainsValue(tChar))\n                    {\n                        return false;\n                    }\n                    map.Add(sChar, tChar);\n                }\n            }\n\n            return true;\n\n    }\n}"
    },
    {
      "problemNumber": "0206",
      "title": "Reverse Linked List",
      "language": "C#",
      "filename": "0206-ReverseLinkedList.cs",
      "path": "LeetCode/C#/0206-ReverseLinkedList.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0206-ReverseLinkedList.cs",
      "approach": "1. We will use three pointers, prev, curr and temp.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We will use three pointers, prev, curr and temp.\n2. We will iterate through the linked list and reverse the pointers.\n3. We will return the prev pointer as the head of the reversed linked list.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n\n        ListNode prev, curr, temp;  // prev is the previous node, curr is the current node and temp is the temporary node.\n        curr = head;                // curr is the head of the linked list.\n        prev = null;                // prev is null initially.\n        while(curr != null) {       // iterate through the linked list.\n            temp = curr.next;       // store the next node in temp.\n            curr.next = prev;       // reverse the pointer.\n            prev = curr;            // move the prev pointer to the current node.\n            curr = temp;            //  move the current pointer to the next node.\n        }\n        return prev;                //  return the prev pointer as the head of the reversed linked list.\n    }\n}"
    },
    {
      "problemNumber": "0206",
      "title": "Reverse Linked List",
      "language": "Go",
      "filename": "0206-ReverseLinkedList.go",
      "path": "LeetCode/Go/0206-ReverseLinkedList.go",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Go/0206-ReverseLinkedList.go",
      "approach": "1. We will use three pointers, prev, curr and temp.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/**\n\nApproach:\n1. We will use three pointers, prev, curr and temp.\n2. We will iterate through the linked list and reverse the pointers.\n3. We will return the prev pointer as the head of the reversed linked list.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n func reverseList(head *ListNode) *ListNode {\n    var curr *ListNode;\t\t// Declare the current node\n    var prev *ListNode;\t\t// Declare the previous node\n    var temp *ListNode;\t\t// Declare the temporary node\n\n    curr= head\t\t\t\t// Initialize the current node\n    prev= nil\t\t\t\t// Initialize the previous node\n    for curr != nil {\t\t// Iterate through the linked list\n        temp= curr.Next\t\t// Store the next node\n        curr.Next=prev\t\t// Reverse the current node\n        prev = curr\t\t\t// Move the previous node\n        curr= temp\t\t\t// Move the current node\n    }\n    return prev;\t\t\t// Return the reversed linked list\n}"
    },
    {
      "problemNumber": "0207",
      "title": "Course Schedule",
      "language": "C#",
      "filename": "0207-CourseSchedule.cs",
      "path": "LeetCode/C#/0207-CourseSchedule.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0207-CourseSchedule.cs",
      "approach": "Kahn's Algorithm",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(V+E) where V is the number of courses and E is the number of prerequisites.",
      "spaceComplexity": "O(V+E) where V is the number of courses and E is the number of prerequisites.",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/course-schedule/solutions/6572782/simplest-solution-c-time-ove-spaceve-ple-qdgk/\nApproach: Kahn's Algorithm\n1. Create a graph with number of courses as nodes and prerequisites as edges.\n2. Create an indegree array to store the indegree of each node.\n3. Create a queue to store the nodes with 0 indegree.\n4. Add all the nodes with 0 indegree to the queue.\n5. Visit the adjacent nodes of the node with 0 indegree, reduce the indegree of the adjacent nodes by 1.\n6. If the indegree of the adjacent node becomes 0, add it to the queue.\n7. Repeat the process until the queue is empty.\n8. If the number of nodes visited is equal to the number of courses, return true else return false.\n\nTime complexity: O(V+E) where V is the number of courses and E is the number of prerequisites.\nSpace complexity: O(V+E) where V is the number of courses and E is the number of prerequisites.\n*/\npublic class Solution {\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n\n        List<List<int>> courseGraph = new List<List<int>>();                                    // Create graph\n        Queue<int> zeroDegreeQueue = new Queue<int>();                                          // Create queue\n        int[] indegree = new int[numCourses];                                                   // Create indegree array\n        int nodesVisited = 0;                                                                   // Number of nodes visited\n        int n = 0;                                                                              // Variable to iterate through number of courses\n\n        // Create Graph\n\n        // Create empty graph\n        while (n < numCourses) {                                                                // Add empty list for each course\n            courseGraph.Add(new List<int>());                                                   // Add empty list for each course\n            n++;                                                                                // Increment n\n        }\n\n        // Add graph nodes\n        for (int prerequisite=0; prerequisite<prerequisites.Length; prerequisite++) {           // Add edges to the graph\n            // prereqCourse - > courseTobeCompletedNode\n            int courseTobeCompletedNode = prerequisites[prerequisite][0];                       // Add edge from prereqCourse to courseTobeCompletedNode\n            int prereqCourse = prerequisites[prerequisite][1];                                  // Add edge from prereqCourse to courseTobeCompletedNode\n            courseGraph[prereqCourse].Add(courseTobeCompletedNode);                             // Add edge from prereqCourse to courseTobeCompletedNode\n        }\n\n        // Calculate indegree of all nodes\n        for (int _prerequisite=0; _prerequisite<prerequisites.Length; _prerequisite++) {        // Calculate indegree of all nodes\n            int indegreePrerequisite = prerequisites[_prerequisite][0];                         // Calculate indegree of all nodes\n            indegree[indegreePrerequisite]++;                                                   // Calculate indegree of all nodes\n        }\n\n       // Add all 0 indegree elements to queue\n       int indegreeIndex = 0;                                                                   // Variable to iterate through indegree array\n       while (indegreeIndex < indegree.Length) {                                                // while indegreeIndex is less than indegree array length\n            if (indegree[indegreeIndex] == 0) {                                                 // If the indegree of the node is 0\n                nodesVisited++;                                                                 // Increment the number of nodes visited\n                zeroDegreeQueue.Enqueue(indegreeIndex);                                         // Add the node to the queue\n            }\n            indegreeIndex++;                                                                    // Increment indegreeIndex\n       }\n\n       // Visit adjacent nodes, remove nodes from queue and add.\n       while (zeroDegreeQueue.Count != 0) {                                                     // while queue is not empty\n            int courseDequeued = zeroDegreeQueue.Dequeue();                                     // Dequeue the course\n            foreach(int course in courseGraph[courseDequeued]) {                                // Visit the adjacent nodes\n                indegree[course]--;                                                             // Reduce the indegree of the adjacent nodes by 1\n                if (indegree[course] == 0) {                                                    // If the indegree of the adjacent node becomes 0\n                    nodesVisited++;                                                             // Increment the number of nodes visited\n                    zeroDegreeQueue.Enqueue(course);                                            // Add the adjacent node to the queue\n                }\n            }\n       }\n       return numCourses == nodesVisited;                                                       // If the number of nodes visited is equal to the number of courses, return true else return false\n    }\n}\n/*\nApproach: DFS\nTODO\n*/"
    },
    {
      "problemNumber": "0208",
      "title": "Implement Trie( Prefix  Tree)",
      "language": "C#",
      "filename": "0208-ImplementTrie(Prefix Tree).cs",
      "path": "LeetCode/C#/0208-ImplementTrie(Prefix Tree).cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0208-ImplementTrie(Prefix%20Tree).cs",
      "approach": "1. Create a TrieNode class with 26 children and a boolean variable to check if it is the end of the word.",
      "tags": [],
      "steps": [],
      "timeComplexity": "Insert: O(n), Search: O(n), StartsWith: O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a TrieNode class with 26 children and a boolean variable to check if it is the end of the word.\n2. Create a Trie class with Insert, Search, and StartsWith methods.\n3. In the Insert method, iterate through the word and check if the current character's child is null. If it is null, create a new TrieNode and assign it to the current character's child.\n4. In the Search method, iterate through the word and check if the current character's child is null. If it is null, return false. If the iteration is completed, return the value of the EndOfWord variable.\n5. In the StartsWith method, iterate through the prefix and check if the current character's child is null. If it is null, return false. If the iteration is completed, return true.\n\nTime Complexity: Insert: O(n), Search: O(n), StartsWith: O(n)\nSpace Complexity: O(n)\n*/\npublic class TrieNode {                                         // TrieNode class\n    public TrieNode[] Children = new TrieNode[26];              // Array to store children nodes (one for each letter 'a' to 'z')\n    public bool EndOfWord = false;                              // Boolean to mark the end of the word\n}\npublic class Trie {                                             // Trie class\n\n    private TrieNode _trie;                                     // TrieNode object\n    public Trie() {\n        _trie = new TrieNode();                                 // Initialize the TrieNode object\n    }\n\n    public void Insert(string word) {                           // Method to insert a key into the Trie\n        var _curr = _trie;                                      // Initialize the curr pointer with the root node\n        foreach (char c in word) {                              // Iterate across the length of the string\n            if(_curr.Children[c - 'a'] == null) {               // Check if the node exists for the current character in the Trie\n                _curr.Children[c - 'a'] = new TrieNode();       // If node for current character does not exist, create a new node\n            }\n            _curr = _curr.Children[c - 'a'];                    // Move the curr pointer to the newly created node\n        }\n        _curr.EndOfWord = true;                                 // Mark the end of the word\n    }\n\n    public bool Search(string word) {                           // Method to search a key in the Trie\n        var _curr = _trie;                                      // Initialize the curr pointer with the root node\n        foreach (char c in word) {                              // Iterate across the length of the string\n            if (_curr.Children[c - 'a'] == null)                // Check if the node exists for the current character in the Trie\n                return false;                                   // Return false if the node does not exist\n            _curr = _curr.Children[c - 'a'];                    // Move the curr pointer to the already existing node for the current character\n        }\n        return _curr.EndOfWord;                                 // Return true if the word exists and is marked as ending\n    }\n\n    public bool StartsWith(string prefix) {                     // Method to search a prefix in the Trie\n        var _curr = _trie;                                      // Initialize the curr pointer with the root node\n        foreach (char c in prefix) {                            // Iterate across the length of the string\n            if (_curr.Children[c - 'a'] == null)                // Check if the node exists for the current character in the Trie\n                return false;                                   // Return false if the node does not exist\n            _curr = _curr.Children[c - 'a'];                    // Move the curr pointer to the already existing node for the current character\n        }\n        return true;                                            // Return true if the prefix exists\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.Insert(word);\n * bool param_2 = obj.Search(word);\n * bool param_3 = obj.StartsWith(prefix);\n */"
    },
    {
      "problemNumber": "0210",
      "title": "Course Schedule I I",
      "language": "C#",
      "filename": "0210-CourseScheduleII.cs",
      "path": "LeetCode/C#/0210-CourseScheduleII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0210-CourseScheduleII.cs",
      "approach": "Kahn's Algorithm",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(V+E) where V is the number of courses and E is the number of prerequisites.",
      "spaceComplexity": "O(V+E) where V is the number of courses and E is the number of prerequisites.",
      "solutionLink": "",
      "code": "/*\nApproach: Kahn's Algorithm\n1. Create a graph with number of courses as nodes and prerequisites as edges.\n2. Create an indegree array to store the indegree of each node.\n3. Create a queue to store the nodes with 0 indegree.\n4. Add all the nodes with 0 indegree to the queue.\n5. Visit the adjacent nodes of the node with 0 indegree, reduce the indegree of the adjacent nodes by 1.\n6. If the indegree of the adjacent node becomes 0, add it to the queue.\n7. Repeat the process until the queue is empty.\n8. If the number of nodes visited is equal to the number of courses, return true else return false.\n\nTime complexity: O(V+E) where V is the number of courses and E is the number of prerequisites.\nSpace complexity: O(V+E) where V is the number of courses and E is the number of prerequisites.\n*/\npublic class Solution {\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\n        List<int> order = new List<int>();                                              // Create order list\n        List<List<int>> graph = new List<List<int>>();                                  // Create graph\n        Queue<int> queue = new Queue<int>();                                            // Create queue\n        int[] inDegree = new int[numCourses];                                           // Create indegree array\n\n        int numCourseIndex = 0;                                                         // Variable to iterate through number of courses\n        while(numCourseIndex++ < numCourses) {                                          // Add empty list for each course\n            graph.Add(new List<int>());                                                 // Add empty list for each course\n        }\n\n        for (int i=0; i < prerequisites.Length; i++) {                                  // Add edges to the graph\n            int course = prerequisites[i][0];                                           // Add edge from prereqCourse to courseTobeCompletedNode\n            int coursePreq = prerequisites[i][1];                                       // Add edge from prereqCourse to courseTobeCompletedNode\n            graph[coursePreq].Add(course);                                              // Add edge from prereqCourse to courseTobeCompletedNode\n        }\n\n        for (int i=0; i<prerequisites.Length; i++) {                                    // Calculate indegree of all nodes\n            int course = prerequisites[i][0];                                           // Calculate indegree of all nodes\n            inDegree[course]++;                                                         // Calculate indegree of all nodes\n        }\n\n        for (int i=0; i<inDegree.Length; i++) {                                         // Add all 0 indegree elements to queue\n            if (inDegree[i] == 0) {                                                     // If the indegree of the node is 0\n                queue.Enqueue(i);                                                       // Add the node to the queue\n                order.Add(i);                                                           // Add the node to the order list\n            }\n        }\n\n        while(queue.Count != 0) {                                                       // Visit adjacent nodes, remove nodes from queue and add.\n            int courseP = queue.Dequeue();                                              // Dequeue the course\n            foreach(int course in graph[courseP]) {                                     // Visit the adjacent nodes\n                inDegree[course]--;                                                     // Reduce the indegree of the adjacent nodes by 1\n                if (inDegree[course] == 0) {                                            // If the indegree of the adjacent node becomes 0\n                    queue.Enqueue(course);                                              // Add the adjacent node to the queue\n                    order.Add(course);                                                  // Add the adjacent node to the order list\n                }\n            }\n        }\n\n        return order.Count == numCourses ? order.ToArray() : new int [0];               // If the number of nodes visited is equal to the number of courses, return true else return false.\n    }\n}\n\n/*\nApproach: DFS\nTODO\n*/"
    },
    {
      "problemNumber": "0213",
      "title": "House Robber I I",
      "language": "C#",
      "filename": "0213-HouseRobberII.cs",
      "path": "LeetCode/C#/0213-HouseRobberII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0213-HouseRobberII.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/house-robber-ii/solutions/6336237/simplest-solution-c-time-on-spacen-pleas-n0ta/\n\nApproach : Dynamic Programming Recursion with Memoization (Top-Down)\n1. Create a dp array of size 101\n2. Call the RobWay method with nums, 0, and n-2\n3. Call the RobWay method with nums, 1, and n-1\n4. Return the maximum of start0 and start1\n5. In the RobWay method:\n    a. Check if i > size, if yes return 0\n    b. Check if dp[i] != -1, if yes return dp[i]\n    c. Calculate the rob amount by adding the current house amount and calling the RobWay method with nums, i+2, and size\n    d. Calculate the skip amount by calling the RobWay method with nums, i+1, and size\n    e. Return the maximum of rob and skip\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    int[] dp = new int[101];                            // create a dp array of size 101\n\n    public int Rob(int[] nums) {                        // declare the Rob method\n        int n = nums.Length;                            // get the length of the nums array\n        if (n == 1)                                     // check if n == 1\n            return nums[0];                             // return the first element of the nums array\n        if (n == 2)                                     // check if n == 2\n            return Math.Max(nums[0], nums[1]);          // return the maximum of the first and second element of the nums array\n        Array.Fill(dp,-1);                              // fill the dp array with -1\n        int start0 = RobWay(nums, 0, n - 2);            // call the RobWay method with nums, 0, and n-2\n\n        Array.Fill(dp,-1);                              // fill the dp array with -1\n        int start1 = RobWay(nums, 1, n - 1);            // call the RobWay method with nums, 1, and n-1\n\n        return Math.Max(start0,start1);                 // return the maximum of start0 and start1\n    }\n    public int RobWay(int[] nums, int i, int size) {    // declare the RobWay method\n        if (i > size) {                                 // check if i > size\n            return 0;                                   // return 0\n        }\n        if(dp[i] != -1) {                               // check if dp[i] != -1\n            return dp[i];                               // return dp[i]\n        }\n        int rob = nums[i] + RobWay(nums, i+2, size);    // calculate the rob amount\n        int skip = RobWay(nums, i+1, size);             // calculate the skip amount\n\n        return dp[i] = Math.Max(rob, skip);             // return the maximum of rob and skip\n    }\n}\n/*\nApproach : Dynamic Programming Iterative with Constant Space (Bottom-Up)\nTBD\n*/"
    },
    {
      "problemNumber": "0217",
      "title": "Contains Duplicate",
      "language": "C#",
      "filename": "0217-ContainsDuplicate.cs",
      "path": "LeetCode/C#/0217-ContainsDuplicate.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0217-ContainsDuplicate.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public bool ContainsDuplicate(int[] nums) {\n        Dictionary<int,int> dict = new Dictionary<int,int>();\n\n        int index = 0;\n        while(index < nums.Length) {\n\n            if(dict.ContainsKey(nums[index])) {\n                return true;\n            }\n            else{\n                dict.Add(nums[index],nums[index]);\n            }\n\n            index++;\n        }\n\n        return false;\n    }\n}\n\n\n// Another Solution\npublic class Solution {\n    public bool ContainsDuplicate(int[] nums) {\n       \n        int index = 0;\n        Array.Sort(nums);\n        while(index < nums.Length - 1) {\n            if(nums[index] == nums[index+1])\n                return true;\n            index++;\n        }\n\n        return false;\n\n\n    }\n}\n"
    },
    {
      "problemNumber": "0219",
      "title": "Contains Duplicate I I",
      "language": "C#",
      "filename": "0219-ContainsDuplicateII.cs",
      "path": "LeetCode/C#/0219-ContainsDuplicateII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0219-ContainsDuplicateII.cs",
      "approach": "1. We will use a HashSet to store the elements.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We will use a HashSet to store the elements.\n2. We will iterate through the array and add the elements to the HashSet.\n3. If the element is already present in the HashSet, we will return true.\n4. If the difference between the current index and the previous index is greater than k, we will remove the element at the previous index.\n5. If we reach the end of the array, we will return false.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\npublic class Solution {\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\n        HashSet<int> hs = new HashSet<int>();\n        int i,j;\n        i = j = 0;\n        while(j<nums.Length) {\n            if( Math.Abs(i-j) <= k) {\n                if(!hs.Contains(nums[j])) {\n                    hs.Add(nums[j]);\n                    j++;\n                }\n                else {\n                    return true;\n                }\n            }\n            else {\n                hs.Remove(nums[i]);\n                i++;\n            }\n        }\n        return false;\n    }\n}"
    },
    {
      "problemNumber": "0226",
      "title": "Invert Binary Tree",
      "language": "C#",
      "filename": "0226-InvertBinaryTree.cs",
      "path": "LeetCode/C#/0226-InvertBinaryTree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0226-InvertBinaryTree.cs",
      "approach": "Recursive",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursive\n1. Call the Invert method with the root\n2. Return the root\n3. Invert method:\n    a. Check if the root is null\n    b. Call the Invert method with the left child of the root\n    c. Call the Invert method with the right child of the root\n    d. Swap the left and right child of the root\nTime complexity: O(n)\nSpace complexity: O(1)\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode InvertTree(TreeNode root) {\n        Invert(root);                           // call invert tree method\n        return root;                            // return the root\n    }\n    public static void Invert(TreeNode root) {  // declare the invert method\n        if (root == null) {                     // check if the root is null\n            return;                             // return\n        }\n        Invert(root.left);                      // call the invert method with the left child of the root\n        Invert(root.right);                     // call the invert method with the right child of the root\n        TreeNode temp;                          // declare a temp variable\n        temp = root.left;                       // swap the left and right child of the root\n        root.left = root.right;                 // swap the left and right child of the root\n        root.right = temp;                      // swap the left and right child of the root\n    }\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\nApproach: Iterative\nTODO\n*/"
    },
    {
      "problemNumber": "0230",
      "title": "Kth Smallest Elementina B S T",
      "language": "C#",
      "filename": "0230-KthSmallestElementinaBST.cs",
      "path": "LeetCode/C#/0230-KthSmallestElementinaBST.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0230-KthSmallestElementinaBST.cs",
      "approach": "1) Create a list to store the inorder traversal items.",
      "tags": [],
      "steps": [
        "1) Create a list to store the inorder traversal items.",
        "2) Call the InOrderTraversal method to traverse the tree in inorder fashion.",
        "3) Return the kth smallest element from the list.",
        "4) In the InOrderTraversal method, if the node is null, return.",
        "5) Traverse the left subtree.",
        "6) Add the current node value to the list.",
        "7) Traverse the right subtree."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1) Create a list to store the inorder traversal items.\n2) Call the InOrderTraversal method to traverse the tree in inorder fashion.\n3) Return the kth smallest element from the list.\n4) In the InOrderTraversal method, if the node is null, return.\n5) Traverse the left subtree.\n6) Add the current node value to the list.\n7) Traverse the right subtree.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    List<int> inorderTraversalItems = new List<int>();  // Declare the list to hold inorder traversal items.\n    public int KthSmallest(TreeNode root, int k) {\n        InOrderTraversal(root);                         // Call the InOrderTraversal method.\n        return inorderTraversalItems[k-1];              // Return the kth smallest element.\n    }\n    public void InOrderTraversal(TreeNode node) {\n        if (node == null) return;                       // Base case.\n        InOrderTraversal(node.left);                    // Traverse the left subtree.\n        inorderTraversalItems.Add(node.val);            // Add the current node value to the list.\n        InOrderTraversal(node.right);                   // Traverse the right subtree.\n    }\n}"
    },
    {
      "problemNumber": "0232",
      "title": "Implement Queueusing Stacks",
      "language": "C#",
      "filename": "0232-ImplementQueueusingStacks.cs",
      "path": "LeetCode/C#/0232-ImplementQueueusingStacks.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0232-ImplementQueueusingStacks.cs",
      "approach": "1. We will use two stacks to implement the queue.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We will use two stacks to implement the queue.\n2. We will use one stack to push the elements and another stack to pop the elements.\n3. When we push the elements, we will push them to the push stack.\n4. When we pop the elements, we will check if the pop stack is empty or not.\n5. If the pop stack is empty, we will pop all the elements from the push stack and push them to the pop stack.\n6. Then we will pop the top element from the pop stack.\n7. When we peek the elements, we will check if the pop stack is empty or not.\n8. If the pop stack is empty, we will pop all the elements from the push stack and push them to the pop stack.\n9. Then we will peek the top element from the pop stack.\n10. When we check if the queue is empty or not, we will check if both the push and pop stacks are empty or not.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\npublic class MyQueue {\n    Stack<int> _sPush;                                      // Stack to push the elements\n    Stack<int> _sPop;                                       // Stack to pop the elements\n\n    public MyQueue() {\n        _sPush = new Stack<int>();                          // Initialize the push stack\n        _sPop = new Stack<int>();                           // Initialize the pop stack\n    }\n\n    public void Push(int x) {\n        _sPush.Push(x);                                     // Push the element to the push stack\n    }\n\n    public int Pop() {\n        if(_sPop.Count() == 0) {                            // If the pop stack is empty\n            while(_sPush.Count()!=0) {                      // If the pop stack is empty, pop all the elements from the push stack and push them to the pop stack\n                _sPop.Push(_sPush.Pop());                   // Push the elements to the pop stack\n            }\n        }\n        return _sPop.Pop();                                 // Pop the top element from the pop stack\n    }\n\n    public int Peek() {\n        if(_sPop.Count() == 0) {                            // If the pop stack is empty\n            while(_sPush.Count()!=0) {                      // If the pop stack is empty, pop all the elements from the push stack and push them to the pop stack\n                _sPop.Push(_sPush.Pop());                   // Push the elements to the pop stack\n            }\n        }\n        return _sPop.Peek();                                // Peek the top element from the pop stack\n    }\n\n    public bool Empty() {\n        return _sPop.Count() == 0 && _sPush.Count() == 0;   // Check if the queue is empty or not\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Peek();\n * bool param_4 = obj.Empty();\n */"
    },
    {
      "problemNumber": "0234",
      "title": "Palindrome Linked List",
      "language": "C#",
      "filename": "0234-PalindromeLinkedList.cs",
      "path": "LeetCode/C#/0234-PalindromeLinkedList.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0234-PalindromeLinkedList.cs",
      "approach": "1. Find the length of the linked list.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Find the length of the linked list.\n2. Find the mid of the linked list.\n3. Reverse the linked list from mid.\n4. Compare the first half of the linked list with the reversed second half of the linked list.\n5. If they are equal, return true. Else, return false.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsPalindrome(ListNode head) {\n        int lengthList, mid, count;                 // lengthList = length of the linked list, mid = mid of the linked list, count = counter variable\n        lengthList = count = 0;                     // Initialize lengthList and count to 0\n\n        ListNode i, j;                              // i = head of the linked list, j = head of the linked list\n        lengthList = FindLengthOfLinkedList(head);  // Find the length of the linked list\n\n        mid = lengthList/2;                         // Find the mid of the linked list\n        i = j = head;                               // Initialize i and j to head of the linked list\n\n        while (count != mid) {                      // Traverse the linked list till mid\n            j = j.next;                             // Move j to next node\n            count++;                                // Increment count\n        }\n\n        j = ReverseLinkedList(j);                   // Reverse the linked list from mid\n\n        while(j != null) {                          // Compare the first half of the linked list with the reversed second half of the linked list\n            if(i.val != j.val) {                    // If they are not equal, return false\n                return false;                       // Return false\n            }\n            i = i.next;                             // Move i to next node\n            j = j.next;                             // Move j to next node\n        }\n\n        return true;                                // Return true\n    }\n\n    public static int FindLengthOfLinkedList(ListNode head) {       // Function to find the length of the linked list\n        ListNode i = head;                                          // Initialize i to head of the linked list\n        int lengthList=0;                                           // Initialize lengthList to 0\n\n        while (i != null) {                                         // Traverse the linked list\n            i = i.next;                                             // Move i to next node\n            lengthList++;                                           // Increment lengthList\n        }\n\n        return lengthList;                                          // Return length of the linked list\n    }\n\n    public static ListNode ReverseLinkedList(ListNode head) {       // Function to reverse the linked list\n        ListNode curr, prev, temp;                                  // curr = current node, prev = previous node, temp = temporary node\n        curr = head;                                                // Initialize curr to head of the linked list\n        prev = null;                                                // Initialize prev to null\n        while(curr != null) {                                       // Traverse the linked list\n            temp = curr.next;                                       // Store the next node in temp\n            curr.next = prev;                                       // Reverse the linked list\n            prev = curr;                                            // Move prev to curr\n            curr = temp;                                            // Move curr to temp\n        }\n        return prev;                                                // Return the head of the reversed linked list\n    }\n}"
    },
    {
      "problemNumber": "0235",
      "title": "Lowest Common Ancestorofa Binary Search Tree",
      "language": "C#",
      "filename": "0235-LowestCommonAncestorofaBinarySearchTree.cs",
      "path": "LeetCode/C#/0235-LowestCommonAncestorofaBinarySearchTree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0235-LowestCommonAncestorofaBinarySearchTree.cs",
      "approach": "1. If the value of p and q is less than the value of the root, then the lowest common ancestor will be in the left subtree.",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. If the value of p and q is less than the value of the root, then the lowest common ancestor will be in the left subtree.\n2. If the value of p and q is greater than the value of the root, then the lowest common ancestor will be in the right subtree.\n3. Else, the root is the lowest common ancestor.\n4. Recursively call the function with the left or right subtree based on the value of p and q.\n5. Return the root if the value of p and q is less than the value of the root or greater than the value of the root.\n6. Else, return the root.\n7. If the root is null or p or q is null, return null.\n\nTime complexity is O(h) where h is the height of the tree.\nSpace complexity is O(h) where h is the height of the tree.\n\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || p == null || q == null) {           // if anyone is null return null\n            return null;\n        }\n        if(p.val < root.val && q.val < root.val) {              // if both are less than root, then go to left subtree\n            return LowestCommonAncestor(root.left, p , q);      // recursively call the function with left subtree\n        }\n        else if (p.val > root.val && q.val > root.val) {        // if both are greater than root, then go to right subtree\n            return LowestCommonAncestor(root.right, p , q);     // recursively call the function with right subtree\n        }\n        else {\n            return root;                                        // else return root\n        }\n    }\n}"
    },
    {
      "problemNumber": "0238",
      "title": "Productof Array Except Self",
      "language": "C#",
      "filename": "0238-ProductofArrayExceptSelf.cs",
      "path": "LeetCode/C#/0238-ProductofArrayExceptSelf.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0238-ProductofArrayExceptSelf.cs",
      "approach": "1. Initialize preFix and postFix to 1.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Initialize preFix and postFix to 1.\n2. Initialize an array res of the same length as nums.\n3. Iterate through the array and update res[i] to preFix.\n4. Update preFix to preFix * nums[i].\n5. Iterate through the array in reverse and update res[i] to res[i] * postFix.\n6. Update postFix to postFix * nums[i].\n7. Return res.\n\nTime complexity: O(n)\nSpace complexity: O(1)\nwhere n is the number of elements in the array.\nand assuming output array is not considered as extra space.\n\n*/\npublic class Solution {\n    public int[] ProductExceptSelf(int[] nums) {\n\n        int preFix = 1, postFix = 1;\n        int[] res = new int[nums.Length];\n\n        for (int i=0; i < nums.Length; i++) {\n            res[i] = preFix;\n            preFix = preFix * nums[i];\n        }\n\n        for (int i=nums.Length - 1; i >= 0; i--) {\n            res[i] = res[i] * postFix;\n            postFix = postFix * nums[i];\n        }\n\n        return res;\n    }\n}"
    },
    {
      "problemNumber": "0242",
      "title": "Valid Anagram",
      "language": "C#",
      "filename": "0242-ValidAnagram.cs",
      "path": "LeetCode/C#/0242-ValidAnagram.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0242-ValidAnagram.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public bool IsAnagram(string s, string t) {\n\n        if (s.Length != t.Length)\n            return false;\n        \n        int[] set = new int[256] ;\n        \n        foreach(char c in s) {\n            set[c]++;  \n        }\n\n        foreach(char c in t) {\n            set[c]--;  \n        }\n\n        int index = 0;\n        while(index < set.Length) {\n            if(set[index]!=0)\n                return false;\n            index++;\n        }\n\n        return true;\n    }\n}\n"
    },
    {
      "problemNumber": "0268",
      "title": "Missing Number",
      "language": "C#",
      "filename": "0268-MissingNumber.cs",
      "path": "LeetCode/C#/0268-MissingNumber.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0268-MissingNumber.cs",
      "approach": "Xor",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Xor\n1. We know that the numbers are from 0 to n. So, we can xor all the numbers from 0 to n and all the numbers in the array.\n2. The result will be the missing number.\n3. The reason is that the xor of the same number is 0. So, the missing number will be left out.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public int MissingNumber(int[] nums) {\n        int lengthOfNums = nums.Length;         // Length of the array\n        int result = lengthOfNums;              // Initialize the result with the length of the array\n        for(int i=0; i<lengthOfNums; i++) {     // Loop through the array\n            result = result ^ i ^ nums[i];      // Xor the result with the index and the number in the array\n        }                                       // The result will be the missing number\n        return result;                          // Return the result\n     }\n}\n\n\n/*\nApproach: Sum of n numbers\n1. We know that the numbers are from 0 to n. So, we can calculate the sum of n numbers.\n2. We can calculate the sum of all the numbers in the array.\n3. The difference between the sum of n numbers and the sum of all the numbers in the array will be the missing number.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int MissingNumber(int[] nums) {\n        int sumOfElements = nums.Sum();                                     // Sum of all the elements in the array\n        int lengthOfElements = nums.Length;                                 // Length of the array\n        int sumOfNElements = (lengthOfElements*(lengthOfElements+1)) / 2;   // Sum of n numbers\n        int result = sumOfNElements - sumOfElements;                        // Missing number\n        return result;                                                      // Return the missing number\n    }\n}"
    },
    {
      "problemNumber": "0278",
      "title": "First Bad Version",
      "language": "C#",
      "filename": "0278-FirstBadVersion.cs",
      "path": "LeetCode/C#/0278-FirstBadVersion.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0278-FirstBadVersion.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "    /*\n    Solution: https://leetcode.com/problems/first-bad-version/solutions/7380676/simplest-solution-c-time-olog-n-space1-p-lck4/\n    Approach: Binary Search to Find First Occurrence\n    Tags: Binary Search, Interactive Problem\n    1) Use binary search with left starting at 1 and right at n.\n    2) While left < right, calculate mid point to avoid overflow.\n    3) If mid version is bad, the first bad version is at mid or before it.\n    4) If mid version is good, the first bad version must be after mid.\n    5) Continue until left equals right, which points to the first bad version.\n\n    Time Complexity: O(log n)\n    Space Complexity: O(1)\n    */\n\n    /* The isBadVersion API is defined in the parent class VersionControl.\n        bool IsBadVersion(int version); */\n\n    public class Solution : VersionControl {\n        public int FirstBadVersion(int n) {\n            int left = 1;                                           // Start from version 1\n            int right = n;                                          // End at version n\n            while (left < right) {                                  // Continue until pointers converge\n                int mid = left + (right - left) / 2;                // Calculate mid to avoid overflow\n                if (IsBadVersion(mid)) {                            // If mid version is bad\n                    right = mid;                                    // First bad version is at mid or before it\n                }\n                else {                                              // If mid version is good\n                    left = mid + 1;                                 // First bad version must be after mid\n                }\n            }\n\n            return left;                                            // Return first bad version (left == right)\n        }\n    }"
    },
    {
      "problemNumber": "0283",
      "title": "Move Zeroes",
      "language": "C#",
      "filename": "0283-MoveZeroes.cs",
      "path": "LeetCode/C#/0283-MoveZeroes.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0283-MoveZeroes.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Two pointer approach\npublic class Solution {\n    public void MoveZeroes(int[] nums) {\n        int  i = 0;\n        int  j = 0;\n        int  k = 0;\n        while(j < nums.Length) { // just swap the number if the current number is non zero\n            if (nums[j] != 0) {\n                k=nums[i];\n                nums[i] = nums[j];\n                nums[j] = k ;\n                i++;\n            }\n            j++;\n        }\n    }\n}"
    },
    {
      "problemNumber": "0287",
      "title": "Findthe Duplicate Number",
      "language": "C#",
      "filename": "0287-FindtheDuplicateNumber.cs",
      "path": "LeetCode/C#/0287-FindtheDuplicateNumber.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0287-FindtheDuplicateNumber.cs",
      "approach": "Floyd's Tortoise and Hare (Cycle Detection)",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Floyd's Tortoise and Hare (Cycle Detection)\n1. Create two pointers slow and fast and assign them to 0.\n2. Move the slow pointer by one step and the fast pointer by two steps.\n3. If the slow and fast pointers meet, break the loop.\n4. Move the slow pointer to 0.\n5. Move both the slow and fast pointers by one step until they meet.\n6. Return the slow pointer.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n*/\npublic class Solution {\n    public int FindDuplicate(int[] nums) {\n        int slow, fast;                     // Create two pointers slow and fast.\n        slow = fast = 0;                    // Assign both the pointers to 0.\n        while(true) {                       // Move the slow pointer by one step and the fast pointer by two steps.\n            slow = nums[slow];              // Move the slow pointer.\n            fast = nums[nums[fast]];        // Move the fast pointer.\n            if(nums[slow]==nums[fast]) {    // If the slow and fast pointers meet, break the loop.\n                break;                      // Break the loop.\n            }\n        }\n        slow = 0;                           // Move the slow pointer to 0.\n        while(slow != fast) {               // Move both the slow and fast pointers by one step until they meet.\n            slow = nums[slow];              // Move the slow pointer.\n            fast = nums[fast];              // Move the fast pointer.\n        }\n        return slow;                        // Return the slow pointer.\n    }\n}"
    },
    {
      "problemNumber": "0290",
      "title": "Word Pattern",
      "language": "C#",
      "filename": "0290-WordPattern.cs",
      "path": "LeetCode/C#/0290-WordPattern.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0290-WordPattern.cs",
      "approach": "1. Create two dictionaries, one to store the mapping of word to pattern and another to store the mapping of pattern to word.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create two dictionaries, one to store the mapping of word to pattern and another to store the mapping of pattern to word.\n2. Split the string s into words and convert the pattern into a char array.\n3. Iterate through the pattern and for each pattern, check if the word is already mapped to the pattern and if the pattern is already mapped to the word.\n4. If the mapping is not present, add the mapping to the dictionaries.\n5. If the mapping is present, check if the mapping is correct.\n6. If the mapping is not correct, return false.\n7. If the loop completes, return true.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n\n*/\npublic class Solution {\n    public bool WordPattern(string pattern, string s) {\n            Dictionary<string,char> dictWordToPattern = new Dictionary<string, char>();\n            Dictionary<char,string> dictPatternToWord = new Dictionary<char, string>();\n\n            var words = s.Split(' ');\n            var patternChars = pattern.ToCharArray();\n\n            if (words.Length != patternChars.Length) return false;\n\n            int wordsPointer = 0;\n            int patternPointer = 0;\n\n            while(patternPointer < pattern.Length) {\n\n                var currentPattern = pattern[patternPointer];\n                var currentWord = words[wordsPointer];\n\n                if (dictPatternToWord.ContainsKey(currentPattern) && dictPatternToWord[currentPattern] != currentWord) return false;\n\n                if (dictWordToPattern.ContainsKey(currentWord) && dictWordToPattern[currentWord] != currentPattern) return false;\n\n                dictPatternToWord[currentPattern] = currentWord;\n                dictWordToPattern[currentWord] = currentPattern;\n\n\n                wordsPointer++;\n                patternPointer++;\n\n            }\n\n            return true;\n    }\n}"
    },
    {
      "problemNumber": "0295",
      "title": "Find Medianfrom Data Stream",
      "language": "C#",
      "filename": "0295-FindMedianfromDataStream.cs",
      "path": "LeetCode/C#/0295-FindMedianfromDataStream.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0295-FindMedianfromDataStream.cs",
      "approach": "1. Create two Priority Queues, one for the left part of the array and the other for the right part of the array.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(log n) for AddNum and O(1) for FindMedian",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create two Priority Queues, one for the left part of the array and the other for the right part of the array.\n2. Add the number to the left part if the number is less than or equal to the top of the left part Priority Queue.\n3. Add the number to the right part if the number is greater than the top of the left part Priority Queue.\n4. Balance the heaps by moving the top of the left part Priority Queue to the right part Priority Queue if the size of the left part Priority Queue is greater than the size of the right part Priority Queue by more than 1.\n5. Balance the heaps by moving the top of the right part Priority Queue to the left part Priority Queue if the size of the right part Priority Queue is greater than the size of the left part Priority Queue.\n6. If the size of the left part Priority Queue is equal to the size of the right part Priority Queue, return the average of the top of the left part Priority Queue and the top of the right part Priority Queue.\n7. If the size of the left part Priority Queue is greater than the size of the right part Priority Queue, return the top of the left part Priority Queue.\n\nTime Complexity: O(log n) for AddNum and O(1) for FindMedian\nSpace Complexity: O(n)\n\n*/\n\npublic class MedianFinder {\n\n    PriorityQueue<int,int> _rightMinPQ;                                                     // Priority Queue for the right part of the array\n    PriorityQueue<int,int> _leftMaxPQ;                                                      // Priority Queue for the left part of the array\n\n    public MedianFinder() {\n        _rightMinPQ = new PriorityQueue<int,int>();                                         // Initialize the Priority Queues\n        _leftMaxPQ = new PriorityQueue<int,int>(Comparer<int>.Create((x, y) => y - x));     // Initialize the Priority Queues\n    }\n\n\n    public void AddNum(int num) {\n        if (_leftMaxPQ.Count == 0 || num <= _leftMaxPQ.Peek()) {                            // Add the number to the left part if the number is less than or equal to the top of the left part Priority Queue\n            _leftMaxPQ.Enqueue(num,num);                                                    // Add the number to the left part\n        }\n        else {\n            _rightMinPQ.Enqueue(num,num);                                                   // Add the number to the right part\n        }\n        // Balance the heaps\n        if (_leftMaxPQ.Count > _rightMinPQ.Count + 1 ) {                                    // Balance the heaps by moving the top of the left part Priority Queue to the right part Priority Queue if the size of the left part Priority Queue is greater than the size of the right part Priority Queue by more than 1\n            int tempR = _leftMaxPQ.Dequeue();                                               // Move the top of the left part Priority Queue to the right part Priority Queue\n           _rightMinPQ.Enqueue(tempR,tempR);                                                // Move the top of the left part Priority Queue to the right part Priority Queue\n        }\n        else if(_rightMinPQ.Count > _leftMaxPQ.Count) {                                     // Balance the heaps by moving the top of the right part Priority Queue to the left part Priority Queue if the size of the right part Priority Queue is greater than the size of the left part Priority Queue\n            int tempL = _rightMinPQ.Dequeue();                                              // Move the top of the right part Priority Queue to the left part Priority Queue\n            _leftMaxPQ.Enqueue(tempL,tempL);                                                // Move the top of the right part Priority Queue to the left part Priority Queue\n        }\n\n    }\n\n    public double FindMedian() {\n        if (_leftMaxPQ.Count == _rightMinPQ.Count) {                                        // If the size of the left part Priority Queue is equal to the size of the right part Priority Queue, return the average of the top of the left part Priority Queue and the top of the right part Priority Queue\n            return (_leftMaxPQ.Peek() + _rightMinPQ.Peek()) / 2.0;                          // Return the average of the top of the left part Priority Queue and the top of the right part Priority Queue\n        }\n        else {\n            return _leftMaxPQ.Peek();                                                       // If the size of the left part Priority Queue is greater than the size of the right part Priority Queue, return the top of the left part Priority Queue\n        }\n\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.AddNum(num);\n * double param_2 = obj.FindMedian();\n */"
    },
    {
      "problemNumber": "0300",
      "title": "Longest Increasing Subsequence",
      "language": "C#",
      "filename": "0300-LongestIncreasingSubsequence.cs",
      "path": "LeetCode/C#/0300-LongestIncreasingSubsequence.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0300-LongestIncreasingSubsequence.cs",
      "approach": "Recursion with memoization",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(n^2)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursion with memoization\n1. We can either take the current element or skip it.\n2. If we take the current element, we need to check if we have taken the previous element or not.\n3. If we have taken the previous element, then we need to skip the current element.\n4. If we have not taken the previous element, then we can take the current element.\n5. We can use a flag to keep track of whether we have taken the previous element or not.\n6. We can use a 2D array to store the maximum sum we can get starting from the ith element and whether we have taken the previous element or not.\n7. If we have already calculated the maximum sum starting from the ith element and whether we have taken the previous element or not, then we can return it.\n8. Otherwise, we can calculate the maximum sum starting from the ith element and whether we have taken the previous element or not.\n9. If we have taken the current element, then we need to skip the next element.\n10. If we have not taken the current element, then we can take the next element.\n11. We can return the maximum of the two.\n12. We can keep track of the maximum sum we can get starting from the 0th element and whether we have taken the previous element or not.\n13. We can return the maximum sum starting from the 0th element and whether we have taken the previous element or not.\n\nTime complexity: O(n^2)\nSpace complexity: O(n^2)\n\n*/\npublic class Solution {\n    int n = 0;                                              // Length of the input array\n    int[,] dp = new int[2501,2501];                         // 2D array to store the maximum sum we can get starting from the ith element and whether we have taken the previous element or not.\n    public int LengthOfLIS(int[] nums) {                    // Function to get the length of the longest increasing subsequence\n        n = nums.Length;                                    // Length of the input array\n        for (int i=0; i<2501; i++) {                        // Initialize the 2D array with -1\n            for (int j=0; j<2501; j++) {                    // Initialize the 2D array with -1\n                dp[i,j] = -1;                               // Initialize the 2D array with -1\n            }\n        }\n        return FindLengthOfLIS(nums, 0, -1);                // Return the length of the longest increasing subsequence\n    }\n\n    public int FindLengthOfLIS(int[] nums, int i, int p) {  // Function to find the length of the longest increasing subsequence\n        if (i >= n) {                                       // If the index is greater than or equal to the length of the input array, then return 0\n            return 0;                                       // If the index is greater than or equal to the length of the input array, then return 0\n        }\n        if (p!= -1 && dp[i,p] != -1)                        // If we have already calculated the maximum sum starting from the ith element and whether we have taken the previous element or not, then return it\n            return dp[i,p];                                 // If we have already calculated the maximum sum starting from the ith element and whether we have taken the previous element or not, then return it\n\n        int take = 0;                                       // Value to take\n        if (p == -1 || nums[i] > nums[p]) {                 // If we have not taken the previous element or the current element is greater than the previous element, then we can take the current element\n            take = 1 + FindLengthOfLIS(nums, i+1, i);       // Take the current element\n        }\n\n        int skip = FindLengthOfLIS(nums, i+1, p);           // Skip the current element\n        if (p != -1)                                        // If we have taken the previous element, then we need to skip the current element\n            dp[i,p] = Math.Max(take, skip);                 // Return the maximum of the two\n        return Math.Max(take, skip);                        // Return the maximum of the two\n    }\n}"
    },
    {
      "problemNumber": "0303",
      "title": "Range Sum Query- Immutable",
      "language": "C#",
      "filename": "0303-RangeSumQuery-Immutable.cs",
      "path": "LeetCode/C#/0303-RangeSumQuery-Immutable.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0303-RangeSumQuery-Immutable.cs",
      "approach": "1. We will store the input array in a private variable _nums.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We will store the input array in a private variable _nums.\n2. We will then implement the SumRange method that will return the sum of the elements from left to right.\n3. We will iterate from left to right and add the elements to the sum.\n4. We will return the sum.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n*/\npublic class NumArray {\n    private int[] _nums;                                    // private variable to store the input array\n    public NumArray(int[] nums) {\n        _nums = nums;                                       // store the input array\n    }\n\n    public int SumRange(int left, int right) {              // method to return the sum of elements from left to right\n        int sum = 0;                                        // variable to store the sum\n        while (left <= right) {                             // iterate from left to right\n            sum = sum + _nums[left];                        // add the element to the sum\n            left++;                                         // increment left\n        }\n        return sum;                                         // return the sum\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.SumRange(left,right);\n */\n"
    },
    {
      "problemNumber": "0326",
      "title": "Powerof Three",
      "language": "C#",
      "filename": "0326-PowerofThree.cs",
      "path": "LeetCode/C#/0326-PowerofThree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0326-PowerofThree.cs",
      "approach": "Iterative Division",
      "tags": [
        "Math",
        "Iteration"
      ],
      "steps": [
        "1) If n is less than or equal to 0, it cannot be a power of three.",
        "2) While n is divisible by 3, divide n by 3.",
        "3) After the loop, if n is reduced to 1, it is a power of three.",
        "4) Otherwise, it is not a power of three."
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nVideo: https://www.youtube.com/watch?v=11lCatB_H_A\nSolution: https://leetcode.com/problems/power-of-three/solutions/7074870/simplest-solution-c-time-olog3-n-space1-ficms/\nApproach: Iterative Division\nTags: Math, Iteration\n1) If n is less than or equal to 0, it cannot be a power of three.\n2) While n is divisible by 3, divide n by 3.\n3) After the loop, if n is reduced to 1, it is a power of three.\n4) Otherwise, it is not a power of three.\n\nTime Complexity: O(log n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool IsPowerOfThree(int n) {\n        if (n <= 0)                         // Negative numbers and zero are not powers of three\n            return false;\n        while(n % 3 == 0) {                 // While n is divisible by 3\n            n = n / 3;                      // Divide n by 3\n        }\n        return n == 1;                      // If n is reduced to 1, it's a power of three\n    }\n}"
    },
    {
      "problemNumber": "0342",
      "title": "Powerof Four",
      "language": "C#",
      "filename": "0342-PowerofFour.cs",
      "path": "LeetCode/C#/0342-PowerofFour.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0342-PowerofFour.cs",
      "approach": "Divide by 4 until n becomes 1 or not divisible",
      "tags": [
        "Math",
        "Iteration"
      ],
      "steps": [
        "1) If n is less than or equal to 0, it cannot be a power of four.",
        "2) While n is greater than 1, check if n is divisible by 4.",
        "3) If divisible, divide n by 4; otherwise, return false.",
        "4) If n is reduced to 1, it is a power of four."
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/power-of-four/solutions/7087932/simplest-solution-c-time-olog4-n-space1-x6b5f/\nApproach: Divide by 4 until n becomes 1 or not divisible\nTags: Math, Iteration\n1) If n is less than or equal to 0, it cannot be a power of four.\n2) While n is greater than 1, check if n is divisible by 4.\n3) If divisible, divide n by 4; otherwise, return false.\n4) If n is reduced to 1, it is a power of four.\n\nTime Complexity: O(log n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool IsPowerOfFour(int n) {\n        if (n <= 0)                         // Negative numbers and zero are not powers of four\n            return false;\n        while (n > 1) {                     // While n is greater than 1\n            if (n % 4 == 0) {               // If n is divisible by 4\n                n = n / 4;                  // Divide n by 4\n            }\n            else {\n                return false;                // If not divisible by 4, not a power of four\n            }\n        }\n        return true;                        // If n is reduced to 1, it's a power of four\n    }\n}"
    },
    {
      "problemNumber": "0344",
      "title": "Reverse String",
      "language": "C#",
      "filename": "0344-ReverseString.cs",
      "path": "LeetCode/C#/0344-ReverseString.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0344-ReverseString.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public void ReverseString(char[] s) {\n\n        int left = 0;\n        int right = s.Length-1;\n        char temp;\n\n        while ( left <= right ) {\n\n            temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;\n\n            left++;\n            right--;\n        }\n\n    }\n}"
    },
    {
      "problemNumber": "0344",
      "title": "Reverse String",
      "language": "Python",
      "filename": "0344-ReverseString.py",
      "path": "LeetCode/Python/0344-ReverseString.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/0344-ReverseString.py",
      "approach": "1. Initialize two pointers, left and right, at the start and end of the string, respectively.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n) - We iterate through the string once.",
      "spaceComplexity": "O(1) - We do not use any extra space.",
      "solutionLink": "",
      "code": "'''\nApproach:\n1. Initialize two pointers, left and right, at the start and end of the string, respectively.\n2. Swap the characters at the left and right pointers.\n3. Increment the left pointer and decrement the right pointer.\n4. Continue swapping the characters until the left pointer is greater than the right pointer.\n5. The string is now reversed in place.\n\nTime complexity:\nO(n) - We iterate through the string once.\n\nSpace complexity:\nO(1) - We do not use any extra space.\n\n'''\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        left = 0\n        right = len(s) - 1\n        while(left <= right):\n            temp = s[left]\n            s[left] = s[right]\n            s[right] = temp\n            left = left + 1\n            right = right - 1\n"
    },
    {
      "problemNumber": "0347",
      "title": "Top K Frequent Elements",
      "language": "C#",
      "filename": "0347-TopKFrequentElements.cs",
      "path": "LeetCode/C#/0347-TopKFrequentElements.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0347-TopKFrequentElements.cs",
      "approach": "1. Create a priority queue to store the numbers based on their frequency.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(nlogk)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a priority queue to store the numbers based on their frequency.\n2. Create a dictionary to store the frequency of each number.\n3. Iterate through the numbers array and for each number, check if it is already present in the dictionary.\n4. If it is present, update the frequency of the number.\n5. If it is not present, add the number to the dictionary with a frequency of 1.\n6. Add the numbers and their frequencies to the priority queue.\n7. Iterate through the priority queue and dequeue the top k elements.\n8. Return the top k elements as the result.\n\nTime complexity: O(nlogk)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int[] TopKFrequent(int[] nums, int k) {\n\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>(Comparer<int>.Create((x, y) => y - x));\n        Dictionary<int,int> dict = new Dictionary<int,int>();\n        List<int> result = new List<int>();\n        int index = 0;\n\n        while (index < nums.Length) {\n\n            if(!dict.ContainsKey(nums[index])) {\n                dict.Add(nums[index],1);\n            }\n            else {\n                dict[nums[index]] = dict[nums[index]] + 1;\n            }\n\n            index++;\n        }\n\n        foreach(var kv in dict) {\n            pq.Enqueue(kv.Key,kv.Value);\n        }\n\n        index = 0;\n\n        while(index < k && pq.Count != 0) {\n            var dqNum = pq.Dequeue();\n            result.Add(dqNum);\n            index++;\n        }\n\n        return result.ToArray();\n    }\n}"
    },
    {
      "problemNumber": "0349",
      "title": "Intersection Of Two Arrays",
      "language": "C#",
      "filename": "0349-IntersectionOfTwoArrays.cs",
      "path": "LeetCode/C#/0349-IntersectionOfTwoArrays.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0349-IntersectionOfTwoArrays.cs",
      "approach": "1. Create a HashSet to store the elements of the first array.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n + m), where n is the length of the first array and m is the length of the second array.",
      "spaceComplexity": "O(n), where n is the length of the first array.",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a HashSet to store the elements of the first array.\n2. Create a List to store the common elements of the two arrays.\n3. Iterate through the first array and add all the elements to the HashSet.\n4. Iterate through the second array and check if the element is present in the HashSet.\n5. If the element is present, remove it from the HashSet and add it to the List.\n6. Convert the List to an array and return the result.\n\nTime Complexity: O(n + m), where n is the length of the first array and m is the length of the second array.\nSpace Complexity: O(n), where n is the length of the first array.\n\n*/\npublic class Solution {\n    public int[] Intersection(int[] nums1, int[] nums2) {\n        HashSet<int> hs = new HashSet<int>();\n        List<int> result = new List<int>();\n\n        foreach(int num in nums1) {\n            hs.Add(num);\n        }\n\n        foreach(int num in nums2) {\n            if(hs.Contains(num)) {\n                hs.Remove(num);\n                result.Add(num);\n\n            }\n        }\n\n        return result.ToArray();\n    }\n}"
    },
    {
      "problemNumber": "0374",
      "title": "Guess Number Higheror Lower",
      "language": "C#",
      "filename": "0374-GuessNumberHigherorLower.cs",
      "path": "LeetCode/C#/0374-GuessNumberHigherorLower.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0374-GuessNumberHigherorLower.cs",
      "approach": "Binary Search",
      "tags": [],
      "steps": [
        "1) Initialize the left and right pointers",
        "2) Iterate through the array",
        "3) Calculate the mid",
        "4) If the mid element is equal to the target, return the mid",
        "5) If the mid element is less than the target, increment the left pointer",
        "6) If the mid element is greater than the target, decrement the right pointer",
        "7) Return the left pointer"
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Binary Search\n1) Initialize the left and right pointers\n2) Iterate through the array\n3) Calculate the mid\n4) If the mid element is equal to the target, return the mid\n5) If the mid element is less than the target, increment the left pointer\n6) If the mid element is greater than the target, decrement the right pointer\n7) Return the left pointer\n\nTime complexity: O(log n)\nSpace complexity: O(1)\n\n*/\n/**\n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is higher than the picked number\n *\t\t\t      1 if num is lower than the picked number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution : GuessGame {\n    public int GuessNumber(int n) {\n        int left = 0;                               // Initialize left pointer\n        int right = n;                              // Initialize right pointer\n\n        while(left<=right) {                        // Iterate through the array\n\n            int mid = left+(right-left)/2;          // Calculate the mid    // Prevent overflow by using this formula (**Important)\n            int output = guess(mid);                // Call the guess API\n            if (output == 0) {                      // If the mid element is equal to the target, return the mid\n                return mid;                         // Return the mid\n            }\n            else if (output == 1) {                 // If the mid element is less than the target, increment the left pointer\n                left = mid + 1;                     // Increment the left pointer\n            }\n            else {                                  // If the mid element is greater than the target, decrement the right pointer\n                right = mid - 1;                    // Decrement the right pointer\n            }\n        }\n\n        return -1;                                  // Should never be reached in a valid game\n    }\n}"
    },
    {
      "problemNumber": "0383",
      "title": "Ransom Note",
      "language": "C#",
      "filename": "0383-RansomNote.cs",
      "path": "LeetCode/C#/0383-RansomNote.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0383-RansomNote.cs",
      "approach": "Character Frequency Count with Hash Table",
      "tags": [
        "Hash Table",
        "String",
        "Counting"
      ],
      "steps": [
        "1) Create a dictionary to count character frequencies in magazine.",
        "2) Iterate through magazine and populate the frequency map.",
        "3) Iterate through ransomNote and check if each character is available.",
        "4) For each character in ransomNote, decrement its count in the dictionary.",
        "5) If any character is missing or count becomes 0, return false.",
        "6) If all characters are found with sufficient counts, return true."
      ],
      "timeComplexity": "O(m + n) where m = magazine.length, n = ransomNote.length",
      "spaceComplexity": "O(k) where k = number of unique characters in magazine",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/ransom-note/solutions/7404079/simplest-solution-c-time-om-n-spacek-ple-tbes/\nApproach: Character Frequency Count with Hash Table\nTags: Hash Table, String, Counting\n1) Create a dictionary to count character frequencies in magazine.\n2) Iterate through magazine and populate the frequency map.\n3) Iterate through ransomNote and check if each character is available.\n4) For each character in ransomNote, decrement its count in the dictionary.\n5) If any character is missing or count becomes 0, return false.\n6) If all characters are found with sufficient counts, return true.\n\nTime Complexity: O(m + n) where m = magazine.length, n = ransomNote.length\nSpace Complexity: O(k) where k = number of unique characters in magazine\n*/\npublic class Solution {\n    public bool CanConstruct(string ransomNote, string magazine) {\n        Dictionary<char,int> dict = new Dictionary<char,int>();     // Dictionary to store character frequencies\n        foreach (char c in magazine) {                              // Count characters in magazine\n            if (!dict.ContainsKey(c)) {                             // If character not in dictionary\n                dict.Add(c,1);                                      // Add character with count 1\n            }\n            else {                                                  // If character already exists\n                dict[c]++;                                          // Increment its count\n            }\n\n        }\n        foreach (char c in ransomNote) {                            // Check each character in ransomNote\n            if (!dict.ContainsKey(c) || dict[c] == 0) {             // If character unavailable or count is 0\n                return false;                                       // Cannot construct ransom note\n            }\n            else {                                                  // If character is available\n                dict[c]--;                                          // Use the character (decrement count)\n            }\n        }\n        return true;                                                // All characters found, can construct ransom note\n    }\n}"
    },
    {
      "problemNumber": "0387",
      "title": "First Unique Characters In String",
      "language": "C#",
      "filename": "0387-FirstUniqueCharactersInString.cs",
      "path": "LeetCode/C#/0387-FirstUniqueCharactersInString.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0387-FirstUniqueCharactersInString.cs",
      "approach": "1. Create a dictionary to store the count of each character in the string.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a dictionary to store the count of each character in the string.\n2. Iterate through the string and update the count of each character in the dictionary.\n3. Iterate through the string again and check if the count of the character is 1.\n4. If the count is 1, return the index of the character.\n5. If no such character is found, return -1.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\npublic class Solution {\n    public int FirstUniqChar(string s) {\n        Dictionary<char,int> dict = new Dictionary<char,int>();\n        int index = 0;\n\n        foreach(var c in s) {\n            if(!dict.ContainsKey(c)) {\n                dict.Add(c,1);\n            }\n            else {\n                dict[c] = dict[c] + 1;\n            }\n            index++;\n        }\n\n        index=0;\n\n        foreach(var c in s) {\n            if(dict.ContainsKey(c) && dict[c] == 1) {\n                return index;\n            }\n            index++;\n        }\n        return -1;\n    }\n}"
    },
    {
      "problemNumber": "0389",
      "title": "Findthe Difference",
      "language": "C#",
      "filename": "0389-FindtheDifference.cs",
      "path": "LeetCode/C#/0389-FindtheDifference.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0389-FindtheDifference.cs",
      "approach": "XOR",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/find-the-difference/solutions/6556260/simplest-solution-c-time-on-spacen-pleas-q11h/\nApproach: XOR\n1. Create a StringBuilder and append both strings to it.\n2. Initialize a char result to '\\0' which is a null character.\n3. Iterate through the StringBuilder and XOR each character with result.\n4. Return the result.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    public char FindTheDifference(string s, string t) {\n        StringBuilder sb = new StringBuilder(); // Initialize a StringBuilder\n        sb.Append(s);                           // Append both strings to StringBuilder\n        sb.Append(t);                           // Append both strings to StringBuilder\n        char result = '\\0';                     // Initialize a char result to '\\0' which is a null character\n        for(int i=0; i<sb.Length; i++) {        // Iterate through the StringBuilder\n            result ^= sb[i];                    // XOR each character with result\n        }\n        return result;                          // Return the result\n    }\n}"
    },
    {
      "problemNumber": "0392",
      "title": "Is Subsequence",
      "language": "C#",
      "filename": "0392-IsSubsequence.cs",
      "path": "LeetCode/C#/0392-IsSubsequence.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0392-IsSubsequence.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution\n{\n    public bool IsSubsequence(string s, string t)\n    {\n        int indexS = 0;\n        int indexT = 0;\n        while (indexS < s.Length && indexT < t.Length)\n        {\n\n            if (s[indexS] == t[indexT])\n            {\n                indexS++;\n            }\n            indexT++;\n        }\n\n        return s.Length == indexS ? true : false;\n    }\n}"
    },
    {
      "problemNumber": "0412",
      "title": "Fizz Buzz",
      "language": "C#",
      "filename": "0412-FizzBuzz.cs",
      "path": "LeetCode/C#/0412-FizzBuzz.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0412-FizzBuzz.cs",
      "approach": "Iteration with Modulo Operations",
      "tags": [
        "Array",
        "Math",
        "String Manipulation"
      ],
      "steps": [
        "1) Initialize a list to store results for numbers 1 to n.",
        "2) Iterate through each number from 1 to n.",
        "3) If divisible by both 3 and 5 (i.e., 15), add \"FizzBuzz\".",
        "4) If divisible by 3 only, add \"Fizz\".",
        "5) If divisible by 5 only, add \"Buzz\".",
        "6) Otherwise, add the number as a string."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/fizz-buzz/solutions/7175850/simplest-solution-c-time-on-spacen-pleas-rk09/\nApproach: Iteration with Modulo Operations\nTags: Array, Math, String Manipulation\n1) Initialize a list to store results for numbers 1 to n.\n2) Iterate through each number from 1 to n.\n3) If divisible by both 3 and 5 (i.e., 15), add \"FizzBuzz\".\n4) If divisible by 3 only, add \"Fizz\".\n5) If divisible by 5 only, add \"Buzz\".\n6) Otherwise, add the number as a string.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n*/\npublic class Solution {\n    public IList<string> FizzBuzz(int n) {\n        var result = new List<string>(n);                       // Initialize result list with capacity n\n\n        for (int i = 1; i <= n; i++) {                         // Iterate from 1 to n inclusive\n            if (i % 15 == 0) {                                 // If divisible by both 3 and 5\n                result.Add(\"FizzBuzz\");                         // Add \"FizzBuzz\"\n            } else if (i % 3 == 0) {                           // If divisible by 3 only\n                result.Add(\"Fizz\");                             // Add \"Fizz\"\n            } else if (i % 5 == 0) {                           // If divisible by 5 only\n                result.Add(\"Buzz\");                             // Add \"Buzz\"\n            } else {                                           // If not divisible by 3 or 5\n                result.Add(i.ToString());                       // Add number as string\n            }\n        }\n\n        return result;                                          // Return the FizzBuzz result list\n    }\n}\n"
    },
    {
      "problemNumber": "0424",
      "title": "Longest Repeating Character Replacement",
      "language": "C#",
      "filename": "0424-LongestRepeatingCharacterReplacement.cs",
      "path": "LeetCode/C#/0424-LongestRepeatingCharacterReplacement.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0424-LongestRepeatingCharacterReplacement.cs",
      "approach": "Sliding Window",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1) - since we only store 26 characters in the dictionary",
      "solutionLink": "",
      "code": "/*\nVideos: https://www.youtube.com/watch?v=ExY8svHF_Eo\nSolution: https://leetcode.com/problems/longest-repeating-character-replacement/solutions/6973917/simplest-solution-c-time-on-space1-pleas-ye56/\nTags: Sliding-Window, Hash-Table\nApproach: Sliding Window\n1. Initialize a dictionary to count character frequencies.\n2. Use two pointers to maintain the window.\n3. Expand the right pointer and update the frequency count.\n4. If the window size minus the maximum frequency is greater than k, shrink the left pointer.\n5. Update the maximum length of the substring found.\n\nTime complexity: O(n)\nSpace complexity: O(1) - since we only store 26 characters in the dictionary\n\n*/\npublic class Solution {\n    public int CharacterReplacement(string s, int k) {\n        int[] freq = new int[26];                                                   // Frequency array for characters A-Z\n        int left = 0;                                                               // Left pointer for the sliding window\n        int maxWindowLength = 0;                                                    // Maximum length of the substring found\n        int maxFreq = 0;                                                            // Maximum frequency of any character in the current window\n        int currWindowLength = 0;                                                   // Current length of the sliding window\n\n        for (int right = 0; right<s.Length; right++) {                              // Iterate through the string with the right pointer\n\n            freq[s[right] - 65]++;                                                  // Increment the frequency of the current character\n            maxFreq = Math.Max(maxFreq, freq[s[right] - 65]);                       // Update the maximum frequency in the current window\n            currWindowLength = right - left + 1;                                    // Update the current window length\n            if ( (currWindowLength - maxFreq) > k) {                                // If the number of characters that need to be replaced exceeds k\n                freq[s[left] - 65]--;                                               // Decrease the frequency of the character at the left pointer\n                left++;                                                             // Move the left pointer to shrink the window\n            }\n            currWindowLength = right - left + 1;                                    // Update the current window length after adjusting the left pointer\n            maxWindowLength = Math.Max(maxWindowLength, currWindowLength);          // Update the maximum window length found\n        }\n\n        return maxWindowLength;                                                     // Return the maximum length of the substring found\n    }\n}"
    },
    {
      "problemNumber": "0448",
      "title": "Find All Numbers Disappeared In Array",
      "language": "C#",
      "filename": "0448-FindAllNumbersDisappearedInArray.cs",
      "path": "LeetCode/C#/0448-FindAllNumbersDisappearedInArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0448-FindAllNumbersDisappearedInArray.cs",
      "approach": "1. Create a new array of size n and fill it with 1 to n.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a new array of size n and fill it with 1 to n.\n2. Traverse the given array and mark the index of the element as -1 in the new array.\n3. Traverse the new array and add the index of the element which is not marked as -1 to the result list.\n4. Return the result list.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n\n*/\npublic class Solution {\n    public IList<int> FindDisappearedNumbers(int[] nums) {\n            int[] check = new int[nums.Length];\n            IList<int> result = new List<int>();\n            int i=0;\n\n            while(i < nums.Length) {\n                check[i] = i+1;\n                i++;\n            }\n\n            i=0;\n            while(i < nums.Length) {\n                check[nums[i] - 1] = -1;\n                i++;\n            }\n\n            i=0;\n            while(i < check.Length) {\n                if (check[i] != -1) {\n                    result.Add(check[i]);\n                }\n                i++;\n            }\n\n            return result;\n    }\n}"
    },
    {
      "problemNumber": "0455",
      "title": "Assign Cookies",
      "language": "C#",
      "filename": "0455-AssignCookies.cs",
      "path": "LeetCode/C#/0455-AssignCookies.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0455-AssignCookies.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(nlogn)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nSolution:\n1. We need to find the number of content children.\n2. We have to assign cookies to children such that each child gets at most one cookie.\n3. We need to find the maximum number of content children.\n4. We can sort the children and cookies in ascending order.\n5. Then, we can iterate through the children and cookies.\n\nTime Complexity: O(nlogn)\nSpace Complexity: O(1)\n\n*/\n\npublic class Solution {\n    public int FindContentChildren(int[] g, int[] s) {\n        Array.Sort(g);                                  // Sort the children\n        Array.Sort(s);                                  // Sort the cookies\n        int i, j;                                       // Initialize two pointers\n        i = j = 0;                                      // Initialize the pointers to 0\n        while(j < s.Length && i < g.Length) {           // Iterate through the children and cookies\n            if(s[j] >= g[i]) {                          // If the cookie is greater than or equal to the greed factor of the child\n                i++;                                    // Move to the next child\n            }\n            j++;                                        // Move to the next cookie\n        }\n        return i;                                       // Return the number of content children\n    }\n}"
    },
    {
      "problemNumber": "0463",
      "title": "Island Perimeter",
      "language": "C#",
      "filename": "0463-IslandPerimeter.cs",
      "path": "LeetCode/C#/0463-IslandPerimeter.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0463-IslandPerimeter.cs",
      "approach": "DFS",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(rows*columns)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: DFS\n1. Start from the first cell of the grid.\n2. If the cell is 1, call the DFS function.\n3. In the DFS function, check if the cell is out of bounds or the cell is water.\n4. If the cell is out of bounds or the cell is water, increment the perimeter.\n5. If the cell is already visited, return.\n6. Mark the cell as visited.\n7. Call the DFS function recursively with the adjacent cells.\n8. Return the perimeter.\nTime Complexity: O(rows*columns)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    int perimiter = 0;                                                                  // Variable to store the perimeter.\n    int rows = 0;                                                                       // Variable to store the number of rows.\n    int columns = 0;                                                                    // Variable to store the number of columns.\n    public int IslandPerimeter(int[][] grid) {                                          // Function to find the perimeter of the island.\n        rows = grid.Length;                                                             // Get the number of rows.\n        columns = grid[0].Length;                                                       // Get the number of columns.\n\n        for(int i=0; i<rows; i++) {                                                     // Iterate through the grid.\n            for(int j=0; j<columns; j++) {                                              // Iterate through the grid.\n                if(grid[i][j] == 1) {                                                   // If the cell is 1, call the DFS function.\n                    DFS(grid, i, j);                                                    // Call the DFS function.\n                    return perimiter;                                                   // Return the perimeter.\n                }\n            }\n        }\n        return 0;                                                                       // Return 0 if the island is not found.\n    }\n\n    public void DFS(int[][] grid, int i, int j) {\n\n        if(i >=rows || i < 0 || j >= columns || j < 0 || grid[i][j] == 0) {             // If the cell is out of bounds or the cell is water, increment the perimeter.\n            perimiter++;                                                                // Increment the perimeter.\n            return;                                                                     // Return.\n        }\n\n        if(grid[i][j] == -1) {                                                          // If the cell is already visited, return.\n            return;                                                                     // Return.\n        }\n\n        grid[i][j] = -1;                                                                // Mark the cell as visited.\n\n        DFS(grid,i+1,j);                                                                // Call the DFS function recursively with the adjacent cells.\n        DFS(grid,i-1,j);                                                                // Call the DFS function recursively with the adjacent cells.\n        DFS(grid,i,j+1);                                                                // Call the DFS function recursively with the adjacent cells.\n        DFS(grid,i,j-1);                                                                // Call the DFS function recursively with the adjacent cells.\n    }\n }\n /*\n Approach: BFS\n TODO\n */"
    },
    {
      "problemNumber": "0496",
      "title": "Next Greater Element I",
      "language": "C#",
      "filename": "0496-NextGreaterElementI.cs",
      "path": "LeetCode/C#/0496-NextGreaterElementI.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0496-NextGreaterElementI.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Approach 1 : Using Stack and Dictionary\n// Time Complexity : O(n)\n// Space Complexity : O(n)\n\n\npublic class Solution {\n    public int[] NextGreaterElement(int[] nums1, int[] nums2) {\n        Dictionary<int, int> dict = new Dictionary<int, int>();\n        Stack<int> stack = new Stack<int>();\n        int[] result = new int[nums1.Length];\n        for(int i = 0; i < nums2.Length; i++) {\n            while(stack.Count > 0 && nums2[i] > stack.Peek()) {\n                dict.Add(stack.Pop(), nums2[i]);\n            }\n            stack.Push(nums2[i]);\n        }\n\n        return nums1.Select(x => dict.ContainsKey(x) ? dict[x] : -1).ToArray();\n\n    }\n}"
    },
    {
      "problemNumber": "0506",
      "title": "Relative- Ranks",
      "language": "C#",
      "filename": "0506-Relative-Ranks.cs",
      "path": "LeetCode/C#/0506-Relative-Ranks.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0506-Relative-Ranks.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public string[] FindRelativeRanks(int[] score) {\n    \n        string[] output = new string[score.Length];\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>(Comparer<int>.Create((x,y)=>score[y]-score[x]));\n        for(int i=0;i<score.Length;i++)\n            pq.Enqueue(i,i);\n        \n        if(pq.Count !=0) output[pq.Dequeue()] = \"Gold Medal\";\n        if(pq.Count !=0) output[pq.Dequeue()] = \"Silver Medal\";\n        if(pq.Count !=0) output[pq.Dequeue()] = \"Bronze Medal\";\n\n        int place = 4;\n\n        while(pq.Count > 0){\n            output[pq.Dequeue()] = place.ToString();\n            place++;\n        }\n\n        return output;\n    }\n}"
    },
    {
      "problemNumber": "0507",
      "title": "Perfect Number",
      "language": "C#",
      "filename": "0507-PerfectNumber.cs",
      "path": "LeetCode/C#/0507-PerfectNumber.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0507-PerfectNumber.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public bool CheckPerfectNumber(int num) {\n        if(num%2!=0)\n            return false;\n        int sum = 0;\n        for( int i=1 ; i<=num/2; i++ ) {\n            if(num%i==0)\n                sum=sum+i;\n        }\n        return sum==num ? true: false; \n    }\n}"
    },
    {
      "problemNumber": "0509",
      "title": "Fibonacci Number",
      "language": "C#",
      "filename": "0509-FibonacciNumber.cs",
      "path": "LeetCode/C#/0509-FibonacciNumber.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0509-FibonacciNumber.cs",
      "approach": "",
      "tags": [],
      "steps": [
        "1) Initialize an array memo of size n+1 to store the Fibonacci numbers.",
        "2) Return memo[n] if this value has been computed before.",
        "3) If not, use recursion to calculate the value, add it to memo, and return it.",
        "4) The recursion uses memo to store and reuse the previously computed values to reduce the number of recursive calls.",
        "5) The recursion has a time complexity of O(n) since each number, starting at 2 up to n, is computed once."
      ],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    int[]  fib = new int[31];\n    public int Fib(int n) {\n\n        fib[0] = 0;\n        fib[1] = 1;\n        int i  = 0;\n\n        for( i=2 ; i<=n; i++ ) {\n            fib[i] = fib[i-1] + fib[i-2];\n        }\n        return fib[n];\n    }\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n///Approach 2: Recursion without Memoization\n//////////////////////////////////////////////////////////////////////////////////////////////////////\npublic class Solution {\n    public int Fib(int n) {\n        if (n == 0)\n            return 0;\n        if (n == 1)\n            return 1;\n        return Fib(n-1) + Fib(n-2);\n    }\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n///Approach 3: Recursion with Memoization\n/*\n1) Initialize an array memo of size n+1 to store the Fibonacci numbers.\n2) Return memo[n] if this value has been computed before.\n3) If not, use recursion to calculate the value, add it to memo, and return it.\n4) The recursion uses memo to store and reuse the previously computed values to reduce the number of recursive calls.\n5) The recursion has a time complexity of O(n) since each number, starting at 2 up to n, is computed once.\nSpace complexity is O(n) as well due to the usage of the memo array.\n*/\n//////////////////////////////////////////////////////////////////////////////////////////////////////\npublic class Solution {\n\n    public int Fib(int n) {\n        if (n == 0)                             // base case\n            return 0;                           // base case\n        if (n == 1)                             // base case\n            return 1;                           // base case\n        int[] dp = new int[31];                 // dp array to store the values\n        for (int i=0; i<dp.Length;i++) {        // initialize the dp array with -1\n            dp[i] = -1;                         // initialize the dp array with -1\n        }\n        return Solve(n-1,dp) + Solve(n-2,dp);   // call the recursive function\n    }\n    public int Solve(int n, int[] dp) {         // recursive function\n        if (n == 0)                             // base case\n            return 0;                           // base case\n        if (n == 1)                             // base case\n            return 1;                           // base case\n        if(dp[n] != -1) {                       // if the value is already calculated\n            return dp[n];                       // return the value\n        }\n        return Solve(n-1,dp) + Solve(n-2,dp);   // recursive call\n    }\n}"
    },
    {
      "problemNumber": "0535",
      "title": "Encodeand Decode Tiny U R L",
      "language": "C#",
      "filename": "0535-EncodeandDecodeTinyURL.cs",
      "path": "LeetCode/C#/0535-EncodeandDecodeTinyURL.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0535-EncodeandDecodeTinyURL.cs",
      "approach": "1. Create a dictionary to store the longUrl and the corresponding shortUrl.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a dictionary to store the longUrl and the corresponding shortUrl.\n2. Create a variable to store the base address.\n3. If the longUrl is not present in the dictionary, then add it to the dictionary.\n4. Return the base address concatenated with the shortUrl.\n5. To decode, extract the shortUrl from the input.\n6. Extract the number from the shortUrl.\n7. Iterate through the dictionary and find the longUrl corresponding to the number.\n8. Return the longUrl.\n\nTime complexity: O(1)\nSpace complexity: O(n)\n\n*/\npublic class Codec {\n    Dictionary<string,int> dict  = new Dictionary<string,int>();\n    string baseAddress = \"http://tinyurl.com/\";\n\n    // Encodes a URL to a shortened URL\n    public string encode(string longUrl) {\n       if(!dict.ContainsKey(longUrl)) {\n        int surl = dict.Count()+1;\n        dict.Add(longUrl,surl);\n       }\n       return baseAddress + dict[longUrl].ToString();\n    }\n\n    // Decodes a shortened URL to its original URL.\n    public string decode(string shortUrl) {\n\n        int surl = Convert.ToInt16(shortUrl.Split(\".com/\")[1]);\n        string longUrl = string.Empty;\n        foreach(var kv in dict) {\n            if(kv.Value == surl)\n                longUrl = kv.Key;\n        }\n        return longUrl;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(url));"
    },
    {
      "problemNumber": "0547",
      "title": "Numberof Provinces",
      "language": "C#",
      "filename": "0547-NumberofProvinces.cs",
      "path": "LeetCode/C#/0547-NumberofProvinces.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0547-NumberofProvinces.cs",
      "approach": "Depth First Search",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/number-of-provinces/solutions/6566544/simplest-solution-c-time-onn-spacen-plea-d53p/\nApproach: Depth First Search\n1. Create a list of visited nodes and initialize all nodes as not visited.\n2. For each node, if it is not visited, call DFS and increment the number of provinces.\n3. In DFS, mark the current node as visited and for all the nodes that are not visited and are connected to the current node, call DFS.\n4. Return the number of provinces.\n\nTime complexity: O(n^2)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    List<bool> visited = new List<bool>();                                              // List to store visited nodes\n    public int FindCircleNum(int[][] isConnected) {                                     // Function to find the number of provinces\n        int numOfProvinces = 0;                                                         // Variable to store the number of provinces\n        for (int node=0; node<isConnected.Length; node++) {                             // Initialize all nodes as not visited\n            visited.Add(false);                                                         // Add false to the list\n        }\n        for(int node=0; node<visited.Count; node++) {                                   // For each node, if it is not visited, call DFS and increment the number of provinces\n            if (!visited[node]) {                                                       // If the node is not visited\n                DFS(isConnected, visited, node);                                        // Call DFS\n                numOfProvinces++;                                                       // Increment the number of provinces\n            }\n        }\n        return numOfProvinces;                                                          // Return the number of provinces\n    }\n\n    public void DFS(int[][] isConnected, List<bool> visited, int currentNode) {         // Function to perform Depth First Search\n        visited[currentNode] = true;                                                    // Mark the current node as visited\n        for(int node=0; node<visited.Count; node++) {                                   // For all the nodes that are not visited and are connected to the current node, call DFS\n            if (!visited[node] && isConnected[currentNode][node] == 1) {                // If the node is not visited and is connected to the current node\n                DFS(isConnected, visited, node);                                        // Call DFS\n            }\n        }\n    }\n}\n\n/*\nApproach: BFS\nTODO\n*/"
    },
    {
      "problemNumber": "0554",
      "title": "Brick Wall",
      "language": "C#",
      "filename": "0554-BrickWall.cs",
      "path": "LeetCode/C#/0554-BrickWall.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0554-BrickWall.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n) where n is the number of bricks in the wall.",
      "spaceComplexity": "O(n) where n is the number of bricks in the wall.",
      "solutionLink": "",
      "code": "/*\n\nSolution:\n1. We need to find the least number of bricks that can be cut to make a straight line.\n2. We need to find the maximum number of bricks that can be cut at the same place.\n3. We can ignore the last brick as we cannot cut it.\n4. We can use a dictionary to store the number of bricks that can be cut at a particular place.\n5. We can iterate through the wall and calculate the current cut.\n6. We can store the current cut in the dictionary.\n7. We can find the maximum number of bricks that can be cut at the same place.\n8. We can return the least number of bricks that can be cut to make a straight line.\n\nTime Complexity: O(n) where n is the number of bricks in the wall.\nSpace Complexity: O(n) where n is the number of bricks in the wall.\n\n*/\n\npublic class Solution {\n    public int LeastBricks(IList<IList<int>> wall) {\n        int currentCut = 0;\n        int maxCut = 0;\n        Dictionary<int,int> dict = new Dictionary<int,int>();\n        int i=0;\n        foreach(var w in wall) {\n            int j=0;\n            currentCut = 0;\n            foreach(var brick in w) {\n                if(j == w.Count()-1) break;                     // If this is the last brick ignore\n                currentCut = currentCut + wall[i][j];\n                if(!dict.ContainsKey(currentCut)) {\n                    dict[currentCut] = 1;\n                }\n                else {\n                    dict[currentCut] = dict[currentCut] + 1;\n                }\n                j++;\n            }\n            i++;\n        }\n\n        foreach(var kv in dict) {\n            maxCut = Math.Max(maxCut,kv.Value);\n        }\n        return i - maxCut;\n    }\n}"
    },
    {
      "problemNumber": "0557",
      "title": "Reverse Wordsina String I I I",
      "language": "C#",
      "filename": "0557-ReverseWordsinaStringIII.cs",
      "path": "LeetCode/C#/0557-ReverseWordsinaStringIII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0557-ReverseWordsinaStringIII.cs",
      "approach": "1. Use two pointers i and j to iterate through the string.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Use two pointers i and j to iterate through the string.\n2. Initialize i and j to 0.\n3. Iterate through the string until j is less than the length of the string.\n4. Find the word and reverse it.\n5. Move i and j to the next word.\n6. Return the reversed string.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n\n*/\n\npublic class Solution\n{\n    public string ReverseWords(string s)\n    {\n        int i, j, sp;                                                             // Initialize two pointers i and j and a variable sp to store the space\n        char t = '\\0';                                                            // Initialize a temporary variable t\n        StringBuilder sb = new StringBuilder(s, s.Length);                        // Initialize a string builder with the input string\n        i = j = sp = 0;                                                           // Initialize i, j and sp to 0\n\n        while (j < sb.Length && i < sb.Length)\n        {                                                                         // Iterate through the string\n\n            while (j < sb.Length && sb[j] != ' ')\n            {                                                                     // Find the word\n                j++;                                                              // Move j to the next character\n            }\n            sp = j;                                                               // Store the space\n            j--;                                                                  // Move j to the last character of the word\n            while (i < j && i < sb.Length && j > 0)\n            {                                                                     // Reverse the word\n                t = sb[i];                                                        // Swap the characters\n                sb[i] = sb[j];                                                    // Swap the characters\n                sb[j] = t;                                                        // Swap the characters\n                i++;                                                              // Move i to the next character\n                j--;                                                              // Move j to the previous character\n            }\n            i = sp + 1;                                                           // Move i to the next word\n            j = sp + 1;                                                           // Move j to the next word\n\n        }\n        return sb.ToString();                                                     // Return the reversed string\n    }\n}"
    },
    {
      "problemNumber": "0572",
      "title": "Subtreeof Another Tree",
      "language": "C#",
      "filename": "0572-SubtreeofAnotherTree.cs",
      "path": "LeetCode/C#/0572-SubtreeofAnotherTree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0572-SubtreeofAnotherTree.cs",
      "approach": "Recursion",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n*m), where n is the number of nodes in the root tree and m is the number of nodes in the subRoot tree.",
      "spaceComplexity": "O(n), where n is the number of nodes in the root tree. The space complexity is O(n) because the maximum depth of the recursion is the height of the tree, which is O(n) in the worst case and O(logn) in the best case.",
      "solutionLink": "",
      "code": "/*\nApproach: Recursion\n1. If the subRoot is null, then return true.\n2. If the root is null, then return false.\n3. If the root and subRoot are same, then return true.\n4. Else, check for left and right subtrees.\n5. If any of the above conditions are met, then return true.\n6. Else, return false.\n\nTime complexity: O(n*m), where n is the number of nodes in the root tree and m is the number of nodes in the subRoot tree.\nSpace complexity: O(n), where n is the number of nodes in the root tree. The space complexity is O(n) because the maximum depth of the recursion is the height of the tree, which is O(n) in the worst case and O(logn) in the best case.\n\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSubtree(TreeNode root, TreeNode subRoot) {\n        if (subRoot == null) {                                                                          // if subRoot is null, then return true.\n            return true;                                                                                // return true.\n        }\n        if (root == null) {                                                                             // if root is null, then return false.\n            return false;                                                                               // return false.\n        }\n        if (IsSametree(root, subRoot)) {                                                                // if root and subRoot are same, then return true.\n            return true;                                                                                // return true.\n        }\n        return IsSubtree(root.left, subRoot) || IsSubtree(root.right, subRoot);                         // check for left and right subtrees.\n    }\n\n    public static bool IsSametree(TreeNode root, TreeNode subRoot) {                                    // Helper function to check if the trees are same.\n        if (root == null && subRoot == null) {                                                          // If both the nodes are null, then they are same, so return true.\n            return true;                                                                                // Return true.\n        }\n        if (root != null && subRoot != null && root.val == subRoot.val) {                               // If both the nodes are not null and their values are same, then check for left and right subtrees.\n                return IsSametree(root.left, subRoot.left) && IsSametree(root.right, subRoot.right);    // Check for left and right subtrees.\n            }\n        else {\n            return false;                                                                               // If any of the above conditions are not met, then return false.\n        }\n    }\n}\n"
    },
    {
      "problemNumber": "0575",
      "title": "Distribute Candies",
      "language": "C#",
      "filename": "0575-DistributeCandies.cs",
      "path": "LeetCode/C#/0575-DistributeCandies.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0575-DistributeCandies.cs",
      "approach": "Hash Table (Dictionary) + Greedy",
      "tags": [
        "Hash Table",
        "Greedy",
        "Array"
      ],
      "steps": [
        "1) Create a dictionary to count unique candy types.",
        "2) Iterate through candyType array and populate the frequency map.",
        "3) Alice can eat at most n/2 candies (where n is total candies).",
        "4) To maximize variety, return min(unique types, n/2).",
        "5) If unique types >= n/2, she can get n/2 different types.",
        "6) If unique types < n/2, she can only get all available unique types."
      ],
      "timeComplexity": "O(n) - single pass through the array",
      "spaceComplexity": "O(n) - dictionary stores up to n unique types",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/distribute-candies/solutions/7404538/simplest-solution-c-time-on-spacen-pleas-r1os/\nApproach: Hash Table (Dictionary) + Greedy\nTags: Hash Table, Greedy, Array\n1) Create a dictionary to count unique candy types.\n2) Iterate through candyType array and populate the frequency map.\n3) Alice can eat at most n/2 candies (where n is total candies).\n4) To maximize variety, return min(unique types, n/2).\n5) If unique types >= n/2, she can get n/2 different types.\n6) If unique types < n/2, she can only get all available unique types.\n\nTime Complexity: O(n) - single pass through the array\nSpace Complexity: O(n) - dictionary stores up to n unique types\n*/\npublic class Solution {\n    public int DistributeCandies(int[] candyType) {\n        Dictionary<int,int> dict = new Dictionary<int,int>();       // Dictionary to store candy types and their counts\n        foreach (int num in candyType) {                            // Count each candy type\n            if (!dict.ContainsKey(num)) {                           // Add new candy type to dictionary\n                dict[num] = 1;                                      // Initialize count to 1\n            }\n            else {                                                  // Increment count for existing candy type\n                dict[num]++;                                        // Increase frequency\n            }\n        }\n        // Alice can eat n/2 candies, so return minimum of n/2 or unique types\n        // This maximizes variety - if there are more unique types than n/2,\n        // she can get n/2 different types; otherwise she gets all unique types\n        return Math.Min(candyType.Length / 2, dict.Keys.Count);     // Return maximum variety Alice can achieve\n    }\n}"
    },
    {
      "problemNumber": "0577",
      "title": "Employee Bonus",
      "language": "SQL",
      "filename": "0577-EmployeeBonus.sql",
      "path": "LeetCode/SQL/0577-EmployeeBonus.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/0577-EmployeeBonus.sql",
      "approach": "Left Join",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "-- Approach: Left Join\n-- 1. We need to find the employee name and bonus from the employee and bonus tables.\n-- 2. We can achieve this by left joining the employee table with the bonus table on empId.\n-- 3. We need to select the employee name and bonus where bonus is less than 1000 or bonus is null.\n-- 4. Return the employee name and bonus.\n\nselect e.name, b.bonus from employee as e\nleft join bonus as b\non e.empId = b.empId\nwhere b.Bonus < 1000 or b.Bonus is Null"
    },
    {
      "problemNumber": "0584",
      "title": "Find Customer Referee",
      "language": "SQL",
      "filename": "0584-FindCustomerReferee.sql",
      "path": "LeetCode/SQL/0584-FindCustomerReferee.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/0584-FindCustomerReferee.sql",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/*\nhttps://leetcode.com/problems/find-customer-referee/solutions/6189169/simplest-solution-sql-please-upvote-by-v-3s7j/\n\nThis query retrieves the name of customers from the customer table where the referee_id is either not equal to 2 or is null.\n\nselect name from customer: This part specifies that we want to select the name column from the customer table.\nwhere referee_id != 2: This condition filters out customers whose referee_id is 2.\nor referee_id is null: This condition includes customers whose referee_id is null.\nCombining these conditions with or means that the query will return the names of customers who either do not have a referee_id of 2 or do not have a referee_id at all (i.e., it is null).\n*/\nselect name from customer where referee_id != 2 or referee_id is null"
    },
    {
      "problemNumber": "0595",
      "title": "Big Countries",
      "language": "SQL",
      "filename": "0595-BigCountries.sql",
      "path": "LeetCode/SQL/0595-BigCountries.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/0595-BigCountries.sql",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Select name, population, area from world where area >= 3000000 or population >=25000000\n*/\n\nselect name, population, area from world where area >= 3000000 or population >=25000000 "
    },
    {
      "problemNumber": "0605",
      "title": "Can Place Flowers",
      "language": "C#",
      "filename": "0605-CanPlaceFlowers.cs",
      "path": "LeetCode/C#/0605-CanPlaceFlowers.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0605-CanPlaceFlowers.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Problem: Can Place Flowers\n// Source: https://leetcode.com/problems/can-place-flowers/\n// Approach 1: Greedy\n// Time complexity : O(n). We traverse the entire flowerbed once.\n// Space complexity : O(1). Constant extra space is used.\n// If the current position is empty, and the next position is empty, and the previous position is empty, then we can plant a flower at the current position.\n\npublic class Solution {\n    public bool CanPlaceFlowers(int[] flowerbed, int n) {\n        int numberOfPlantedFlowers = 0;\n        if(flowerbed.Length == 1 && flowerbed[0]==0) return true;\n        for(int i=0; i<flowerbed.Length; i++) {\n            if(i == 0) //[0,0,1]\n            {\n                if (flowerbed[i]==0 && flowerbed[i+1]==0)\n                {\n                    numberOfPlantedFlowers++;\n                    flower  bed[i]=1;\n                    Console.WriteLine(i);\n                }\n            }\n            else if(i == flowerbed.Length-1) //[1,0,0]\n            {\n               if (flowerbed[i]==0 && flowerbed[i-1]==0)\n                {\n                    numberOfPlantedFlowers++;\n                    flowerbed[i]=1;\n                    Console.WriteLine(i);\n                }\n            }\n            else\n            {\n                 if (flowerbed[i]==0 && flowerbed[i-1]==0 && flowerbed[i+1]==0) // [0,0,0]\n                {\n                    numberOfPlantedFlowers++;\n                    flowerbed[i]=1;\n                    Console.WriteLine(i);\n                }\n            }\n        }\n        return numberOfPlantedFlowers >= n ? true: false;\n    }\n}"
    },
    {
      "problemNumber": "0620",
      "title": "Not Boring Movies",
      "language": "SQL",
      "filename": "0620-NotBoringMovies.sql",
      "path": "LeetCode/SQL/0620-NotBoringMovies.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/0620-NotBoringMovies.sql",
      "approach": "Select the movies which are not boring and have odd id",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "-- Approach: Select the movies which are not boring and have odd id\n-- 1. We need to select the id, movie, description, and rating from the cinema table.\n-- 2. We need to select the movies which are not boring and have an odd id.\n-- 3. We need to order the result by rating in descending order.\n-- 4. Return the id, movie, description, and rating.\nselect id, movie, description, rating\nfrom cinema\nwhere description != 'boring' and id % 2 != 0\norder by rating desc;"
    },
    {
      "problemNumber": "0645",
      "title": "Set Mismatch",
      "language": "C#",
      "filename": "0645-SetMismatch.cs",
      "path": "LeetCode/C#/0645-SetMismatch.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0645-SetMismatch.cs",
      "approach": "1. Create a hashset to store the unique numbers.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a hashset to store the unique numbers.\n2. Initialize the current sum, first duplicate number, and missing number.\n3. Iterate through the numbers array and for each number, check if it is already present in the hashset.\n4. If it is present, update the first duplicate number.\n5. If it is not present, add the number to the hashset and update the current sum.\n6. Calculate the missing number using the formula (n*(n+1)/2) - current sum.\n7. Return the first duplicate number and the missing number.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int[] FindErrorNums(int[] nums) {\n\n        HashSet<int> set = new HashSet<int>();\n        int currentSum = 0;\n        int firstDupNum = -1;\n        int missingNum = -1;\n\n        foreach(int num in nums) {\n            if(set.Contains(num)) {\n                firstDupNum = num;\n            }\n            else {\n                set.Add(num);\n                currentSum = currentSum + num;\n            }\n        }\n\n        missingNum = ( nums.Length*(nums.Length + 1) / 2 ) - currentSum;\n\n        return [firstDupNum,missingNum];\n\n    }\n}"
    },
    {
      "problemNumber": "0680",
      "title": "Valid Palindrome I I",
      "language": "C#",
      "filename": "0680-ValidPalindromeII.cs",
      "path": "LeetCode/C#/0680-ValidPalindromeII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0680-ValidPalindromeII.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public bool ValidPalindrome(string s) {\n       \n        int chance = 0; // try to remove this variable\n        int i=0;\n        int j= s.Length - 1;\n\n        while(i<=j) {\n\n            if(s[i] != s[j] && chance == 1) {\n                return false;\n            }\n            else if(s[i] != s[j] && chance == 0) {\n                chance++;\n                return IsPalendrome(s,i+1,j) || IsPalendrome(s,i,j-1) ;\n            }      \n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    private bool IsPalendrome(string s, int i, int j) {\n        while(i<=j) {\n            if(s[i]!=s[j]) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n"
    },
    {
      "problemNumber": "0682",
      "title": "Baseball Game",
      "language": "C#",
      "filename": "0682-BaseballGame.cs",
      "path": "LeetCode/C#/0682-BaseballGame.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0682-BaseballGame.cs",
      "approach": "1. Create a stack to store the scores.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a stack to store the scores.\n2. Iterate through the operations array.\n3. If the current operation is \"C\", pop the last score from the stack.\n4. If the current operation is \"D\", double the last score and push it to the stack.\n5. If the current operation is \"+\", add the sum of the last two scores and push it to the stack.\n6. If the current operation is a number, push it to the stack.\n7. After iterating through all the operations, pop all the scores from the stack and calculate the sum.\n8. Return the sum.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int CalPoints(string[] operations) {\n        Stack<int> stack = new Stack<int>();                // To store the scores\n        int sum = 0;                                        // To store the sum of all the scores\n\n        foreach(string ch in operations) {                  // Iterating through the operations array\n            switch(ch) {\n                case \"C\":                                   // If the current operation is \"C\"\n                    if(stack.Count() == 0) break;           // If the stack is empty, do nothing\n                    stack.Pop();                            // Pop the last score from the stack\n                    break;                                  // Break from the switch case\n\n                case \"D\":                                   // If the current operation is \"D\"\n                    if(stack.Count() == 0) break;           // If the stack is empty, do nothing\n                    int peeked = stack.Peek();              // Peek the last score from the stack\n                    peeked*=2;                              // Double the last score\n                    stack.Push(peeked);                     // Push the doubled score to the stack\n                    break;                                  // Break from the switch case\n\n                case \"+\":                                   // If the current operation is \"+\"\n                    if(stack.Count() == 0) break;           // If the stack is empty, do nothing\n                    int poped = stack.Pop();                // Pop the last score from the stack\n                    peeked = stack.Peek();                  // Peek the second last score from the stack\n                    stack.Push(poped);                      // Push the last score back to the stack\n                    stack.Push(poped+peeked);               // Push the sum of the last two scores to the stack\n                    break;                                  // Break from the switch case\n\n                default:                                    // If the current operation is a number\n                    stack.Push(Int32.Parse(ch));            // Push the number to the stack\n                    break;                                  // Break from the switch case\n            }\n        }\n        while(stack.Count() != 0) {                         // Pop all the scores from the stack and calculate the sum\n            int num = stack.Pop();                          // Pop the score from the stack\n            sum=sum+num;                                    // Add the score to the sum\n        }\n        return sum;                                         // Return the sum\n    }\n}"
    },
    {
      "problemNumber": "0695",
      "title": "Max Areaof Island",
      "language": "C#",
      "filename": "0695-MaxAreaofIsland.cs",
      "path": "LeetCode/C#/0695-MaxAreaofIsland.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0695-MaxAreaofIsland.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(rows*columns)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach : DFS\n1. Start from the first cell of the grid.\n2. If the cell is 1, call the DFS function.\n3. In the DFS function, check if the cell is out of bounds or the cell is water.\n4. If the cell is out of bounds or the cell is water, return.\n5. Mark the cell as visited.\n6. Call the DFS function recursively with the adjacent cells.\n7. Increment the area.\n8. Return the area.\n\nTime Complexity: O(rows*columns)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    int rows = 0;                                                               // Variable to store the number of rows.\n    int columns = 0;                                                            // Variable to store the number of columns.\n    int maxArea = 0;                                                            // Variable to store the maximum area.\n    public int MaxAreaOfIsland(int[][] grid) {                                  // Function to find the maximum area of the island.\n\n        rows = grid.Length;                                                     // Get the number of rows.\n        columns = grid[0].Length;                                               // Get the number of columns.\n\n        for (int i=0; i<rows; i++) {                                            // Iterate through the grid.\n            for (int j=0; j<columns; j++) {                                     // Iterate through the grid.\n                if (grid[i][j]==1) {                                            // If the cell is 1, call the DFS function.\n                    maxArea = Math.Max(DFS(grid, i, j), maxArea);               // Call the DFS function and get the maximum area.\n                }\n            }\n        }\n        return maxArea;                                                         // Return the maximum area.\n    }\n\n    public int DFS(int[][] grid, int i, int j) {                                // Function to perform Depth First Search.\n        if (i<0 || i >=rows || j<0 || j>=columns || grid[i][j] != 1) {          // If the cell is out of bounds or the cell is water, return.\n            return 0;                                                           // If the cell is out of bounds or the cell is water, return.\n        }\n\n        grid[i][j] = -1;                                                        // Mark the cell as visited.\n\n        return 1 + DFS(grid, i+1, j) +                                          // Call the DFS function recursively with the adjacent cells.\n                    DFS(grid, i-1, j) +\n                    DFS(grid, i, j+1) +\n                    DFS(grid, i, j-1);\n    }\n}\n/*\nApproach: BFS\nTODO\n*/"
    },
    {
      "problemNumber": "0703",
      "title": "Kth Largest Number In Stream",
      "language": "C#",
      "filename": "0703-KthLargestNumberInStream.cs",
      "path": "LeetCode/C#/0703-KthLargestNumberInStream.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0703-KthLargestNumberInStream.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class KthLargest {\n\n    private PriorityQueue<int,int> pq = new PriorityQueue<int,int>();\n    private int kth {get;set;}\n    public KthLargest(int k, int[] nums) {\n        kth= k;\n        foreach (int num in nums) {\n            pq.Enqueue(num,num);\n        }\n        while (pq.Count > kth) {\n            pq.Dequeue();\n        }\n    }\n    public int Add(int val) {\n        pq.Enqueue(val,val);\n        if (pq.Count > kth) {\n            pq.Dequeue();\n        }\n        return pq.Peek();\n    }\n}\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest obj = new KthLargest(k, nums);\n * int param_1 = obj.Add(val);\n */"
    },
    {
      "problemNumber": "0704",
      "title": "Binary Search",
      "language": "C#",
      "filename": "0704-BinarySearch.cs",
      "path": "LeetCode/C#/0704-BinarySearch.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0704-BinarySearch.cs",
      "approach": "Binary Search",
      "tags": [],
      "steps": [
        "1) Initialize the left and right pointers",
        "2) Iterate through the array",
        "3) Calculate the mid",
        "4) If the mid element is equal to the target, return the mid",
        "5) If the mid element is less than the target, increment the left pointer",
        "6) If the mid element is greater than the target, decrement the right pointer",
        "7) Return -1"
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Binary Search\n1) Initialize the left and right pointers\n2) Iterate through the array\n3) Calculate the mid\n4) If the mid element is equal to the target, return the mid\n5) If the mid element is less than the target, increment the left pointer\n6) If the mid element is greater than the target, decrement the right pointer\n7) Return -1\nTime complexity: O(log n)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int Search(int[] nums, int target) {\n        int left = 0;                   // Initialize the left pointer\n        int right = nums.Length - 1;    // Initialize the right pointer\n        int mid = (right+left)/2;       // Calculate the mid\n\n        while(left<=right) {            // Iterate through the array  \n            mid = (right+left)/2;       // Calculate the mid\n\n            if(nums[mid] == target) {   // If the mid element is equal to the target, return the mid\n                return mid;             // Return the mid\n            }\n\n            if(nums[mid] < target) {    // If the mid element is less than the target, increment the left pointer\n                left = mid + 1;         // Increment the left pointer\n            }\n            else {\n                right = mid - 1 ;       // If the mid element is greater than the target, decrement the right pointer\n            }\n        }\n\n        return -1;                      // Return -1 if the target is not found\n    }\n}"
    },
    {
      "problemNumber": "0704",
      "title": "Binary Search",
      "language": "Java",
      "filename": "0704-BinarySearch.java",
      "path": "LeetCode/Java/0704-BinarySearch.java",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Java/0704-BinarySearch.java",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "class Solution {\n    public int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        int mid = 0;\n        while(left<=right) {\n            mid = (left + right)/2;\n            if(nums[mid] == target) {\n                return mid;\n            }\n\n            if(nums[mid] < target) {\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n}"
    },
    {
      "problemNumber": "0709",
      "title": "To Lower Case",
      "language": "C#",
      "filename": "0709-ToLowerCase.cs",
      "path": "LeetCode/C#/0709-ToLowerCase.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0709-ToLowerCase.cs",
      "approach": "Character Manipulation with ASCII Values",
      "tags": [
        "String",
        "Character Manipulation",
        "ASCII"
      ],
      "steps": [
        "1) Use StringBuilder for efficient string construction.",
        "2) Iterate through each character in the input string.",
        "3) Check if the character is an uppercase letter (A-Z).",
        "4) If uppercase, convert to lowercase by adding 32 to ASCII value.",
        "5) Append the (potentially converted) character to StringBuilder.",
        "6) Return the resulting lowercase string."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/to-lower-case/solutions/7400197/simplest-solution-c-time-on-spacen-pleas-4wea/\nApproach: Character Manipulation with ASCII Values\nTags: String, Character Manipulation, ASCII\n1) Use StringBuilder for efficient string construction.\n2) Iterate through each character in the input string.\n3) Check if the character is an uppercase letter (A-Z).\n4) If uppercase, convert to lowercase by adding 32 to ASCII value.\n5) Append the (potentially converted) character to StringBuilder.\n6) Return the resulting lowercase string.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n*/\npublic class Solution {\n    public string ToLowerCase(string s) {\n        StringBuilder sb = new StringBuilder();                 // StringBuilder for efficient string building\n        foreach(char c in s) {                                  // Iterate through each character\n            char newChar = c;                                   // Initialize with original character\n            if (c >= 'A' && c <= 'Z') {                         // Check if character is uppercase\n                newChar = (char)(c + 32);                       // Convert to lowercase (ASCII difference is 32)\n            }\n            sb.Append(newChar);                                 // Append character to result\n        }\n        return sb.ToString();                                   // Return the lowercase string\n    }\n}\n"
    },
    {
      "problemNumber": "0724",
      "title": "Find Pivot Index",
      "language": "C#",
      "filename": "0724-FindPivotIndex.cs",
      "path": "LeetCode/C#/0724-FindPivotIndex.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0724-FindPivotIndex.cs",
      "approach": "Prefix Sum",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Prefix Sum\n1. Calculate the total sum of the array.\n2. Iterate through the array and calculate the sum of the left side and right side of the current index.\n3. If the sum of the left side and right side is equal, return the current index.\n4. If the sum of the left side and right side is not equal, update the sum of the left side and move to the next index.\n5. If no such index is found, return -1.\n\nTime complexity: O(n)\nSpace complexity: O(1)\nwhere n is the number of elements in the array.\n\n*/\npublic class Solution {\n    public int PivotIndex(int[] nums) {\n        int currentIndex = 0;\n            int sumLeft = 0;\n            int sumRight = 0;\n            int totalSum = nums.Sum();\n\n            while(currentIndex < nums.Length) {\n                sumRight = totalSum - sumLeft - nums[currentIndex];\n\n                if(sumLeft == sumRight) {\n                    return currentIndex;\n                }\n                sumLeft = sumLeft + nums[currentIndex];\n                currentIndex++;\n            }\n\n            return -1;\n    }\n}"
    },
    {
      "problemNumber": "0735",
      "title": "Asteroid Collision",
      "language": "C#",
      "filename": "0735-AsteroidCollision.cs",
      "path": "LeetCode/C#/0735-AsteroidCollision.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0735-AsteroidCollision.cs",
      "approach": "- Use a stack to keep track of the asteroids",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n- Use a stack to keep track of the asteroids\n- If the asteroid is positive, push it to the stack\n- If the asteroid is negative, check if the stack is empty or the top of the stack is negative\n    - If the stack is empty or the top of the stack is negative, push the asteroid to the stack\n    - If the top of the stack is positive and the asteroid is negative, check if the top of the stack is smaller than the asteroid\n        - If the top of the stack is smaller than the asteroid, pop the top of the stack\n        - If the top of the stack is equal to the asteroid, pop the top of the stack\n- Reverse the stack and return the result\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int[] AsteroidCollision(int[] asteroids) {\n        Stack<int> stack = new Stack<int>();                                                            // Use a stack to keep track of the asteroids\n        foreach(int asteroid in asteroids) {                                                            // Iterate through the asteroids\n            if(asteroid > 0) {                                                                          // If the asteroid is positive, push it to the stack\n                stack.Push(asteroid);                                                                   // Push the asteroid to the stack\n            }\n            else {\n                while(stack.Count != 0 && stack.Peek() > 0 && stack.Peek() < -asteroid) {               // If the top of the stack is positive and the asteroid is negative, check if the top of the stack is smaller than the asteroid\n                    stack.Pop();                                                                        // Pop the top of the stack\n                }\n                if(stack.Count == 0 || stack.Peek() < 0) {                                              // If the stack is empty or the top of the stack is negative, push the asteroid to the stack\n                    stack.Push(asteroid);                                                               // Push the asteroid to the stack\n                }\n                else if(stack.Peek() == -asteroid) {                                                    // If the top of the stack is equal to the asteroid, pop the top of the stack\n                    stack.Pop();                                                                        // Pop the top of the stack\n                }\n            }\n        }\n        return stack.Reverse().ToArray();                                                               // Reverse the stack and return the result\n    }\n}"
    },
    {
      "problemNumber": "0775",
      "title": "Global Local Inversions",
      "language": "C#",
      "filename": "0775-GlobalLocalInversions.cs",
      "path": "LeetCode/C#/0775-GlobalLocalInversions.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0775-GlobalLocalInversions.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public bool IsIdealPermutation(int[] nums) {\n     for(int i=0; i<nums.Length; i++) {\n         if(Math.Abs(nums[i] - i) > 1) { // Array num to it's index difference should not be greater than 1\n             return false;\n         }\n     }   \n     return true;\n    }\n}"
    },
    {
      "problemNumber": "0781",
      "title": "Rabbitsin Forest",
      "language": "C#",
      "filename": "0781-RabbitsinForest.cs",
      "path": "LeetCode/C#/0781-RabbitsinForest.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0781-RabbitsinForest.cs",
      "approach": "1) We will use a Dictionary to store the number of rabbits that have the same answer.",
      "tags": [],
      "steps": [
        "1) We will use a Dictionary to store the number of rabbits that have the same answer.",
        "2) For each answer, we will check if it is already in the Dictionary.",
        "3) If it is, we will increment the count of rabbits with that answer.",
        "4) If it is not, we will add it to the Dictionary with a count of 1.",
        "5) After processing all the answers, we will iterate through the Dictionary and calculate the total number of rabbits.",
        "6) For each answer, we will calculate the number of groups of rabbits with that answer.",
        "7) The number of groups is equal to the number of rabbits with that answer divided by the size of the group (answer + 1).",
        "8) We will multiply the number of groups by the size of the group to get the total number of rabbits with that answer.",
        "9) Finally, we will return the total number of rabbits."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1) We will use a Dictionary to store the number of rabbits that have the same answer.\n2) For each answer, we will check if it is already in the Dictionary.\n3) If it is, we will increment the count of rabbits with that answer.\n4) If it is not, we will add it to the Dictionary with a count of 1.\n5) After processing all the answers, we will iterate through the Dictionary and calculate the total number of rabbits.\n6) For each answer, we will calculate the number of groups of rabbits with that answer.\n7) The number of groups is equal to the number of rabbits with that answer divided by the size of the group (answer + 1).\n8) We will multiply the number of groups by the size of the group to get the total number of rabbits with that answer.\n9) Finally, we will return the total number of rabbits.\nTime Complexity: O(n)\nSpace Complexity: O(n)\n*/\npublic class Solution {\n    public int NumRabbits(int[] answers) {\n        Dictionary<int, int> groups = new Dictionary<int, int>();                           // Dictionary to store the number of rabbits with the same answer\n        int sum = 0;                                                                        // Variable to store the total number of rabbits\n        foreach (int num in answers) {                                                      // Iterate through the answers\n            if (groups.ContainsKey(num)) {                                                  // If the answer is already in the Dictionary\n                groups[num]++;                                                              // Increment the count of rabbits with that answer\n            } else {                                                                        // If the answer is not in the Dictionary\n                groups.Add(num, 1);                                                         // Add it to the Dictionary with a count of 1\n            }\n        }\n\n        foreach (var group in groups) {                                                     // Iterate through the Dictionary\n            int groupSize = group.Key + 1;                                                  // Calculate the size of the group\n            int numberOfGroups = (int)Math.Ceiling((double)group.Value / groupSize);        // Calculate the number of groups of rabbits with that answer\n            sum += numberOfGroups * groupSize;                                              // Multiply the number of groups by the size of the group to get the total number of rabbits with that answer\n        }\n\n        return sum;                                                                         // Return the total number of rabbits\n    }\n}\n"
    },
    {
      "problemNumber": "0785",
      "title": "Is Graph Bipartite",
      "language": "C#",
      "filename": "0785-IsGraphBipartite.cs",
      "path": "LeetCode/C#/0785-IsGraphBipartite.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0785-IsGraphBipartite.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "\n/*\nSolution: https://leetcode.com/problems/is-graph-bipartite/submissions/1587185288/\nApproach : DFS\n1. Create an array colors of size graph.Length and initialize it with 0.\n2. Iterate through each node in the graph.\n3. If the color of the node is 0 and DFS returns false, return false.\n4. If DFS returns true for all the nodes, return true.\n5. In the DFS function, if the color of the node is not 0, return true if the color is equal to the given color.\n6. If the color of the node is 0, set the color of the node to the given color.\n7. Iterate through each neighbor of the node and call the DFS function with the opposite color.\n8. If the DFS function returns false, return false.\n9. If the DFS function returns true for all the neighbors, return true.\nTime complexity : O(V+E)\nSpace complexity : O(V)\n*/\npublic class Solution {\n    public bool IsBipartite(int[][] graph) {\n        int[] colors = new int[graph.Length];                               // 1 -> Red, -1 -> Blue, 0 -> Not colored\n        for (int i=0; i<graph.Length; i++) {                                // Iterate through each node in the graph\n            if (colors[i] == 0 && !DFS(graph, colors, 1, i)) {              // If the color of the node is 0 and DFS returns false, return false\n                return false;                                               // If DFS returns true for all the nodes, return true\n            }\n        }\n        return true;                                                        // Return true\n    }\n    public bool DFS(int[][] graph, int[] colors, int color, int node) {     // DFS function\n        if(colors[node] != 0) {                                             // If the color of the node is not 0\n            return color == colors[node];                                   // Return true if the color is equal to the given color\n        }\n        colors[node] = color;                                               // Set the color of the node to the given color\n        foreach(int neighbor in graph[node]) {                              // Iterate through each neighbor of the node\n            if (!DFS(graph, colors, -color, neighbor)) {                    // Call the DFS function with the opposite color\n                return false;                                               // If the DFS function returns false, return false\n            }\n        }\n        return true;                                                        // If the DFS function returns true for all the neighbors, return true\n    }\n}\n"
    },
    {
      "problemNumber": "0844",
      "title": "Backspace String Compare",
      "language": "C#",
      "filename": "0844-BackspaceStringCompare.cs",
      "path": "LeetCode/C#/0844-BackspaceStringCompare.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0844-BackspaceStringCompare.cs",
      "approach": "Two Pointer Technique",
      "tags": [],
      "steps": [
        "1) Traverse both strings from the end to the beginning.",
        "2) Use two pointers to skip characters that are followed by a backspace character '#'.",
        "3) Compare the characters at the pointers after skipping the backspaces."
      ],
      "timeComplexity": "O(n + m), where n and m are the lengths of the two strings.",
      "spaceComplexity": "O(1), as we are not using any extra space except for a few variables.",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/backspace-string-compare/solutions/6891192/simplest-solution-c-time-onm-space1-plea-y9ba/\nApproach: Two Pointer Technique\n1) Traverse both strings from the end to the beginning.\n2) Use two pointers to skip characters that are followed by a backspace character '#'.\n3) Compare the characters at the pointers after skipping the backspaces.\nTime Complexity: O(n + m), where n and m are the lengths of the two strings.\nSpace Complexity: O(1), as we are not using any extra space except for a few variables.\n*/\npublic class Solution\n{\n    public bool BackspaceCompare(string s, string t)\n    {\n        return BackSpaceString(s) == BackSpaceString(t);                        // Compare the processed strings after handling backspaces\n    }\n\n    public string BackSpaceString(string s)\n    {\n        int backSpace = 0;                                                      // Counter for backspaces\n        StringBuilder sb = new StringBuilder();\n        for (int i = s.Length - 1; i >= 0; i--)                                 // Traverse the string from the end to the beginning\n        {\n            if (s[i] == '#')                                                    // If the current character is a backspace\n            {\n                backSpace++;                                                    // Increment the backspace counter\n                continue;                                                       // Skip the current character\n            }\n            if (backSpace > 0)                                                  // If there are backspaces to process\n            {\n                backSpace--;                                                    // Decrement the backspace counter\n                continue;                                                       // Skip the current character\n            }\n            sb.Append(s[i]);                                                    // Append the current character to the StringBuilder\n        }\n\n        string result = new string(sb.ToString().Reverse().ToArray());          // Reverse the StringBuilder to get the correct order of characters\n        return result;                                                          // Return the processed string\n    }\n}"
    },
    {
      "problemNumber": "0876",
      "title": "Middleofthe Linked List",
      "language": "C#",
      "filename": "0876-MiddleoftheLinkedList.cs",
      "path": "LeetCode/C#/0876-MiddleoftheLinkedList.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0876-MiddleoftheLinkedList.cs",
      "approach": "1) Initialize two pointers, slow and fast, and point them to the head of the linked list.",
      "tags": [],
      "steps": [
        "1) Initialize two pointers, slow and fast, and point them to the head of the linked list.",
        "2) Traverse the linked list until the fast pointer reaches the end.",
        "3) Move the slow pointer by one step and the fast pointer by two steps.",
        "4) If the slow and fast pointers meet, then there is a cycle in the linked list.",
        "5) If the fast pointer reaches the end of the linked list, then there is no cycle.",
        "6) Return true if there is a cycle, else return false."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1) Initialize two pointers, slow and fast, and point them to the head of the linked list.\n2) Traverse the linked list until the fast pointer reaches the end.\n3) Move the slow pointer by one step and the fast pointer by two steps.\n4) If the slow and fast pointers meet, then there is a cycle in the linked list.\n5) If the fast pointer reaches the end of the linked list, then there is no cycle.\n6) Return true if there is a cycle, else return false.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MiddleNode(ListNode head) {\n        ListNode fast, slow;                            // Initialize two pointers\n        slow = fast = head;                             // Point both the pointers to the head of the linked list\n        while(fast != null && fast.next != null) {      // Traverse the linked list until the fast pointer reaches the end\n            slow = slow.next;                           // Move the slow pointer by one step\n            fast = fast.next.next;                      // Move the fast pointer by two steps\n        }\n        return slow;                                    // Return the slow pointer\n    }\n}"
    },
    {
      "problemNumber": "0896",
      "title": "Monotonic Array",
      "language": "C#",
      "filename": "0896-MonotonicArray.cs",
      "path": "LeetCode/C#/0896-MonotonicArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0896-MonotonicArray.cs",
      "approach": "1. Check if the array is increasing monotonic or decreasing monotonic.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Check if the array is increasing monotonic or decreasing monotonic.\n2. If the array is increasing monotonic or decreasing monotonic, return true.\n3. If the array is neither increasing monotonic nor decreasing monotonic, return false.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n\n*/\npublic class Solution {\n    public bool IsMonotonic(int[] nums) {\n            return IsIncreasingMonotonic(nums) || IsDecreasingMonotonic(nums);\n    }\n    static bool IsIncreasingMonotonic(int[] nums) {\n            int index = 0;\n            while(index < nums.Length - 1) {\n                if (nums[index] > nums [index + 1])  return false;\n                index++;\n            }\n\n            return true;\n        }\n\n        static bool IsDecreasingMonotonic(int[] nums) {\n            int index = 0;\n            while(index < nums.Length - 1) {\n                if (nums[index] < nums [index + 1])  return false;\n                index++;\n            }\n\n            return true;\n        }\n}"
    },
    {
      "problemNumber": "0904",
      "title": "Fruit Into Baskets",
      "language": "C#",
      "filename": "0904-FruitIntoBaskets.cs",
      "path": "LeetCode/C#/0904-FruitIntoBaskets.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0904-FruitIntoBaskets.cs",
      "approach": "Two Pointers (Sliding Window)",
      "tags": [
        "Array",
        "Hash Table",
        "Sliding Window",
        "Two Pointers"
      ],
      "steps": [
        "1) Use a sliding window approach with left and right pointers.",
        "2) Use a dictionary to track fruit types and their counts in current window.",
        "3) Expand the window by moving right pointer and adding fruits to dictionary.",
        "4) If more than 2 fruit types exist, shrink window from left until only 2 types remain.",
        "5) Track the maximum window size (maximum fruits collected) throughout the process.",
        "6) Return the maximum number of fruits that can be collected."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1) - at most 3 fruit types in dictionary",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/fruit-into-baskets/solutions/7043440/simplest-solution-c-time-on-spacen-pleas-9kr1/\nApproach: Two Pointers (Sliding Window)\nTags: Array, Hash Table, Sliding Window, Two Pointers\n1) Use a sliding window approach with left and right pointers.\n2) Use a dictionary to track fruit types and their counts in current window.\n3) Expand the window by moving right pointer and adding fruits to dictionary.\n4) If more than 2 fruit types exist, shrink window from left until only 2 types remain.\n5) Track the maximum window size (maximum fruits collected) throughout the process.\n6) Return the maximum number of fruits that can be collected.\n\nTime Complexity: O(n)\nSpace Complexity: O(1) - at most 3 fruit types in dictionary\n*/\npublic class Solution {\n    public int TotalFruit(int[] fruits) {\n        int left = 0;                                               // Left pointer for sliding window\n        int maxFruits = 0;                                          // Maximum fruits collected so far\n        Dictionary<int, int> dict = new Dictionary<int, int>();     // Dictionary to track fruit types and counts\n\n        for (int right = 0; right < fruits.Length; right++) {      // Expand window by moving right pointer\n            int fruitType = fruits[right];                          // Get current fruit type\n\n            if (!dict.ContainsKey(fruitType)) {                     // If fruit type not in dictionary\n                dict[fruitType] = 0;                                // Initialize count to 0\n            }\n            dict[fruitType]++;                                      // Increment count of current fruit type\n\n            while (dict.Count > 2) {                                // While we have more than 2 fruit types\n                int leftFruit = fruits[left];                       // Get fruit type at left pointer\n                dict[leftFruit]--;                                  // Decrease count of left fruit\n                if (dict[leftFruit] == 0) {                         // If count becomes 0\n                    dict.Remove(leftFruit);                         // Remove fruit type from dictionary\n                }\n                left++;                                             // Move left pointer to shrink window\n            }\n\n            maxFruits = Math.Max(maxFruits, right - left + 1);      // Update maximum fruits with current window size\n        }\n\n        return maxFruits;                                           // Return maximum fruits collected\n    }\n}\n"
    },
    {
      "problemNumber": "0929",
      "title": "Unique  Email  Addresses",
      "language": "C#",
      "filename": "0929-Unique Email Addresses.cs",
      "path": "LeetCode/C#/0929-Unique Email Addresses.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0929-Unique%20Email%20Addresses.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "// Approach 1\npublic class Solution {\n    public int NumUniqueEmails(string[] emails) {\n\n        HashSet<String> hs = new HashSet<String>();\n        foreach(string email in emails) {\n            string localName = email.Split('@')[0];\n            string domain = email.Split('@')[1];\n            localName = localName.Split('+')[0];\n            localName = localName.Replace(\".\",\"\");\n            hs.Add(localName+\"@\"+domain);\n        }\n        return hs.Count();\n    }\n}"
    },
    {
      "problemNumber": "0946",
      "title": "Validate Stack Sequences",
      "language": "C#",
      "filename": "0946-ValidateStackSequences.cs",
      "path": "LeetCode/C#/0946-ValidateStackSequences.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/0946-ValidateStackSequences.cs",
      "approach": "1) Initialize the currentItemToBePoppedIndex to 0",
      "tags": [],
      "steps": [
        "1) Initialize the currentItemToBePoppedIndex to 0",
        "2) Initialize the stack",
        "3) Iterate through the pushed array",
        "4) Push the element to the stack",
        "5) While the stack is not empty and the top element of the stack is equal to the element at currentItemToBePoppedIndex in the popped array",
        "6) Pop the element from the stack",
        "7) Increment the currentItemToBePoppedIndex",
        "8) Return true if the stack is empty, else return false"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize the currentItemToBePoppedIndex to 0\n2) Initialize the stack\n3) Iterate through the pushed array\n4) Push the element to the stack\n5) While the stack is not empty and the top element of the stack is equal to the element at currentItemToBePoppedIndex in the popped array\n6) Pop the element from the stack\n7) Increment the currentItemToBePoppedIndex\n8) Return true if the stack is empty, else return false\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public bool ValidateStackSequences(int[] pushed, int[] popped) {\n        int currentItemToBePoppedIndex = 0;                                                             // Initialize the currentItemToBePoppedIndex to 0\n        Stack<int> stack = new Stack<int>();                                                            // Initialize the stack\n        foreach(int num in pushed) {                                                                    // Iterate through the pushed array\n            stack.Push(num);                                                                            // Push the element to the stack\n            while(stack.Count > 0 && stack.Peek() == popped[currentItemToBePoppedIndex]) {              // While the stack is not empty and the top element of the stack is equal to the element at currentItemToBePoppedIndex in the popped array\n                stack.Pop();                                                                            // Pop the element from the stack\n                currentItemToBePoppedIndex++;                                                           // Increment the currentItemToBePoppedIndex\n            }\n        }\n        return stack.Count>0?false:true;                                                                // Return true if the stack is empty, else return false\n    }\n}"
    },
    {
      "problemNumber": "1046",
      "title": "Last Stone Weight",
      "language": "C#",
      "filename": "1046-LastStoneWeight.cs",
      "path": "LeetCode/C#/1046-LastStoneWeight.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1046-LastStoneWeight.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public int LastStoneWeight(int[] stones) {\n            PriorityQueue<int, int> pq = new PriorityQueue<int, int>(Comparer<int>.Create((x, y) => y - x));\n            for (int i = 0; i < stones.Length; i++)\n                pq.Enqueue(stones[i], stones[i]);\n            int fe = pq.Dequeue();\n            while (pq.Count > 0)\n            {\n                int se = pq.Dequeue();\n                int ne;\n                ne = Math.Abs(se - fe);\n                if (ne > 0)\n                {\n                    pq.Enqueue(ne, ne);\n                    se = 0;\n                }\n                if (ne == 0)\n                {\n                    fe = se = -1;\n                }\n                if (pq.Count > 0)\n                {\n                    fe = pq.Dequeue();\n                }\n            }\n            return fe == -1 ? 0 : fe;\n        }\n}\n"
    },
    {
      "problemNumber": "1068",
      "title": "Product Sales Analysis I",
      "language": "SQL",
      "filename": "1068-ProductSalesAnalysisI.sql",
      "path": "LeetCode/SQL/1068-ProductSalesAnalysisI.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/1068-ProductSalesAnalysisI.sql",
      "approach": "Join the tables on product_id",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "-- Approach: Join the tables on product_id\n-- 1. We need to join the sales and product tables on the basis of the product_id column.\n-- 2. We can achieve this by using the left join keyword to join the two tables.\n-- 3. We need to specify the columns that we want to select from the tables.\n-- 4. We need to specify the condition on which we want to join the tables.\n-- 5. Return the product_name, year, and price columns.\n\nselect p.product_name, s.year, s.price from sales as s\nleft join product as p\non s.product_id = p.product_id"
    },
    {
      "problemNumber": "1148",
      "title": "Article Views I",
      "language": "SQL",
      "filename": "1148-ArticleViewsI.sql",
      "path": "LeetCode/SQL/1148-ArticleViewsI.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/1148-ArticleViewsI.sql",
      "approach": "Self Join",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "-- Approach: Self Join\n-- 1. We need to find the author_id who viewed their own article.\n-- 2. We can achieve this by joining the views table with itself on author_id = viewer_id.\n-- 3. We need to select the distinct author_id as id from views where author_id = viewer_id.\n-- 4. We need to order the result by author_id.\n-- 5. Return the id.\nselect distinct author_id as id from views\n    where author_id = viewer_id\n    order by author_id"
    },
    {
      "problemNumber": "1160",
      "title": "Find Words That Can Be Formed By Characters",
      "language": "C#",
      "filename": "1160-FindWordsThatCanBeFormedByCharacters.cs",
      "path": "LeetCode/C#/1160-FindWordsThatCanBeFormedByCharacters.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1160-FindWordsThatCanBeFormedByCharacters.cs",
      "approach": "1. Create a dictionary of characters and their count in chars string.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n*m) where n is the length of words and m is the length of chars.",
      "spaceComplexity": "O(n) where n is the length of chars.",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a dictionary of characters and their count in chars string.\n2. For each word in words, create a dictionary of characters and their count.\n3. Check if the word can be formed from chars string.\n    a. If yes, add the length of the word to result.\n4. Return the result.\n\nTime Complexity: O(n*m) where n is the length of words and m is the length of chars.\nSpace Complexity: O(n) where n is the length of chars.\n\n*/\npublic class Solution {\n    public int CountCharacters(string[] words, string chars) {\n        Dictionary<char,int> dict = new Dictionary<char,int>();\n        Dictionary<char,int> temp = new Dictionary<char,int>();\n        int result = 0;\n        foreach(char ch in chars) {\n            if(!dict.ContainsKey(ch)) {\n                dict[ch] = 1;\n            }\n            else {\n                dict[ch] = dict[ch] + 1;\n            }\n        }\n\n        foreach(string word in words) {\n\n            foreach(char ch in word) {\n               if(!temp.ContainsKey(ch)) {\n                    temp[ch] = 1;\n                }\n                else {\n                    temp[ch] = temp[ch] + 1;\n                }\n            }\n\n            int index = 0;\n            foreach(var kv in temp) {\n                if (dict.ContainsKey(kv.Key) && dict[kv.Key] >= temp[kv.Key])  {\n                    index++;\n                    continue;\n                }\n                else {\n                    break;\n                }\n            }\n            if (index == temp.Count())\n                result = result + word.Length;\n            temp.Clear();\n        }\n        return result;\n\n    }\n}"
    },
    {
      "problemNumber": "1189",
      "title": "Maximum Number Of Balloons",
      "language": "C#",
      "filename": "1189-MaximumNumberOfBalloons.cs",
      "path": "LeetCode/C#/1189-MaximumNumberOfBalloons.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1189-MaximumNumberOfBalloons.cs",
      "approach": "1. Create a dictionary to store the count of each character in the word \"balloon\".",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a dictionary to store the count of each character in the word \"balloon\".\n2. Create another dictionary to store the count of each character in the given text.\n3. Create a list to store the count of each character in the given text divided by the count of each character in the word \"balloon\".\n4. Return the minimum value from the list.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\npublic class Solution {\n    public int MaxNumberOfBalloons(string text) {\n        string balloon = \"balloon\";\n\n            Dictionary<char,int> text_dict = new Dictionary<char, int>();\n            Dictionary<char,int> balloon_dict = new Dictionary<char, int>();\n            IList<int> count = new List<int>();\n\n            int numOfTextChar = 0;\n            int numOfBalloonsChar = 0;\n\n            foreach(char c in balloon) {\n                if(balloon_dict.ContainsKey(c)) {\n                    balloon_dict[c] = balloon_dict[c] + 1;\n                }\n                else {\n                    balloon_dict.Add(c,1);\n                }\n            }\n\n            foreach(char c in text) {\n                if(text_dict.ContainsKey(c)) {\n                    text_dict[c] = text_dict[c] + 1;\n                }\n                else {\n                    text_dict.Add(c,1);\n                }\n            }\n\n            foreach(var kv in balloon_dict) {\n\n                numOfBalloonsChar = kv.Value;\n\n                if(text_dict.ContainsKey(kv.Key)) {\n                    numOfTextChar = text_dict[kv.Key];\n                    count.Add(numOfTextChar/numOfBalloonsChar);\n                }\n                else {\n                    return 0;\n                }\n\n            }\n\n            return count.Min();\n    }\n}\n\n/*\nSame approach smaller code\n*/\n\npublic class Solution {\n    public int MaxNumberOfBalloons(string text) {\n        var charCounts = text.GroupBy(c => c)\n                        .ToDictionary(g => g.Key, g => g.Count());\n        var balloonCounts = \"balloon\".GroupBy(c => c)\n                        .ToDictionary(g => g.Key, g => g.Count());\n\n        int result = text.Length;\n        foreach (var balloonCount in balloonCounts) {\n            if (charCounts.ContainsKey(balloonCount.Key)) {\n                result = Math.Min(result, charCounts[balloonCount.Key] / balloonCount.Value);\n            } else {\n                result = 0;\n                break;\n            }\n        }\n        return result;\n    }\n}"
    },
    {
      "problemNumber": "1299",
      "title": "Replace Elements With Greatest Element On Right Side",
      "language": "C#",
      "filename": "1299-ReplaceElementsWithGreatestElementOnRightSide.cs",
      "path": "LeetCode/C#/1299-ReplaceElementsWithGreatestElementOnRightSide.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1299-ReplaceElementsWithGreatestElementOnRightSide.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public int[] ReplaceElements(int[] arr) {\n\n        int oldMax = -1;\n        int newMax = -1;\n        \n        for(int i=arr.Length - 1; i > -1; i--) {\n\n         newMax = Math.Max(oldMax,arr[i]);\n         arr[i] = oldMax;\n         oldMax = newMax;\n    \n        }\n        return arr;   \n    }\n}\n"
    },
    {
      "problemNumber": "1323",
      "title": "Maximum69 Number",
      "language": "C#",
      "filename": "1323-Maximum69Number.cs",
      "path": "LeetCode/C#/1323-Maximum69Number.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1323-Maximum69Number.cs",
      "approach": "Scan from highest digit, change first 6 to 9",
      "tags": [
        "Math",
        "Greedy",
        "Simulation"
      ],
      "steps": [
        "1) Start from the highest digit (thousands place for 4-digit numbers).",
        "2) If the current digit is 6, change it to 9 and return the new number.",
        "3) If not, move to the next lower digit.",
        "4) If no 6 is found, return the original number."
      ],
      "timeComplexity": "O(1) (since number of digits is constant)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/maximum-69-number/solutions/7088498/simplest-solution-c-time-o1-space1-pleas-psug/\nTags: Greedy\nApproach: Scan from highest digit, change first 6 to 9\nTags: Math, Greedy, Simulation\n1) Start from the highest digit (thousands place for 4-digit numbers).\n2) If the current digit is 6, change it to 9 and return the new number.\n3) If not, move to the next lower digit.\n4) If no 6 is found, return the original number.\n\nTime Complexity: O(1) (since number of digits is constant)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int Maximum69Number (int num) {\n        int pos = 4;                              // Position tracker for digits (thousands to units)\n        int q = 1000;                             // Divisor to extract each digit\n        int originalNum = num;                    // Store original number for calculation\n\n        while (pos > 0) {                        // Check each digit from left to right\n            if (num / q == 6)                    // If current digit is 6\n                return originalNum + (3 * q);    // Change 6 to 9 (add 3 * place value) and return\n            else {\n                num = num % q;                   // Remove the leftmost digit\n                q = q / 10;                      // Move to next lower digit\n                pos--;                           // Decrement position\n            }\n        }\n        return originalNum;                      // If no 6 found, return original number\n    }\n}"
    },
    {
      "problemNumber": "1343",
      "title": "Numberof Sub-arraysof Size Kand Average Greaterthanor Equalto Threshold",
      "language": "C#",
      "filename": "1343-NumberofSub-arraysofSizeKandAverageGreaterthanorEqualtoThreshold.cs",
      "path": "LeetCode/C#/1343-NumberofSub-arraysofSizeKandAverageGreaterthanorEqualtoThreshold.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1343-NumberofSub-arraysofSizeKandAverageGreaterthanorEqualtoThreshold.cs",
      "approach": "1. We will initialize i, j, c, res, and sum to 0.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We will initialize i, j, c, res, and sum to 0.\n2. We will calculate the sum of the first k elements and check if the average is greater than or equal to the threshold.\n3. We will increment the result if the average is greater than or equal to the threshold.\n4. We will iterate through the array and calculate the sum of the next k elements.\n5. We will check if the average is greater than or equal to the threshold and increment the result accordingly.\n6. We will return the result.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public int NumOfSubarrays(int[] arr, int k, int threshold) {\n        int i ,j, c, res, sum;                          // Initialize i, j, c, res, and sum to 0.\n        i = c = sum = res = 0;                          // Initialize i, c, sum, and res to 0.\n        j = i + k - 1;                                  // Initialize j to i + k - 1.\n\n        while (c <= j) {                                // Calculate the sum of the first k elements.\n            sum = sum + arr[c];                         // Add the element at index c to the sum.\n            c++;                                        // Increment c.\n        }\n\n        res = (sum/k) >= threshold ? 1 : 0;             // Check if the average is greater than or equal to the threshold and increment the result accordingly.\n\n        while ( j < arr.Length) {                       // Iterate through the array and calculate the sum of the next k elements.\n            sum = sum - arr[i++];                       // Subtract the element at index i from the sum and increment i.\n            j++;                                        // Increment j.\n            if(j < arr.Length) {                        // Check if j is less than the length of the array.\n                sum = sum + arr[j];                     // Add the element at index j to the sum.\n            }\n            else {\n                break;                                  // Break the loop if j is equal to or greater than the length of the array.\n            }\n            if((sum/k) >= threshold) {                  // Check if the average is greater than or equal to the threshold.\n                res++;                                  // Increment the result.\n            }\n        }\n\n        return res;                                     // Return the result.\n    }\n}"
    },
    {
      "problemNumber": "1378",
      "title": "Replace Employee I D With The Unique Identifier",
      "language": "SQL",
      "filename": "1378-ReplaceEmployeeIDWithTheUniqueIdentifier.sql",
      "path": "LeetCode/SQL/1378-ReplaceEmployeeIDWithTheUniqueIdentifier.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/1378-ReplaceEmployeeIDWithTheUniqueIdentifier.sql",
      "approach": "Join the two tables on the basis of id",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "-- Approach: Join the two tables on the basis of id\n-- 1. We need to join the Employees and EmployeeUNI tables on the basis of the id column.\n-- 2. We can achieve this by using the join keyword to join the two tables.\n-- 3. We need to specify the columns that we want to select from the tables.\n-- 4. We need to specify the condition on which we want to join the tables.\n-- 5. Return the unique_id and name columns.\n\nselect\neu.unique_id as unique_id, e.name as name\nfrom Employees e\nleft join EmployeeUNI eu\non e.id = eu.id\n\n-- or\n\n-- SELECT\n--   EmployeeUNI.unique_id,\n--   Employees.name\n-- FROM Employees\n-- LEFT JOIN EmployeeUNI\n--   USING (id);"
    },
    {
      "problemNumber": "1399",
      "title": "Count Largest Group",
      "language": "C#",
      "filename": "1399-CountLargestGroup.cs",
      "path": "LeetCode/C#/1399-CountLargestGroup.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1399-CountLargestGroup.cs",
      "approach": "Using Dictionary",
      "tags": [],
      "steps": [
        "1) We will use a Dictionary to store the number of groups with the same sum of digits.",
        "2) For each number from 1 to n, we will calculate the sum of its digits.",
        "3) We will check if the sum of digits is already in the Dictionary.",
        "4) If it is, we will increment the count of groups with that sum of digits.",
        "5) If it is not, we will add it to the Dictionary with a count of 1.",
        "6) After processing all the numbers, we will find the largest group size.",
        "7) We will iterate through the Dictionary and count the number of groups with the largest size.",
        "8) Finally, we will return the count of groups with the largest size."
      ],
      "timeComplexity": "O(n * log(n))",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/count-largest-group/submissions/1615589789/?envType=daily-question&envId=2025-04-23\nApproach: Using Dictionary\n1) We will use a Dictionary to store the number of groups with the same sum of digits.\n2) For each number from 1 to n, we will calculate the sum of its digits.\n3) We will check if the sum of digits is already in the Dictionary.\n4) If it is, we will increment the count of groups with that sum of digits.\n5) If it is not, we will add it to the Dictionary with a count of 1.\n6) After processing all the numbers, we will find the largest group size.\n7) We will iterate through the Dictionary and count the number of groups with the largest size.\n8) Finally, we will return the count of groups with the largest size.\nTime Complexity: O(n * log(n))\nSpace Complexity: O(n)\n\n*/\npublic class Solution {\n    public int CountLargestGroup(int n) {\n        Dictionary<int, int> dict = new Dictionary<int,int>();          // Dictionary to store the number of groups with the same sum of digits\n        int largestGroup = 0;                                           // Variable to store the largest group size\n        for (int i=1; i<=n; i++) {                                      // Iterate through numbers from 1 to n\n            int sumOfDigits = SumOfDigits(i);                           // Calculate the sum of digits of the number\n            if (dict.ContainsKey(sumOfDigits)) {                        // If the sum of digits is already in the Dictionary\n                dict[sumOfDigits]++;                                    // Increment the count of groups with that sum of digits\n            }\n            else {                                                      // If the sum of digits is not in the Dictionary\n                dict.Add(sumOfDigits, 1);                               // Add it to the Dictionary with a count of 1\n            }\n            largestGroup = Math.Max(largestGroup, dict[sumOfDigits]);   // Update the largest group size\n        }\n\n        int noOfGroupsWithLargestSize = 0;                              // Variable to store the count of groups with the largest size\n        foreach(var group in dict.Values) {                             // Iterate through the Dictionary\n            if (group == largestGroup) {                                // If the group size is equal to the largest group size\n                noOfGroupsWithLargestSize++;                            // Increment the count of groups with the largest size\n            }\n        }\n\n        return noOfGroupsWithLargestSize;                               // Return the count of groups with the largest size\n    }\n\n    private int SumOfDigits(int n) {                                    // Helper function to calculate the sum of digits of a number\n        int sum = 0;                                                    // Variable to store the sum of digits\n        while (n>0) {                                                   // While there are still digits left in the number\n            sum+= n%10;                                                 // Add the last digit to the sum\n            n=n/10;                                                     // Remove the last digit from the number\n        }\n        return sum;                                                     // Return the sum of digits\n    }\n}"
    },
    {
      "problemNumber": "1408",
      "title": "String Matchinginan Array",
      "language": "C#",
      "filename": "1408-StringMatchinginanArray.cs",
      "path": "LeetCode/C#/1408-StringMatchinginanArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1408-StringMatchinginanArray.cs",
      "approach": "Brute Force",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: Brute Force\n1. Create a list of strings to store the result\n2. Iterate through the words array\n3. Iterate through the words array again\n4. Check if the word is not the same as the current word and the current word is a substring of the word\n5. If the condition is true, add the current word to the result list and break the inner loop\n6. Return the result list\n\nNote: Use KMP, trie, Rabin-Karp, or other string matching algorithms for better performance\nTime complexity: O(n^2)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    public IList<string> StringMatching(string[] words) {\n        IList<string> result = new List<string>();      // declare a list of strings to store the result\n        for (int i=0; i<words.Length; i++) {            // iterate through the words array\n            for (int j=0; j<words.Length; j++) {        // iterate through the words array again\n                if (i==j) continue;                     // check if the word is not the same as the current word\n                if(words[j].Contains(words[i])) {       // check if the current word is a substring of the word\n                    result.Add(words[i]);               // add the current word to the result list\n                    break;                              // break the inner loop if the word is found to avoid duplicates\n                }\n            }\n        }\n        return result;\n    }\n}"
    },
    {
      "problemNumber": "1422",
      "title": "Maximum Score After Splitting A String",
      "language": "C#",
      "filename": "1422-MaximumScoreAfterSplittingAString.cs",
      "path": "LeetCode/C#/1422-MaximumScoreAfterSplittingAString.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1422-MaximumScoreAfterSplittingAString.cs",
      "approach": "1. Count the number of 1's in the right part of the string.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Count the number of 1's in the right part of the string.\n2. Traverse the string from left to right and count the number of 0's in the left part of the string.\n3. Calculate the score by adding the number of 0's in the left part and the number of 1's in the right part.\n4. Update the maxScore if the current score is greater than the maxScore.\n5. Return the maxScore.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public int MaxScore(string s) {\n     int currentIndex, numOfZerosInLeftPart, numOfOnesInRightPart, score, maxScore;\n            currentIndex = numOfZerosInLeftPart = numOfOnesInRightPart = score = maxScore = 0;\n\n            while(currentIndex < s.Length) {\n\n                if(s[currentIndex] == '1') numOfOnesInRightPart++;\n                currentIndex++;\n\n            }\n\n            currentIndex = 0;\n\n            while(currentIndex < s.Length - 1) {\n\n                if (s[currentIndex] == '0') {\n                    numOfZerosInLeftPart++;\n                }\n                else {\n                    numOfOnesInRightPart--;\n                }\n\n                score = numOfZerosInLeftPart + numOfOnesInRightPart;\n                if (score > maxScore) maxScore = score;\n                currentIndex++;\n\n            }\n\n            return maxScore;\n    }\n}"
    },
    {
      "problemNumber": "1436",
      "title": "Destination City",
      "language": "C#",
      "filename": "1436-DestinationCity.cs",
      "path": "LeetCode/C#/1436-DestinationCity.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1436-DestinationCity.cs",
      "approach": "HashSet",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: HashSet\n1. Create a HashSet to store all the destination cities.\n2. Add all the destination cities to the HashSet.\n3. Remove all the source cities from the HashSet.\n4. The remaining city in the HashSet is the destination city.\n5. Return the destination city.\n\nTime complexity: O(n)\nSpace complexity: O(n)\nwhere n is the number of paths.\n\n*/\npublic class Solution {\n    public string DestCity(IList<IList<string>> paths) {\n\n        HashSet<string> hashSet = new HashSet<string>();\n\n        foreach(var item in paths) {\n            hashSet.Add(item[1]);\n        }\n\n        foreach(var item in paths) {\n            hashSet.Remove(item[0]);\n        }\n\n        return hashSet.Single();\n    }\n}"
    },
    {
      "problemNumber": "1436",
      "title": "Destination City",
      "language": "Python",
      "filename": "1436-DestinationCity.py",
      "path": "LeetCode/Python/1436-DestinationCity.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/1436-DestinationCity.py",
      "approach": "1. Create a dictionary mapping where the key is the source city and the value is the destination city.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "'''\nApproach:\n1. Create a dictionary mapping where the key is the source city and the value is the destination city.\n2. Start from the first source city and keep on updating the source city to the destination city.\n3. If the source city is not in the mapping, then it is the destination city.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n'''\nclass Solution:\n    def destCity(self, paths: List[List[str]]) -> str:\n        mapping = {}\n        for path in paths:\n            mapping[path[0]] = path[1]\n        dest = paths[0][0]\n        while(dest is not None):\n            if dest in mapping:\n                dest = mapping[dest]\n            else:\n                return dest\n"
    },
    {
      "problemNumber": "1437",
      "title": "Check If All1s Areat Least Length K Places Away",
      "language": "C#",
      "filename": "1437-CheckIfAll1sAreatLeastLengthKPlacesAway.cs",
      "path": "LeetCode/C#/1437-CheckIfAll1sAreatLeastLengthKPlacesAway.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1437-CheckIfAll1sAreatLeastLengthKPlacesAway.cs",
      "approach": "Track Distance Between Consecutive 1's",
      "tags": [
        "Array",
        "Greedy"
      ],
      "steps": [
        "1) Initialize the last position of 1 to -(k+1) to handle the first 1 correctly.",
        "2) Iterate through the array and check each element.",
        "3) When a 1 is found, calculate the distance from the previous 1.",
        "4) If the distance between consecutive 1's is less than k, return false.",
        "5) Update the last position of 1 and continue.",
        "6) If all 1's are at least k places apart, return true."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: Check If All 1's Are at Least K Places Away\nApproach: Track Distance Between Consecutive 1's\nTags: Array, Greedy\n1) Initialize the last position of 1 to -(k+1) to handle the first 1 correctly.\n2) Iterate through the array and check each element.\n3) When a 1 is found, calculate the distance from the previous 1.\n4) If the distance between consecutive 1's is less than k, return false.\n5) Update the last position of 1 and continue.\n6) If all 1's are at least k places apart, return true.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool KLengthApart(int[] nums, int k) {\n        int lastOneFoundAtIndex = -(k + 1);                     // Initialize to ensure first 1 is always valid\n        for (int i = 0; i < nums.Length; i++) {                 // Iterate through each element in array\n\n            if (nums[i] == 1) {                                 // If current element is 1\n                if ((i - lastOneFoundAtIndex - 1) < k) {        // Check distance from previous 1 (excluding both 1's)\n                    return false;                               // Return false if distance is less than k\n                }\n                lastOneFoundAtIndex = i;                        // Update last position of 1\n            }\n        }\n        return true;                                            // All 1's are at least k places apart\n    }\n}"
    },
    {
      "problemNumber": "1496",
      "title": "Path Crossing",
      "language": "C#",
      "filename": "1496-PathCrossing.cs",
      "path": "LeetCode/C#/1496-PathCrossing.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1496-PathCrossing.cs",
      "approach": "1. Create a hashset to store the visited points.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a hashset to store the visited points.\n2. Initially, add the starting point (0,0) to the hashset.\n3. Traverse the path string and for each character, update the x and y coordinates.\n4. If the current point is already visited, return true.\n5. Otherwise, add the current point to the hashset.\n6. If the loop completes, return false.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public bool IsPathCrossing(string path) {\n        HashSet<(int,int)> set = new HashSet<(int,int)>();\n            int x,y;\n            x = y = 0;\n            set.Add((0,0));\n\n            foreach(char c in path) {\n                switch (c) {\n\n                    case 'N':\n                        y=y+1;\n                        break;\n                    case 'E':\n                        x=x+1;\n                        break;\n                    case 'S':\n                        y=y-1;\n                        break;\n                    case 'W':\n                        x=x-1;\n                        break;\n                }\n\n                if (set.Contains((x,y)))\n                    return true;\n                set.Add((x,y));\n\n            }\n\n            return false;\n    }\n}"
    },
    {
      "problemNumber": "1500",
      "title": "Evaluate Reverse Polish Notation",
      "language": "C#",
      "filename": "1500-EvaluateReversePolishNotation.cs",
      "path": "LeetCode/C#/1500-EvaluateReversePolishNotation.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1500-EvaluateReversePolishNotation.cs",
      "approach": "1) Initialize the num1 and num2 to 0",
      "tags": [],
      "steps": [
        "1) Initialize the num1 and num2 to 0",
        "2) Initialize the stack",
        "3) Iterate through the tokens",
        "4) If the token is an operator, pop the top two elements from the stack",
        "5) Perform the operation based on the operator",
        "6) Push the result to the stack",
        "7) If the token is an operand, push the operand to the stack",
        "8) Return the top element from the stack"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) Initialize the num1 and num2 to 0\n2) Initialize the stack\n3) Iterate through the tokens\n4) If the token is an operator, pop the top two elements from the stack\n5) Perform the operation based on the operator\n6) Push the result to the stack\n7) If the token is an operand, push the operand to the stack\n8) Return the top element from the stack\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution\n{\n    public int EvalRPN(string[] tokens)\n    {\n        int num1 = 0;                                       // Initialize the num1 to 0\n        int num2 = 0;                                       // Initialize the num2 to 0\n        Stack<int> stack = new Stack<int>();                // Initialize the stack\n        foreach (string op in tokens)\n        {                                                   // Iterate through the tokens\n\n            switch (op)\n            {                                               // Switch based on the operator\n\n                case \"+\":                                   // If the operator is +\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num1 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num2 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    stack.Push(num2 + num1);                // Push the result to the stack\n                    break;                                  // Break the case\n\n                case \"-\":                                   // If the operator is -\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num1 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num2 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    stack.Push(num2 - num1);                // Push the result to the stack\n                    break;                                  // Break the case\n\n                case \"*\":                                   // If the operator is *\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num1 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num2 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    stack.Push(num2 * num1);                // Push the result to the stack\n                    break;                                  // Break the case\n\n                case \"/\":                                   // If the operator is /\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num1 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    if (stack.Count != 0)\n                    {                                       // If the stack is not empty\n                        num2 = stack.Pop();                 // Pop the top element from the stack\n                    }\n                    stack.Push(num2 / num1);                // Push the result to the stack\n                    break;                                  // Break the case\n\n                default:                                    // If the operator is an operand\n                    stack.Push(Int32.Parse(op));            // Push the operand to the stack\n                    break;                                  // Break the case\n            }                                               // End of switch\n\n        }\n        return stack.Peek();                                // Return the top element from the stack\n    }\n}"
    },
    {
      "problemNumber": "1512",
      "title": "Numberof Good Pairs",
      "language": "C#",
      "filename": "1512-NumberofGoodPairs.cs",
      "path": "LeetCode/C#/1512-NumberofGoodPairs.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1512-NumberofGoodPairs.cs",
      "approach": "1. Create a dictionary to store the frequency of each number.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a dictionary to store the frequency of each number.\n2. Iterate through the array and store the frequency of each number in the dictionary.\n3. Iterate through the dictionary and calculate the number of good pairs for each number.\n4. Return the sum of all the good pairs.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int NumIdenticalPairs(int[] nums) {\n        Dictionary<int,int> dict = new Dictionary<int,int>();           // To store the frequency of each number\n        int result = 0;                                                 // To store the number of good pairs\n\n        foreach(int num in nums) {                                      // Storing the frequency of each number in the dictionary\n            if(!dict.ContainsKey(num)) {                                // If the number is not present in the dictionary\n                dict[num] = 1;                                          // Add the number to the dictionary with frequency 1\n            }\n            else {\n                dict[num] = dict[num] + 1;                              // If the number is already present in the dictionary, increment the frequency\n            }\n        }\n\n        foreach(var kv in dict) {                                       // Calculating the number of good pairs for each number\n            result = result + (((kv.Value)*(kv.Value -1)) / 2);         // Number of good pairs for a number n is nC2 = n*(n-1)/2\n        }\n        return result;                                                  // Return the total number of good pairs\n    }\n}\n"
    },
    {
      "problemNumber": "1544",
      "title": "Make The String Great",
      "language": "C#",
      "filename": "1544-MakeTheStringGreat.cs",
      "path": "LeetCode/C#/1544-MakeTheStringGreat.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1544-MakeTheStringGreat.cs",
      "approach": "1. Create a stack to store the characters.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a stack to store the characters.\n2. Iterate through the string.\n3. If the stack is empty, push the current character to the stack.\n4. If the stack is not empty, peek the top character from the stack.\n5. If the current character is equal to the peeked character in uppercase, pop the peeked character from the stack.\n6. If the current character is not equal to the peeked character in uppercase, push the current character to the stack.\n7. After iterating through the string, pop all the characters from the stack and return the string.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    public string MakeGood(string s) {\n        Stack<char> stack  = new Stack<char>();                         // To store the characters\n        StringBuilder sb = new StringBuilder();                         // To store the final string\n        while(true) {                                                   // Loop until the string is not modified\n            for(int i = s.Length-1; i>=0; i--) {                        // Iterating through the string\n                stack.Push(s[i]);                                       // Push the character to the stack\n            }\n            while(stack.Count() != 0) {                                 // Pop all the characters from the stack\n                char popped = stack.Pop();                              // Pop the character from the stack\n                if(stack.Count() != 0) {                                // If the stack is not empty\n                    char peeked = stack.Peek();                         // Peek the top character from the stack\n                    if(IfBad(peeked, popped)) {                         // If the current character is equal to the peeked character in uppercase and vice versa\n                        popped = stack.Pop();                           // Pop the peeked character from the stack\n                        continue;                                       // Continue to the next character\n                    }\n                }\n                sb.Append(popped);                                      // Append the character to the final string\n            }\n            if(s.Equals(sb.ToString())) break;                          // If the string is not modified, break from the loop\n            s = sb.ToString();                                          // Update the string\n            stack.Clear();                                              // Clear the stack\n            sb.Clear();                                                 // Clear the final string\n        }\n        return s;                                                       // Return the final string\n    }\n\n    static bool IfBad(char a, char b) {\n        return (((int)a - '0') + 32) == ((int)b - '0') || (((int)b - '0') + 32) == ((int)a - '0') ; // Check if the characters are equal to each other in uppercase and vice versa\n    }\n}"
    },
    {
      "problemNumber": "1550",
      "title": "Three Consecutive Odds",
      "language": "C#",
      "filename": "1550-ThreeConsecutiveOdds.cs",
      "path": "LeetCode/C#/1550-ThreeConsecutiveOdds.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1550-ThreeConsecutiveOdds.cs",
      "approach": "Iterate array",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/three-consecutive-odds/post-solution/?submissionId=1630962333\nApproach: Iterate array\n1. Check if the current element and the next two elements are odd.\n2. If they are, return true.\n3. If no such triplet is found, return false.\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool ThreeConsecutiveOdds(int[] arr) {\n        int size = arr.Length;                                                  // Get the size of the array\n        if (size <=2)                                                           // If the size of the array is less than 3, return false\n            return false;                                                       // return false\n        for (int i=0; i<size-2; i++) {                                          // Iterate through the array\n            if (arr[i] % 2 != 0 && arr[i+1] % 2 != 0 && arr[i+2] % 2 != 0)      // Check if the current element and the next two elements are odd\n                return true;                                                    // If they are, return true\n        }\n        return false;                                                            // If no such triplet is found, return false\n    }\n}"
    },
    {
      "problemNumber": "1550",
      "title": "Three Consecutive Odds",
      "language": "Python",
      "filename": "1550-ThreeConsecutiveOdds.py",
      "path": "LeetCode/Python/1550-ThreeConsecutiveOdds.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/1550-ThreeConsecutiveOdds.py",
      "approach": "1. Initialize a variable `size` to the length of the input list `arr`.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n), where n is the length of the input list `arr`.",
      "spaceComplexity": "O(1), as we are using a constant amount of space.",
      "solutionLink": "",
      "code": "'''\nSolution: https://leetcode.com/problems/three-consecutive-odds/submissions/1630979353/?envType=daily-question&envId=2025-05-11\nApproach:\n1. Initialize a variable `size` to the length of the input list `arr`.\n2. If the size is less than or equal to 2, return False since it's impossible to have three consecutive odd numbers.\n3. Iterate through the list `arr` using a for loop, checking each triplet of consecutive elements.\n4. For each triplet, check if all three elements are odd (i.e., not divisible by 2).\n5. If a triplet of consecutive odd numbers is found, return True.\n6. If the loop completes without finding any triplet, return False.\n\nTime Complexity: O(n), where n is the length of the input list `arr`.\nSpace Complexity: O(1), as we are using a constant amount of space.\n'''\n\nclass Solution(object):\n    def threeConsecutiveOdds(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        size = len(arr)                                                         # Get the size of the array\n        if size <=2:                                                            # If size is less than or equal to 2, return False\n            return False                                                        # Since it's impossible to have three consecutive odds\n        for i in range(size - 2):                                               # Iterate through the array\n            if arr[i] % 2 != 0 and arr[i+1] % 2 != 0 and arr[i+2] % 2 != 0:     # Check if three consecutive numbers are odd\n                return True                                                     # If found, return True\n        return False                                                            # If no such triplet is found, return False"
    },
    {
      "problemNumber": "1572",
      "title": "Matrix Diagonal Sum",
      "language": "C#",
      "filename": "1572-MatrixDiagonalSum.cs",
      "path": "LeetCode/C#/1572-MatrixDiagonalSum.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1572-MatrixDiagonalSum.cs",
      "approach": "Iteration",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n), where n is the number of elements in the matrix.",
      "spaceComplexity": "O(1).",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/matrix-diagonal-sum/solutions/6559182/simplest-solution-c-time-on-space1-pleas-twxx/\nApproach: Iteration\n1. Initialize a variable sum to 0.\n2. Iterate through the matrix mat.\n3. Add the element at the index i and colIndex to sum.\n4. Decrement colIndex by 1.\n5. Repeat steps 3 and 4 until the end of the matrix.\n6. If the length of the matrix is odd, subtract the element at the index lengthOfMatrix/2 and lengthOfMatrix/2 from sum.\n7. Return sum.\n\nTime complexity: O(n), where n is the number of elements in the matrix.\nSpace complexity: O(1).\n*/\npublic class Solution {\n    public int DiagonalSum(int[][] mat) {\n        int lengthOfMatrix = mat.Length;                            // Get the length of the matrix.\n        int colIndex = lengthOfMatrix - 1;                          // Initialize the column index to the last column.\n        int sum = 0;                                                // Initialize a variable sum to 0.\n        for(int i=0; i<lengthOfMatrix; i++) {                       // Iterate through the matrix.\n            sum += mat[i][i];                                       // Add the element at the index i and i to sum.\n            sum += mat[i][colIndex];                                // Add the element at the index i and colIndex to sum.\n            colIndex--;                                             // Decrement colIndex by 1.\n        }\n        if (lengthOfMatrix % 2 != 0) {                              // If the length of the matrix is odd.\n            sum = sum - mat[lengthOfMatrix/2][lengthOfMatrix/2];    // Subtract the element at the index lengthOfMatrix/2 and lengthOfMatrix/2 from sum.\n        }\n        return sum;                                                 // Return sum.\n    }\n}"
    },
    {
      "problemNumber": "1581",
      "title": "Customer Who Visitedbut Did Not Make Any Transactions",
      "language": "SQL",
      "filename": "1581-CustomerWhoVisitedbutDidNotMakeAnyTransactions.sql",
      "path": "LeetCode/SQL/1581-CustomerWhoVisitedbutDidNotMakeAnyTransactions.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/1581-CustomerWhoVisitedbutDidNotMakeAnyTransactions.sql",
      "approach": "Left Join",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "-- Approach: Left Join\n-- 1. We need to join the visits and transactions tables on the basis of the visit_id column.\n-- 2. We can achieve this by using the left join keyword to join the two tables.\n-- 3. We need to specify the columns that we want to select from the tables.\n-- 4. We need to specify the condition on which we want to join the tables.\n-- 5. We need to filter out the rows where the transaction_id is null.\n-- 6. Group the results by the customer_id column.\n-- 7. Return the customer_id and the count of the number of transactions.\n\nselect v.customer_id, count(v.customer_id) as count_no_trans\nfrom visits as v\nleft join transactions as t\non v.visit_id = t.visit_id\nwhere transaction_id is null\ngroup by v.customer_id"
    },
    {
      "problemNumber": "1603",
      "title": "Design Parking System",
      "language": "C#",
      "filename": "1603-DesignParkingSystem.cs",
      "path": "LeetCode/C#/1603-DesignParkingSystem.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1603-DesignParkingSystem.cs",
      "approach": "- Create three variables to store the number of big, medium, and small cars.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n- Create three variables to store the number of big, medium, and small cars.\n- Create a constructor to initialize the number of big, medium, and small cars.\n- Create a method to add a car to the parking lot.\n- Check the car type and decrement the number of cars accordingly.\n- Return true if the car is added successfully, otherwise return false.\n\nTime complexity: O(1)\nSpace complexity: O(1)\n\n*/\npublic class ParkingSystem {\n\n    private int _numOfBigCars;\n    private int _numOfMediumCars;\n    private int _numOfSmallCars;\n\n\n\n    public ParkingSystem(int big, int medium, int small) {\n        _numOfBigCars = big;\n        _numOfMediumCars = medium;\n        _numOfSmallCars = small;\n    }\n\n\n    public bool AddCar(int carType) {\n\n        switch(carType) {\n            case 1:\n                if (_numOfBigCars > 0) {\n                        _numOfBigCars--;\n                        return true;\n                    }\n                else\n                    return false;\n            case 2:\n                if (_numOfMediumCars > 0) {\n                        _numOfMediumCars--;\n                        return true;\n                    }\n                else\n                    return false;\n            case 3:\n                if (_numOfSmallCars > 0) {\n                        _numOfSmallCars--;\n                        return true;\n                    }\n                else\n                    return false;\n        }\n\n        return false;\n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj.AddCar(carType);\n */"
    },
    {
      "problemNumber": "1624",
      "title": "Largest Substring Between Two Equal Characters",
      "language": "C#",
      "filename": "1624-LargestSubstringBetweenTwoEqualCharacters.cs",
      "path": "LeetCode/C#/1624-LargestSubstringBetweenTwoEqualCharacters.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1624-LargestSubstringBetweenTwoEqualCharacters.cs",
      "approach": "1. Create a dictionary to store the index of the first occurrence of a character.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a dictionary to store the index of the first occurrence of a character.\n2. Iterate through the string and check if the character is already present in the dictionary.\n3. If it is present, calculate the difference between the current index and the index of the first occurrence of the character.\n4. Update the result with the maximum difference.\n5. Return the result.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\npublic class Solution {\n    public int MaxLengthBetweenEqualCharacters(string s) {\n        Dictionary<char,int> dict = new Dictionary<char, int>();\n\n            int index, result;\n            index = 0;\n            result = -1;\n\n            while(index < s.Length) {\n\n                if(!dict.ContainsKey(s[index])) {\n                    dict[s[index]] = index;\n                }\n                else {\n                    result = Math.Max(index - dict[s[index]] - 1,result);\n                }\n                index++;\n            }\n            return result;\n    }\n}"
    },
    {
      "problemNumber": "1683",
      "title": "Invalid Tweets",
      "language": "SQL",
      "filename": "1683-InvalidTweets.sql",
      "path": "LeetCode/SQL/1683-InvalidTweets.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/1683-InvalidTweets.sql",
      "approach": "Select the tweet_id from the table where the length of the content is greater than 15",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "-- Approach: Select the tweet_id from the table where the length of the content is greater than 15\n-- 1. We need to select the tweet_id from the tweets table where the length of the content is greater than 15.\n-- 2. We can achieve this by using the select statement to select the tweet_id from the tweets table.\n-- 3. We need to filter the tweets based on the length of the content using the where clause.\n-- 4. We need to specify the condition where the length of the content is greater than 15.\n-- 5. Return the tweet_id.\nselect tweet_id from tweets where LENGTH(content) > 15"
    },
    {
      "problemNumber": "1700",
      "title": "Number Of Students Unable To Eat Lunch",
      "language": "C#",
      "filename": "1700-NumberOfStudentsUnableToEatLunch.cs",
      "path": "LeetCode/C#/1700-NumberOfStudentsUnableToEatLunch.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1700-NumberOfStudentsUnableToEatLunch.cs",
      "approach": "1. Create a dictionary to store the count of students with each preference.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n\n1. Create a dictionary to store the count of students with each preference.\n2. Iterate through the students array and store the count of students with each preference in the dictionary.\n3. Iterate through the sandwiches array and check if the sandwich preference is available in the dictionary and the count is greater than 0.\n4. If the sandwich preference is available and the count is greater than 0, decrement the count and decrement the result.\n5. If the sandwich preference is not available or the count is 0, return the result.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public int CountStudents(int[] students, int[] sandwiches) {\n        int result = students.Length;\n        Dictionary<int,int> dict = new Dictionary<int,int>();\n\n        foreach(int student in students) {\n            if(!dict.ContainsKey(student)) {\n                dict[student] = 1;\n            }\n            else {\n                dict[student] = dict[student] + 1;\n            }\n        }\n\n        foreach(int sandwich in sandwiches) {\n            if(dict.ContainsKey(sandwich) && dict[sandwich] > 0) {\n                dict[sandwich] = dict[sandwich] - 1;\n                result = result - 1;\n            }\n            else {\n                return result;\n            }\n        }\n\n        return result;\n    }\n}"
    },
    {
      "problemNumber": "1716",
      "title": "Calculate Moneyin Leetcode Bank",
      "language": "C#",
      "filename": "1716-CalculateMoneyinLeetcodeBank.cs",
      "path": "LeetCode/C#/1716-CalculateMoneyinLeetcodeBank.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1716-CalculateMoneyinLeetcodeBank.cs",
      "approach": "Mathematical Pattern Recognition and Arithmetic Sequence",
      "tags": [
        "Math",
        "Arithmetic Sequence",
        "Pattern Recognition"
      ],
      "steps": [
        "1) If n <= 7, use simple arithmetic sequence formula for first week.",
        "2) Calculate complete weeks (q) and remaining days (r).",
        "3) For complete weeks: each week adds 7 more than previous (28, 35, 42...).",
        "4) For remaining days: start from (1 + q) and form arithmetic sequence.",
        "5) Sum complete weeks contribution and remaining days contribution."
      ],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/calculate-money-in-leetcode-bank/solutions/7299967/simplest-solution-c-time-o1-space1-pleas-4dlh/\nApproach: Mathematical Pattern Recognition and Arithmetic Sequence\nTags: Math, Arithmetic Sequence, Pattern Recognition\n1) If n <= 7, use simple arithmetic sequence formula for first week.\n2) Calculate complete weeks (q) and remaining days (r).\n3) For complete weeks: each week adds 7 more than previous (28, 35, 42...).\n4) For remaining days: start from (1 + q) and form arithmetic sequence.\n5) Sum complete weeks contribution and remaining days contribution.\n\nTime Complexity: O(1)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int TotalMoney(int n) {\n        if (n <= 7) {                                           // If within first week\n            return n * (n + 1) / 2;                            // Simple arithmetic sequence: 1+2+...+n\n        } else {\n            int q = n / 7;                                      // Number of complete weeks\n            int r = n % 7;                                      // Remaining days after complete weeks\n            int a = 1 + q;                                      // First day amount in the remaining week\n            int l = a + (r - 1);                               // Last day amount in remaining days\n\n            // total = full weeks + remaining days\n            return (28 * q) + (7 * q * (q - 1)) / 2 + (r * (a + l)) / 2;  // Sum of complete weeks + remaining days\n        }\n    }\n}\n"
    },
    {
      "problemNumber": "1752",
      "title": "Checkif Array Is Sortedand Rotated",
      "language": "C#",
      "filename": "1752-CheckifArrayIsSortedandRotated.cs",
      "path": "LeetCode/C#/1752-CheckifArrayIsSortedandRotated.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1752-CheckifArrayIsSortedandRotated.cs",
      "approach": "1. Initialize peekFound to false.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Initialize peekFound to false.\n2. Iterate through the array from 0 to n-2.\n3. If the current element is greater than the next element, check if peekFound is false.\n4. If peekFound is false, set peekFound to true.\n5. If peekFound is true, return false.\n6. If peekFound is true and the last element is greater than the first element, return false.\n7. Return true.\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool Check(int[] nums) {\n        bool peekFound = false;                             //  Initializing peekFound to false\n        for(int i=0; i<nums.Length-1; i++) {                //  Iterating through the array from 0 to n-2\n            if(nums[i] > nums[i+1]) {                       //  If the current element is greater than the next element\n                if(peekFound == false)                      //  Check if peekFound is false\n                    peekFound = true;                       //  If peekFound is false, set peekFound to true\n                else\n                    return false;                           //  If peekFound is true, return false\n            }\n        }\n        if(peekFound && nums[nums.Length-1] > nums[0]) {    //  If peekFound is true and the last element is greater than the first element\n            return false;                                   //  Return false\n        }\n        return true;                                        //  Return true\n    }\n}"
    },
    {
      "problemNumber": "1757",
      "title": "Recyclableand Low Fat Products",
      "language": "SQL",
      "filename": "1757-RecyclableandLowFatProducts.sql",
      "path": "LeetCode/SQL/1757-RecyclableandLowFatProducts.sql",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/SQL/1757-RecyclableandLowFatProducts.sql",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/6186285/simplest-solution-sql-please-upvote-by-v-ksgl/",
      "code": "-- https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/6186285/simplest-solution-sql-please-upvote-by-v-ksgl/\n-- Query all columns of the products table that have low_fats and recyclable.\n-- Return the result table in any order.\nselect product_id from products where low_fats='y' and recyclable='y'\n"
    },
    {
      "problemNumber": "1758",
      "title": "Minimum Changes To Make Alternative Binary String",
      "language": "C#",
      "filename": "1758-MinimumChangesToMakeAlternativeBinaryString.cs",
      "path": "LeetCode/C#/1758-MinimumChangesToMakeAlternativeBinaryString.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1758-MinimumChangesToMakeAlternativeBinaryString.cs",
      "approach": "1. We will start from 0 and 1 and will check how many changes are required to make string alternative.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We will start from 0 and 1 and will check how many changes are required to make string alternative.\n2. We will take minimum of two strings as alternative string can start from 0 or 1.\n3. We will keep track of next expected character and will check if current character is same as next expected character.\n4. If not, we will increment result and will update current character to next expected character.\n5. We will update next expected character to opposite of current character.\n6. We will return minimum of two strings.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public int MinOperations(string s) {\n        char nextExpectedChar = '1';\n            char currentChar = '\\0';\n            int index = 1;\n            int result = 0;\n\n            if (s[0] != '0') {\n                nextExpectedChar = '0';\n            }\n\n            while(index < s.Length) {\n\n                currentChar = s[index];\n\n                if(currentChar != nextExpectedChar) {\n                    result++;\n                    currentChar = nextExpectedChar;\n                }\n\n                nextExpectedChar = currentChar == '0' ? '1' : '0';\n                index++;\n            }\n\n            // As alternative string can start from 0 or 1, we will take minimum of two strings\n            // if result is for 0. s.Length - result will be for 1.\n            return Math.Min(s.Length - result ,result);\n    }\n}"
    },
    {
      "problemNumber": "1768",
      "title": "Merge Strings Alternately",
      "language": "C#",
      "filename": "1768-MergeStringsAlternately.cs",
      "path": "LeetCode/C#/1768-MergeStringsAlternately.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1768-MergeStringsAlternately.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public string MergeAlternately(string word1, string word2) {\n\n        int lsb = word1.Length > word2.Length ? word1.Length : word2.Length;\n        int index = 0;\n        StringBuilder sb = new StringBuilder();\n\n        while(index < lsb) {\n\n            if (index < word1.Length) sb.Append(word1[index]);\n            if (index < word2.Length) sb.Append(word2[index]);\n\n            index++;\n        }\n\n        return sb.ToString();\n\n    }\n}\n\n"
    },
    {
      "problemNumber": "1822",
      "title": "Signofthe Productofan Array",
      "language": "C#",
      "filename": "1822-SignoftheProductofanArray.cs",
      "path": "LeetCode/C#/1822-SignoftheProductofanArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1822-SignoftheProductofanArray.cs",
      "approach": "1. Initialize a variable to store the number of negative numbers in the array.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Initialize a variable to store the number of negative numbers in the array.\n2. Iterate through the array and for each number, check if it is negative.\n3. If the number is negative, increment the count of negative numbers.\n4. If the number is zero, return 0.\n5. If the count of negative numbers is even, return 1.\n6. Otherwise, return -1.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n*/\npublic class Solution {\n    public int ArraySign(int[] nums) {\n        int numOfNegNums = 0;\n\n        foreach(int num in nums) {\n            if (num < 0) numOfNegNums++;\n            if (num == 0) return 0;\n        }\n\n        return numOfNegNums % 2 == 0 ? 1 : -1;\n    }\n}"
    },
    {
      "problemNumber": "1897",
      "title": "Redistribute Characters To Make All Strings Equal",
      "language": "C#",
      "filename": "1897-RedistributeCharactersToMakeAllStringsEqual.cs",
      "path": "LeetCode/C#/1897-RedistributeCharactersToMakeAllStringsEqual.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1897-RedistributeCharactersToMakeAllStringsEqual.cs",
      "approach": "1. Create a dictionary to store the frequency of each character in the words array.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n*m)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a dictionary to store the frequency of each character in the words array.\n2. Iterate through the words array and calculate the frequency of each character.\n3. If the frequency of any character is not divisible by the length of the words array, return false.\n4. If all characters have a frequency divisible by the length of the words array, return true.\n\nTime complexity: O(n*m)\nSpace complexity: O(n)\nwhere n is the number of words in the array and m is the average length of the words.\n\n\n*/\npublic class Solution {\n    public bool MakeEqual(string[] words) {\n        Dictionary<char,int> dict = new Dictionary<char, int>();\n\n            foreach (string word in words) {\n\n                foreach(char ch in word) {\n\n                    if (dict.ContainsKey(ch)) {\n                        dict[ch] = dict[ch] + 1;\n                    }\n                    else {\n                        dict.Add(ch,1);\n                    }\n                }\n            }\n\n            foreach(var kv in dict) {\n                if (kv.Value % words.Length  !=  0)\n                    return false;\n            }\n\n            return true;\n    }\n}"
    },
    {
      "problemNumber": "1903",
      "title": "Largest Odd Number In String",
      "language": "C#",
      "filename": "1903-LargestOddNumberInString.cs",
      "path": "LeetCode/C#/1903-LargestOddNumberInString.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1903-LargestOddNumberInString.cs",
      "approach": "1. Start from the end of the string and check if the number is odd or even.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Start from the end of the string and check if the number is odd or even.\n2. If the number is even or 0, remove it from the string.\n3. If the number is odd, return the string.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public string LargestOddNumber(string num) {\n\n        int index = num.Length - 1;                                      // Start from the end of the string\n        int removals = 0;                                                // Number of removals\n        while (index >= 0) {                                             // Iterate through the string\n             if((num[index] - '0') % 2 == 0) {                           // If the number is even\n                removals++;                                              // Remove the number\n                index--;                                                 // Move to the next number\n            }\n            else {\n                break;                                                   // If the number is odd, break the loop\n            }\n        }\n        return num.Substring(0,num.Length - removals);                   // Return the string after removing the even numbers\n    }\n}"
    },
    {
      "problemNumber": "1911",
      "title": "Maximum Alternating Subsequence Sum",
      "language": "C#",
      "filename": "1911-MaximumAlternatingSubsequenceSum.cs",
      "path": "LeetCode/C#/1911-MaximumAlternatingSubsequenceSum.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1911-MaximumAlternatingSubsequenceSum.cs",
      "approach": "Recursion with memoization",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach: Recursion with memoization\n1. We can either take the current element or skip it.\n2. If we take the current element, we need to check if we have taken the previous element or not.\n3. If we have taken the previous element, then we need to skip the current element.\n4. If we have not taken the previous element, then we can take the current element.\n5. We can use a flag to keep track of whether we have taken the previous element or not.\n6. We can use a 2D array to store the maximum sum we can get starting from the ith element and whether we have taken the previous element or not.\n7. If we have already calculated the maximum sum starting from the ith element and whether we have taken the previous element or not, then we can return it.\n8. Otherwise, we can calculate the maximum sum starting from the ith element and whether we have taken the previous element or not.\n9. If we have taken the current element, then we need to skip the next element.\n10. If we have not taken the current element, then we can take the next element.\n11. We can return the maximum of the two.\n12. We can keep track of the maximum sum we can get starting from the 0th element and whether we have taken the previous element or not.\n13. We can return the maximum sum starting from the 0th element and whether we have taken the previous element or not.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    long[,] dp = new long[100001,2];                                // 2D array to store the maximum sum we can get starting from the ith element and whether we have taken the previous element or not.\n    int n = 0;                                                      // Length of the input array\n\n    public long MaxAlternatingSum(int[] nums) {                     // Function to get the maximum alternating subsequence sum\n        n = nums.Length;                                            // Length of the input array\n        for(int i=0; i<100001; i++) {                               // Initialize the 2D array with -1\n            for (int j=0; j<2; j++) {                               // Initialize the 2D array with -1\n                dp[i,j] = -1;                                       // Initialize the 2D array with -1\n            }\n        }\n        return AlternatingSum(nums, true, 0);                       // Return the maximum sum starting from the 0th element and whether we have taken the previous element or not.\n    }\n\n    public long AlternatingSum(int[] nums, bool flag, int i) {\n\n        if(i >= n) {                                                // If the index is greater than or equal to the length of the input array, then return 0\n            return 0;                                               // If the index is greater than or equal to the length of the input array, then return 0\n        }\n\n        int flagBit = flag ? 1 : 0;                                 // If the flag is true, then set the flagBit to 1, otherwise set the flagBit to 0\n        if(dp[i,flagBit] != -1) {                                   // If we have already calculated the maximum sum starting from the ith element and whether we have taken the previous element or not, then return it\n            return dp[i,flagBit];                                   // If we have already calculated the maximum sum starting from the ith element and whether we have taken the previous element or not, then return it\n        }\n\n        long valToTake = nums[i];                                   // Value to take\n        if(!flag) valToTake = -valToTake;                           // If we have not taken the previous element, then set the value to take to -value to take\n        long skip = AlternatingSum(nums, flag, i+1);                // Skip the current element\n        long take = valToTake + AlternatingSum(nums, !flag, i+1);   // Take the current element\n        return dp[i,flagBit] = Math.Max(take, skip);                // Return the maximum of the two\n    }\n\n}\n/*\nApproach: Iterative approach (Bottom-up)\n*/"
    },
    {
      "problemNumber": "1913",
      "title": "Maximum Product Difference Between Two Pairs",
      "language": "C#",
      "filename": "1913-MaximumProductDifferenceBetweenTwoPairs.cs",
      "path": "LeetCode/C#/1913-MaximumProductDifferenceBetweenTwoPairs.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1913-MaximumProductDifferenceBetweenTwoPairs.cs",
      "approach": "1. Initialize max1, max2, min1, min2 to int.MinValue and int.MaxValue respectively.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Initialize max1, max2, min1, min2 to int.MinValue and int.MaxValue respectively.\n2. Iterate through the array.\n3. If the current number is greater than max2, update max2.\n4. If the current number is greater than max1, update max2 to max1 and max1 to the current number.\n5. If the current number is less than min2, update min2.\n6. If the current number is less than min1, update min2 to min1 and min1 to the current number.\n7. Return the difference between the product of max1 and max2 and the product of min1 and min2.\n\nTime complexity: O(n)\nSpace complexity: O(1)\nwhere n is the number of elements in the array.\n\n\n*/\npublic class Solution {\n    public int MaxProductDifference(int[] nums) {\n         int max1, max2, min1, min2, index,currentNumber;\n            max1 = max2 = int.MinValue;\n            min1 = min2 = int.MaxValue;\n            index = 0;\n\n            while (index < nums.Length) {\n\n                currentNumber = nums[index];\n\n                if (currentNumber > max2) {\n                    max2 = currentNumber;\n                }\n\n                if(currentNumber > max1) {\n                    max2 = max1;\n                    max1 = currentNumber;\n                }\n\n                if(currentNumber < min2) {\n                    min2 = currentNumber;\n                }\n\n                if(currentNumber < min1) {\n                    min2 = min1;\n                    min1 = currentNumber;\n                }\n\n                index++;\n\n            }\n\n            return (max1 * max2) - (min1 * min2);\n    }\n}"
    },
    {
      "problemNumber": "1929",
      "title": "Concatenationof Array",
      "language": "C#",
      "filename": "1929-ConcatenationofArray.cs",
      "path": "LeetCode/C#/1929-ConcatenationofArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1929-ConcatenationofArray.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "public class Solution {\n    public int[] GetConcatenation(int[] nums) {\n        \n        int[] conArray = new int[nums.Length*2];\n\n        for(int i=0;i<nums.Length;i++) {\n            conArray[i] = nums[i];\n        }\n\n         for(int i=nums.Length;i<nums.Length*2;i++) {\n            conArray[i] = nums[i - nums.Length];\n        }\n\n        return conArray;\n    }\n}\n"
    },
    {
      "problemNumber": "1935",
      "title": "Maximum Numberof Words You Can Type",
      "language": "C#",
      "filename": "1935-MaximumNumberofWordsYouCanType.cs",
      "path": "LeetCode/C#/1935-MaximumNumberofWordsYouCanType.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1935-MaximumNumberofWordsYouCanType.cs",
      "approach": "Track broken letters and check each word",
      "tags": [
        "String",
        "Array",
        "Simulation"
      ],
      "steps": [
        "1) Mark all broken letters in a boolean array.",
        "2) Iterate through each character in the text.",
        "3) For each word, check if it contains any broken letter.",
        "4) If a word can be typed (no broken letter), increment the result.",
        "5) Return the total count of typeable words."
      ],
      "timeComplexity": "O(n + m) where n = text.Length, m = brokenLetters.Length",
      "spaceComplexity": "O(1) - fixed size array for 26 letters",
      "solutionLink": "",
      "code": "/*\nSolution: Count Words That Can Be Typed\nApproach: Track broken letters and check each word\nTags: String, Array, Simulation\n1) Mark all broken letters in a boolean array.\n2) Iterate through each character in the text.\n3) For each word, check if it contains any broken letter.\n4) If a word can be typed (no broken letter), increment the result.\n5) Return the total count of typeable words.\n\nTime Complexity: O(n + m) where n = text.Length, m = brokenLetters.Length\nSpace Complexity: O(1) - fixed size array for 26 letters\n*/\npublic class Solution {\n    public int CanBeTypedWords(string text, string brokenLetters) {\n        bool[] brokenChars = new bool[26];                // Tracks which letters are broken\n        int result = 0;                                   // Counts typeable words\n        bool canType = true;                              // Flag for current word typeability\n\n        foreach (char c in brokenLetters) {               // Mark broken letters\n            brokenChars[c - 'a'] = true;\n        }\n\n        for (int i = 0; i < text.Length; i++) {           // Iterate through text\n            char currentChar = text[i];\n            if (currentChar == ' ') {                     // End of a word\n                if (canType) result++;                    // If word can be typed, increment result\n                canType = true;                           // Reset for next word\n            }\n            else {\n                if (brokenChars[currentChar - 'a'])       // If current char is broken\n                    canType = false;                      // Mark word as untypeable\n            }\n        }\n        if (canType) result++;                            // Check last word\n        return result;                                    // Return total typeable words\n    }\n}"
    },
    {
      "problemNumber": "1963",
      "title": "Minimum Numberof Swapsto Makethe String Balanced",
      "language": "C#",
      "filename": "1963-MinimumNumberofSwapstoMaketheStringBalanced.cs",
      "path": "LeetCode/C#/1963-MinimumNumberofSwapstoMaketheStringBalanced.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1963-MinimumNumberofSwapstoMaketheStringBalanced.cs",
      "approach": "1. Initialize maxNumberOfClosingBrackets, currentNumberOfClosingBrackets to 0.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Initialize maxNumberOfClosingBrackets, currentNumberOfClosingBrackets to 0.\n2. Iterate through the string.\n3. If the current character is ']', increment currentNumberOfClosingBrackets.\n4. Else, decrement currentNumberOfClosingBrackets.\n5. Update maxNumberOfClosingBrackets to the maximum of maxNumberOfClosingBrackets and currentNumberOfClosingBrackets.\n6. Return (maxNumberOfClosingBrackets+1)/2.\n7. The reason for adding 1 to maxNumberOfClosingBrackets is that we need to consider the extra closing bracket that will close the brackets.\n\nTime complexity: O(n)\nSpace complexity: O(1)\nwhere n is the length of the string.\n\n\n*/\npublic class Solution {\n    public int MinSwaps(string s) {\n        int maxNumberOfClosingBrackets = 0;\n        int currentNumberOfClosingBrackets = 0;\n        foreach(char c in s) {\n            if(c==']') {\n                currentNumberOfClosingBrackets++;\n            }\n            else {\n                currentNumberOfClosingBrackets--;\n            }\n            maxNumberOfClosingBrackets = Math.Max(maxNumberOfClosingBrackets,currentNumberOfClosingBrackets);\n        }\n        return (maxNumberOfClosingBrackets+1)/2;                                                                // div by 2 bcoz 1 extra bracket will close 2 brackets.\n    }\n}"
    },
    {
      "problemNumber": "1984",
      "title": "Minimum Difference Between Highestand Lowestof K Scores",
      "language": "C#",
      "filename": "1984-MinimumDifferenceBetweenHighestandLowestofKScores.cs",
      "path": "LeetCode/C#/1984-MinimumDifferenceBetweenHighestandLowestofKScores.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/1984-MinimumDifferenceBetweenHighestandLowestofKScores.cs",
      "approach": "1. Sort the array",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(nlogn) + O(n) = O(nlogn)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Sort the array\n2. Take a window of size k and find the difference between the last and first element of the window\n3. Keep track of the minimum difference\n4. Move the window by 1 and repeat the process\n5. Return the minimum difference\n\nTime complexity: O(nlogn) + O(n) = O(nlogn)\nSpace complexity: O(1)\n\n*/\npublic class Solution {\n    public int MinimumDifference(int[] nums, int k) {\n        Array.Sort(nums);                                           // Sort the array\n        int i = 0;                                                  // Initialize the window\n        int j = i + k - 1;                                          // Initialize the window\n        int res = int.MaxValue;                                     // Initialize the result\n\n        while (j < nums.Length) {                                   // Iterate through the array\n            res = Math.Min(res,nums[j] - nums[i]);                  // Find the difference between the last and first element of the window and update the result\n            i++;                                                    // Move the window by 1\n            j++;                                                    // Move the window by 1\n        }\n        \n        return res;\n    }\n}"
    },
    {
      "problemNumber": "1984",
      "title": "Minimum Difference Between Highestand Lowestof K Scores",
      "language": "Go",
      "filename": "1984-MinimumDifferenceBetweenHighestandLowestofKScores.go",
      "path": "LeetCode/Go/1984-MinimumDifferenceBetweenHighestandLowestofKScores.go",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Go/1984-MinimumDifferenceBetweenHighestandLowestofKScores.go",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "func minimumDifference(nums []int, k int) int {\n    sort.Ints(nums)                          // Sort the array\n\ti := 0                                   // Initialize the window\n\tj := i + k - 1                           // Initialize the window\n\tres := math.MaxInt32                     // Initialize the result\n\n\tfor j < len(nums) {                      // Iterate through the array\n\t\tres = int(math.Min(float64(res), float64(nums[j]-nums[i]))) // Find the difference and update the result\n\t\ti++                                   // Move the window by 1\n\t\tj++                                   // Move the window by 1\n\t}\n\n\treturn res\n}"
    },
    {
      "problemNumber": "1984",
      "title": "Minimum Difference Between Highestand Lowestof K Scores",
      "language": "JavaScript",
      "filename": "1984-MinimumDifferenceBetweenHighestandLowestofKScores.js",
      "path": "LeetCode/JavaScript/1984-MinimumDifferenceBetweenHighestandLowestofKScores.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/1984-MinimumDifferenceBetweenHighestandLowestofKScores.js",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumDifference = function(nums, k) {\n    nums.sort((a, b) => a - b);                                // Sort the array\n     let i = 0;                                                // Initialize the window\n     let j = i + k - 1;                                        // Initialize the window\n     let res = Number.MAX_VALUE;                               // Initialize the result\n\n     while (j < nums.length) {                                 // Iterate through the array\n         res = Math.min(res, nums[j] - nums[i]);               // Find the difference between the last and first element of the window and update the result\n         i++;                                                  // Move the window by 1\n         j++;                                                  // Move the window by 1\n     }\n\n     return res;\n};"
    },
    {
      "problemNumber": "2001",
      "title": "Numberof Pairsof Interchangeable Rectangles",
      "language": "C#",
      "filename": "2001-NumberofPairsofInterchangeableRectangles.cs",
      "path": "LeetCode/C#/2001-NumberofPairsofInterchangeableRectangles.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2001-NumberofPairsofInterchangeableRectangles.cs",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nSolution:\n1. We need to find the number of pairs of interchangeable rectangles.\n2. Two rectangles are interchangeable if they have the same ratio of width to height.\n3. So, we need to find the ratio of width to height for each rectangle and store it in a dictionary.\n4. Then, we need to find the number of pairs of rectangles with the same ratio.\n5. If the number of rectangles with the same ratio is n, then the number of pairs of rectangles with the same ratio is nC2 = (n*(n-1))/2.\n6. We need to calculate the number of pairs of rectangles with the same ratio for all ratios and return the result.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n\n*/\npublic class Solution {\n    public long InterchangeableRectangles(int[][] rectangles) {\n\n        Dictionary<double,int> dict = new Dictionary<double,int>();\n        long result = 0;\n        foreach(var arr in rectangles) {\n            double ratio = (double)arr[0]/(double)arr[1];\n            if(!dict.ContainsKey(ratio)) {\n                dict[ratio] = 1;\n            }\n            else {\n                dict[ratio] = dict[ratio] + 1;\n            }\n        }\n\n        foreach(var kv in dict) {\n            if(kv.Value >= 2) {\n                long tempMul = (long)(kv.Value)*(kv.Value-1);       // This Multiplication is huge hence calculating separately to store in long\n                result = result + (tempMul/2);                      // nC2 = (n*(n-1))/2\n            }\n        }\n\n        return result;\n    }\n}"
    },
    {
      "problemNumber": "2016",
      "title": "Maximum Difference Between Increasing Elements",
      "language": "C#",
      "filename": "2016-MaximumDifferenceBetweenIncreasingElements.cs",
      "path": "LeetCode/C#/2016-MaximumDifferenceBetweenIncreasingElements.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2016-MaximumDifferenceBetweenIncreasingElements.cs",
      "approach": "Two Pointers",
      "tags": [],
      "steps": [
        "1) Initialize two pointers: `minPosition` at the start and `maxPosition` at the second element.",
        "2) Iterate through the array with `maxPosition`:",
        "3) Continue until `maxPosition` reaches the end of the array.",
        "4) Return `maxDiff`."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/maximum-difference-between-increasing-elements/solutions/6852841/simplest-solution-c-time-on-space1-pleas-j7tq/\nApproach: Two Pointers\n1) Initialize two pointers: `minPosition` at the start and `maxPosition` at the second element.\n2) Iterate through the array with `maxPosition`:\n   - If the current element at `maxPosition` is greater than the element at `minPosition`, calculate the difference and update `maxDiff` if this difference is greater than the current `maxDiff`.\n   - If the current element at `maxPosition` is not greater, move `minPosition` to `maxPosition`.\n3) Continue until `maxPosition` reaches the end of the array.\n4) Return `maxDiff`.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution\n{\n    public int MaximumDifference(int[] nums)\n    {\n        int minPosition = 0;                                                             // Start with the first element as the minimum position\n        int maxPosition = 1;                                                             // Start with the second element as the maximum position\n        int maxDiff = -1;                                                                // Initialize maxDiff to -1, indicating no valid difference found yet\n        while (maxPosition < nums.Length)                                                // Iterate through the array until maxPosition reaches the end\n        {\n            if (nums[maxPosition] > nums[minPosition])                                   // If the current element at maxPosition is greater than the element at minPosition\n            {\n                maxDiff = Math.Max(maxDiff, nums[maxPosition] - nums[minPosition]);      // Calculate the difference and update maxDiff if it's greater than the current maxDiff\n            }\n            else\n            {\n                minPosition = maxPosition;                                               // If the current element is not greater, move minPosition to maxPosition\n            }\n            maxPosition++;                                                               // Move to the next element\n        }\n        return maxDiff;                                                                  // Return the maximum difference found, or -1 if no valid difference was found\n    }\n}"
    },
    {
      "problemNumber": "2043",
      "title": "Simple Bank System",
      "language": "C#",
      "filename": "2043-SimpleBankSystem.cs",
      "path": "LeetCode/C#/2043-SimpleBankSystem.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2043-SimpleBankSystem.cs",
      "approach": "Object-Oriented Design with Balance Management",
      "tags": [
        "Design",
        "Array",
        "Simulation",
        "OOP"
      ],
      "steps": [
        "1) Store account balances in a list for easy access and modification.",
        "2) Implement transfer operation with validation for both accounts and sufficient funds.",
        "3) Implement deposit operation with account validation.",
        "4) Implement withdrawal operation with account validation and sufficient funds check.",
        "5) Use helper method to validate account numbers (1-indexed to n)."
      ],
      "timeComplexity": "O(1) for all operations",
      "spaceComplexity": "O(n) where n is number of accounts",
      "solutionLink": "",
      "code": "/*\nSolution: Simple Bank System Implementation\nApproach: Object-Oriented Design with Balance Management\nTags: Design, Array, Simulation, OOP\n1) Store account balances in a list for easy access and modification.\n2) Implement transfer operation with validation for both accounts and sufficient funds.\n3) Implement deposit operation with account validation.\n4) Implement withdrawal operation with account validation and sufficient funds check.\n5) Use helper method to validate account numbers (1-indexed to n).\n\nTime Complexity: O(1) for all operations\nSpace Complexity: O(n) where n is number of accounts\n*/\npublic class Bank\n{\n    private readonly List<long> _balances;                      // Store account balances (0-indexed internally)\n\n    public Bank(long[] balance)\n    {\n        _balances = new List<long>(balance);                    // Initialize balances from input array\n    }\n\n    public bool Transfer(int account1, int account2, long money)\n    {\n        if (IsValidAccount(account1) && IsValidAccount(account2) && _balances[account1 - 1] >= money)  // Validate accounts and sufficient funds\n        {\n            _balances[account1 - 1] -= money;                   // Deduct money from source account\n            _balances[account2 - 1] += money;                   // Add money to destination account\n            return true;                                        // Transfer successful\n        }\n\n        return false;                                           // Transfer failed due to invalid account or insufficient funds\n    }\n\n    public bool Deposit(int account, long money)\n    {\n        if (IsValidAccount(account))                            // Validate account number\n        {\n            _balances[account - 1] += money;                    // Add money to account (convert to 0-indexed)\n            return true;                                        // Deposit successful\n        }\n\n        return false;                                           // Deposit failed due to invalid account\n    }\n\n    public bool Withdraw(int account, long money)\n    {\n        if (IsValidAccount(account) && _balances[account - 1] >= money)  // Validate account and sufficient funds\n        {\n            _balances[account - 1] -= money;                    // Deduct money from account (convert to 0-indexed)\n            return true;                                        // Withdrawal successful\n        }\n\n        return false;                                           // Withdrawal failed due to invalid account or insufficient funds\n    }\n\n    private bool IsValidAccount(int account)\n    {\n        return account > 0 && account <= _balances.Count;       // Check if account number is within valid range (1 to n)\n    }\n}\n"
    },
    {
      "problemNumber": "2053",
      "title": "Kth Distinct Stringinan Array",
      "language": "C#",
      "filename": "2053-KthDistinctStringinanArray.cs",
      "path": "LeetCode/C#/2053-KthDistinctStringinanArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2053-KthDistinctStringinanArray.cs",
      "approach": "Using Dictionary",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n), where n is the length of the array.",
      "spaceComplexity": "O(n), for the dictionary to store counts.",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/kth-distinct-string-in-an-array/solutions/6886598/simplest-solution-c-time-on-spacen-pleas-kfpg/\nApproach: Using Dictionary\n1. Create a dictionary to count occurrences of each string in the array.\n2. Iterate through the array and populate the dictionary with counts.\n3. Iterate through the array again, checking the counts in the dictionary.\n4. If the count is 1, increment an index counter.\n5. If the index counter matches k, return the current string.\n6. If no such string exists, return an empty string.\n\nTime Complexity: O(n), where n is the length of the array.\nSpace Complexity: O(n), for the dictionary to store counts.\n*/\npublic class Solution\n{\n    public string KthDistinct(string[] arr, int k)\n    {\n        Dictionary<string, int> dict = new Dictionary<string, int>(); // Dictionary to store string counts\n        int index = 0;                                                // Index to track the k-th distinct string\n\n        foreach (string str in arr)                                   // Iterate through the array to count occurrences\n        {\n            if (!dict.ContainsKey(str))                               // If the string is not in the dictionary\n            {\n                dict[str] = 1;                                        // Add it with a count of 1\n            }\n            else                                                      // If the string is already in the dictionary\n            {\n                dict[str] = dict[str] + 1;                            // Increment its count\n            }\n        }\n\n        foreach (string str in arr)                                   // Iterate through the array again\n        {\n            if (dict[str] > 1)                                        // Check if the count is greater than 1\n            {\n                continue;                                             // If it is, skip to the next string\n            }\n            else                                                      // If the string is already in the dictionary\n            {\n                index++;                                              // Increment the index counter\n            }\n\n            if (index == k) return str;                               // If the index matches k, return the current string\n        }\n\n        return \"\";                                                    // If no k-th distinct string is found, return an empty string\n    }\n}"
    },
    {
      "problemNumber": "2073",
      "title": "Time Needed To Buy Tickets",
      "language": "C#",
      "filename": "2073-TimeNeededToBuyTickets.cs",
      "path": "LeetCode/C#/2073-TimeNeededToBuyTickets.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2073-TimeNeededToBuyTickets.cs",
      "approach": "1. We will keep on buying tickets from the first shop till we have enough tickets from the kth shop.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We will keep on buying tickets from the first shop till we have enough tickets from the kth shop.\nSimulation Technique is used here.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\n\npublic class Solution {\n    public int TimeRequiredToBuy(int[] tickets, int k) {\n\n        int index = 0;\n        int result = 0 ;\n        while (tickets[k] != 0) {\n            if (tickets[index] != 0) {\n                tickets[index] = tickets[index] - 1;\n                result++;\n            }\n            if(index == tickets.Length - 1)\n                index = 0;\n            else\n                index++;\n        }\n\n        return result;\n    }\n}\n\n/*\n\nApproach:\n1. Loop through the tickets array and check if the number of tickets in the current shop is less than the number of tickets in the kth shop.\n2. If yes, then buy all the tickets from the current shop.\n3. If no, then buy all the tickets from the kth shop.\n4. If the current shop is after the kth shop, then buy all the tickets from the kth shop - 1.\n5. If the current shop is before the kth shop, then buy all the tickets from the kth shop.\n6. Return the total number of tickets bought.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\n\npublic class Solution {\n    public int TimeRequiredToBuy(int[] tickets, int k) {\n\n        int index = 0;\n        int result = 0;\n\n        while (index < tickets.Length) {\n            if(tickets[index] < tickets[k]) {\n                result = result + tickets[index];\n            }\n            else {\n                if(index > k) {\n                    result = result + tickets[k] - 1;\n                }\n                else {\n                    result = result + tickets[k];\n                }\n            }\n\n            index++;\n        }\n\n        return result;\n    }\n}\n"
    },
    {
      "problemNumber": "2124",
      "title": "Checkif All As Appears Before All Bs",
      "language": "C#",
      "filename": "2124-CheckifAllAsAppearsBeforeAllBs.cs",
      "path": "LeetCode/C#/2124-CheckifAllAsAppearsBeforeAllBs.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2124-CheckifAllAsAppearsBeforeAllBs.cs",
      "approach": "1. Start from the beginning of the string and check if 'b' is found for the first time.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Start from the beginning of the string and check if 'b' is found for the first time.\n2. If 'b' is found for the first time, set the flag to true.\n3. If once 'b' is found, check if all the characters are 'b'. If not, return false.\n4. return true if all 'b's are found after the first 'b'.\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool CheckString(string s) {\n        bool bFound = false;                                    // Flag to check if 'b' is found\n        foreach(char ch in s) {                                 // Iterate through the string\n            if(ch == 'b' && bFound == false) {                  // If 'b' is found for the first time\n                bFound = true;                                  // Set the flag to true\n                continue;                                       // Continue to the next character\n            }\n            if(bFound && ch !='b')                              // If 'b' is found and a character other than 'b' is found\n                return false;                                   // Return false\n        }\n        return true;                                            // Return true if all 'b's are found after the first 'b'\n    }\n}"
    },
    {
      "problemNumber": "2154",
      "title": "Keep Multiplying Found Valuesby Two",
      "language": "C#",
      "filename": "2154-KeepMultiplyingFoundValuesbyTwo.cs",
      "path": "LeetCode/C#/2154-KeepMultiplyingFoundValuesbyTwo.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2154-KeepMultiplyingFoundValuesbyTwo.cs",
      "approach": "HashSet Lookup with Iterative Multiplication",
      "tags": [
        "Array",
        "Hash Table",
        "Simulation"
      ],
      "steps": [
        "1) Create a HashSet from the array for O(1) lookup operations.",
        "2) While the current value exists in the HashSet, multiply it by 2.",
        "3) Continue until the value is not found in the HashSet.",
        "4) Return the final value that doesn't exist in the array."
      ],
      "timeComplexity": "O(n + k) where n = nums.length, k = number of multiplications",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: Keep Multiplying Found Values by Two\nApproach: HashSet Lookup with Iterative Multiplication\nTags: Array, Hash Table, Simulation\n1) Create a HashSet from the array for O(1) lookup operations.\n2) While the current value exists in the HashSet, multiply it by 2.\n3) Continue until the value is not found in the HashSet.\n4) Return the final value that doesn't exist in the array.\n\nTime Complexity: O(n + k) where n = nums.length, k = number of multiplications\nSpace Complexity: O(n)\n*/\npublic class Solution {\n    public int FindFinalValue(int[] nums, int original) {\n        HashSet<int> hs = new HashSet<int>();                   // HashSet for O(1) lookup\n        foreach(int num in nums) {                              // Add all elements to HashSet\n            hs.Add(num);\n        }\n        while (hs.Contains(original)) {                         // While current value exists in array\n            original = original * 2;                            // Multiply by 2\n        }\n        return original;                                        // Return final value not found in array\n    }\n}"
    },
    {
      "problemNumber": "2169",
      "title": "Count Operationsto Obtain Zero",
      "language": "C#",
      "filename": "2169-CountOperationstoObtainZero.cs",
      "path": "LeetCode/C#/2169-CountOperationstoObtainZero.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2169-CountOperationstoObtainZero.cs",
      "approach": "Simulation with Repeated Subtraction",
      "tags": [
        "Math",
        "Simulation"
      ],
      "steps": [
        "1) Initialize a counter to track the number of operations.",
        "2) While both numbers are non-zero, subtract the smaller from the larger.",
        "3) Increment the operation counter after each subtraction.",
        "4) Continue until one of the numbers becomes zero.",
        "5) Return the total count of operations performed."
      ],
      "timeComplexity": "O(max(num1, num2)) - worst case when numbers differ by 1",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: Count Operations to Obtain Zero\nApproach: Simulation with Repeated Subtraction\nTags: Math, Simulation\n1) Initialize a counter to track the number of operations.\n2) While both numbers are non-zero, subtract the smaller from the larger.\n3) Increment the operation counter after each subtraction.\n4) Continue until one of the numbers becomes zero.\n5) Return the total count of operations performed.\n\nTime Complexity: O(max(num1, num2)) - worst case when numbers differ by 1\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int CountOperations(int num1, int num2) {\n        int result = 0;                                         // Counter for number of operations\n        while (num1 != 0 && num2 != 0) {                       // Continue while both numbers are non-zero\n            if (num1 >= num2)                                   // If num1 is greater or equal\n                num1 = num1 - num2;                             // Subtract num2 from num1\n            else                                                // If num2 is greater\n                num2 = num2 - num1;                             // Subtract num1 from num2\n            result++;                                           // Increment operation counter\n        }\n        return result;                                          // Return total operations count\n    }\n}"
    },
    {
      "problemNumber": "2185",
      "title": "Counting Words Witha Given Prefix",
      "language": "C#",
      "filename": "2185-CountingWordsWithaGivenPrefix.cs",
      "path": "LeetCode/C#/2185-CountingWordsWithaGivenPrefix.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2185-CountingWordsWithaGivenPrefix.cs",
      "approach": "Brute Force",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Brute Force\n1. Initialize the result to 0.\n2. Iterate through the words array.\n3. For each word in the array, check if it starts with the given prefix.\n4. If it does, increment the result.\n5. Return the result.\nTime complexity: O(n)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int PrefixCount(string[] words, string pref) {\n        int result=0;                       // declare result and initialize it to 0\n        foreach(string word in words) {     // iterate through the words array\n            if(word.StartsWith(pref)) {     // check if the word starts with the given prefix\n                result++;                   // increment the result\n            }\n        }\n        return result;                      // return the result\n    }\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n/*\nApproach: Trie\n1. Create a Trie data structure.\n2. Insert all the words in the Trie.\n3. Search for the prefix in the Trie.\n4. Return the count of the prefix.\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Trie {\n    public Trie[] Child = new Trie[26];     // create an array of Trie nodes\n    public bool WordEnd = false;            // create a boolean variable WordEnd\n    public int Count;                       // create an integer variable Count\n\n  }\npublic class Solution {\n    public int PrefixCount(string[] words, string pref) {\n        Trie root = new Trie();             // create a new Trie node root\n        int result = 0;                     // declare result and initialize it to 0\n        foreach(string word in words) {     // iterate through the words array\n            InsertWordInTrie(root, word);   // insert the word in the Trie\n        }\n        result = SearchPrefix(root, pref);  // search for the prefix in the Trie\n        return result;                      // return the result\n    }\n\n    public static void InsertWordInTrie(Trie root, string word) {\n        Trie curr;                                  // declare a Trie node curr\n        curr = root;                                // initialize curr to root\n        foreach (char ch in word) {                 // iterate through the word\n            if(curr.Child[ch - 'a'] == null) {      // check if the child of curr is null\n                curr.Child[ch - 'a'] = new Trie();  // create a new Trie node\n            }\n            curr = curr.Child[ch - 'a'];            // move curr to the child\n            curr.Count++;                           // increment the count\n        }\n        curr.WordEnd = true;                        // mark the end of the word\n    }\n\n    public static int SearchPrefix(Trie root, string pref) {\n        Trie curr;                              // declare a Trie node curr\n        curr = root;                            // initialize curr to root\n        foreach(char ch in pref) {              // iterate through the prefix\n            if(curr.Child[ch - 'a'] == null) {  // check if the child of curr is null\n                return 0;                       // return 0\n            }\n            curr = curr.Child[ch - 'a'];        // move curr to the child\n        }\n        return curr.Count;                      // return the count of the prefix\n    }\n}"
    },
    {
      "problemNumber": "2206",
      "title": "Divide Array Into Equal Pairs",
      "language": "C#",
      "filename": "2206-DivideArrayIntoEqualPairs.cs",
      "path": "LeetCode/C#/2206-DivideArrayIntoEqualPairs.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2206-DivideArrayIntoEqualPairs.cs",
      "approach": "1. Create a boolean array of size 1000 and fill it with true.",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a boolean array of size 1000 and fill it with true.\n2. Iterate through the array and toggle the value of the index in the boolean array.\n3. If the value is false, return false.\n4. If all the values are true, return true.\nTime complexity is O(n)\nSpace complexity is O(1)\n\n*/\npublic class Solution {\n    public bool DivideArray(int[] nums) {\n        bool[] pair = new bool[1000];   // Create a boolean array of size 1000 and fill it with true.\n        Array.Fill(pair,true);          // Fill the array with true.\n        foreach(int num in nums) {      // Iterate through the array and toggle the value of the index in the boolean array.\n            pair[num] = !pair[num];     // Toggle the value of the index in the boolean array.\n        }\n        foreach(bool value in pair) {   // If the value is false, return false.\n            if (value == false)         // If the value is false, return false.\n                return false;           // Return false.\n        }\n        return true;                    // If all the values are true, return true.\n    }\n}"
    },
    {
      "problemNumber": "2210",
      "title": "Count Hillsand Valleysinan Array",
      "language": "C#",
      "filename": "2210-CountHillsandValleysinanArray.cs",
      "path": "LeetCode/C#/2210-CountHillsandValleysinanArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2210-CountHillsandValleysinanArray.cs",
      "approach": "Two Pointers",
      "tags": [],
      "steps": [
        "1) Initialize two pointers, i and j, both starting at 0.",
        "2) Use a while loop to iterate through the array until j reaches the second last element.",
        "3) Check if the current element at j is a hill or a valley by comparing it with its neighbors.",
        "4) If it is a hill or a valley, increment the count and update i to j.",
        "5) Move j to the next element.",
        "6) Return the count of hills and valleys."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nVideos: https://www.youtube.com/watch?v=NK83TS3xi0c\nSolution: https://leetcode.com/problems/count-hills-and-valleys-in-an-array/solutions/7011664/simplest-solution-c-time-on-space1-pleas-vthe/\nTags: Array, Two-Pointers\nApproach: Two Pointers\n1) Initialize two pointers, i and j, both starting at 0.\n2) Use a while loop to iterate through the array until j reaches the second last element.\n3) Check if the current element at j is a hill or a valley by comparing it with its neighbors.\n4) If it is a hill or a valley, increment the count and update i to j.\n5) Move j to the next element.\n6) Return the count of hills and valleys.\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution\n{\n    public int CountHillValley(int[] nums)\n    {\n        int i = 0;                                          // Pointer to track the last hill or valley\n        int j = 0;                                          // Pointer to iterate through the array\n        int numOfValleysOrHills = 0;                        // Counter for hills and valleys\n\n        while (j < nums.Length - 1)                         // Iterate through the array\n        {\n            if (                                            // Check if the current element is a hill or a valley\n            (nums[i] < nums[j] && nums[j] > nums[j + 1])\n            ||\n            (nums[i] > nums[j] && (nums[j] < nums[j + 1]))\n            )\n            {\n                numOfValleysOrHills++;                      // Increment the count if a hill or valley is found\n                i = j;                                      // Update i to the current position j\n            }\n            j++;                                            // Move to the next element\n        }\n\n        return numOfValleysOrHills;                         // Return the total count of hills and valleys\n\n    }\n}"
    },
    {
      "problemNumber": "2215",
      "title": "Findthe Differenceof Two Arrays",
      "language": "C#",
      "filename": "2215-FindtheDifferenceofTwoArrays.cs",
      "path": "LeetCode/C#/2215-FindtheDifferenceofTwoArrays.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2215-FindtheDifferenceofTwoArrays.cs",
      "approach": "- Create two hashsets to store the unique elements of the two arrays.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n- Create two hashsets to store the unique elements of the two arrays.\n- Create a list to store the difference of the two arrays.\n- Iterate through the first array and add the elements to the first hashset.\n- Iterate through the second array and add the elements to the second hashset.\n- Iterate through the first hashset and check if the element is not present in the second hashset, then add it to the list.\n- Add the list to the result.\n- Create a new list to store the difference of the second array.\n- Iterate through the second hashset and check if the element is not present in the first hashset, then add it to the list.\n- Add the list to the result.\n- Return the result.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class Solution {\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\n        HashSet<int> hs1 = new HashSet<int>();\n        HashSet<int> hs2 = new HashSet<int>();\n        IList<IList<int>> result = new List<IList<int>>();\n        IList<int> list = new List<int>();\n\n        foreach(int num in nums1) {\n            hs1.Add(num);\n        }\n\n        foreach(int num in nums2) {\n            hs2.Add(num);\n        }\n\n        foreach(int num in hs1) {\n            if(!hs2.Contains(num))\n                list.Add(num);\n        }\n\n        result.Add(list);\n        list = new List<int>();\n\n        foreach(int num in hs2) {\n            if(!hs1.Contains(num))\n                list.Add(num);\n        }\n\n        result.Add(list);\n        return result;\n    }\n}"
    },
    {
      "problemNumber": "2250",
      "title": "Implement Stackusing Queues",
      "language": "C#",
      "filename": "2250-ImplementStackusingQueues.cs",
      "path": "LeetCode/C#/2250-ImplementStackusingQueues.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2250-ImplementStackusingQueues.cs",
      "approach": "1. We can implement a stack using one queue.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. We can implement a stack using one queue.\n2. We can use the queue to implement the stack.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\n*/\npublic class MyStack {\n    private Queue<int> _q;                          // Queue to implement stack\n\n    public MyStack() {\n        _q = new Queue<int>();                      // Initialize the queue\n    }\n\n    public void Push(int x) {\n        _q.Enqueue(x);                              // Enqueue the element\n         for(int i=0; i<_q.Count-1; i++) {          // Move the elements to the front of the queue\n            _q.Enqueue(_q.Dequeue());               // Dequeue the element and enqueue it again\n        }\n    }\n\n    public int Pop() {\n        return _q.Dequeue();                        // Dequeue the element\n    }\n\n    public int Top() {\n        return _q.Peek();                           // Peek the element\n    }\n\n    public bool Empty() {\n        return _q.Count == 0;                       // Check if the queue is empty\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Top();\n * bool param_4 = obj.Empty();\n */"
    },
    {
      "problemNumber": "2264",
      "title": "Largest3 Same Digit Number In String",
      "language": "C#",
      "filename": "2264-Largest3SameDigitNumberInString.cs",
      "path": "LeetCode/C#/2264-Largest3SameDigitNumberInString.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2264-Largest3SameDigitNumberInString.cs",
      "approach": "1. Traverse the string and check if there are 3 consecutive same digits.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Traverse the string and check if there are 3 consecutive same digits.\n2. If yes, return the maximum digit.\n3. If no, return empty string.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public string LargestGoodInteger(string num) {\n        int currPtr = 0;\n        int maxChar = -1;\n        while (currPtr < num.Length - 2) {\n            if(num[currPtr] == num[currPtr+1] && num[currPtr] == num[currPtr+2]) {\n                maxChar = Math.Max(maxChar,num[currPtr] - '0');\n            }\n            currPtr++;\n        }\n        return maxChar > -1 ? maxChar.ToString() + maxChar.ToString() + maxChar.ToString() : \"\";\n    }\n}"
    },
    {
      "problemNumber": "2270",
      "title": "Numberof Waysto Split Array",
      "language": "C#",
      "filename": "2270-NumberofWaystoSplitArray.cs",
      "path": "LeetCode/C#/2270-NumberofWaystoSplitArray.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2270-NumberofWaystoSplitArray.cs",
      "approach": "1. Calculate the total sum of the array.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n) where n is the length of the nums array.",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Calculate the total sum of the array.\n2. Iterate through the array and calculate the leftSum and rightSum.\n3. If the leftSum is greater than or equal to the rightSum, increment the result.\n4. Return the result.\n\nTime Complexity: O(n) where n is the length of the nums array.\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int WaysToSplitArray(int[] nums) {\n        long totalSum, leftSum, rightSum;           // Declare the variables\n        int result = 0;                             // Initialize the result to 0\n        leftSum = rightSum = 0;                     // Initialize the leftSum and rightSum to 0\n        totalSum = FindSum(nums);                   // Calculate the total sum of the array\n        for (int i = 0; i<nums.Length - 1; i++) {   // Iterate through the array up to the second last element\n            leftSum = leftSum + nums[i];            // Calculate the leftSum\n            rightSum = totalSum - leftSum;          // Calculate the rightSum\n            if (leftSum >= rightSum) {              // Check if the leftSum is greater than or equal to the rightSum\n                result++;                           // Increment the result\n            }\n        }\n        return result;                              // Return the result\n    }\n\n    public static long FindSum(int[] nums) {        // Function to calculate the total sum of the array\n        long totalSum = 0;                          // Initialize the totalSum to 0\n        foreach (int num in nums) {                 // Iterate through the array\n            totalSum+= num;                         // Calculate the total sum\n        }\n        return totalSum;                            // Return the total sum\n    }\n}"
    },
    {
      "problemNumber": "2348",
      "title": "Numberof Zero- Filled Subarrays",
      "language": "C#",
      "filename": "2348-NumberofZero-FilledSubarrays.cs",
      "path": "LeetCode/C#/2348-NumberofZero-FilledSubarrays.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2348-NumberofZero-FilledSubarrays.cs",
      "approach": "Count length of each zero streak and sum up all possible subarrays",
      "tags": [
        "Array",
        "Math",
        "Counting"
      ],
      "steps": [
        "1) Iterate through the array, tracking the current streak of consecutive zeros.",
        "2) For each zero, increment the streak and add its length to the sum.",
        "3) If a non-zero is encountered, reset the streak.",
        "4) The sum accumulates the total number of zero-filled subarrays."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "\n/*\nSolution: https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/7099676/simplest-solution-c-time-on-space1-pleas-qfik/\nApproach: Count length of each zero streak and sum up all possible subarrays\nTags: Array, Math, Counting\n1) Iterate through the array, tracking the current streak of consecutive zeros.\n2) For each zero, increment the streak and add its length to the sum.\n3) If a non-zero is encountered, reset the streak.\n4) The sum accumulates the total number of zero-filled subarrays.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public long ZeroFilledSubarray(int[] nums) {\n        long currentContinuousZeros = 0;           // Tracks current streak of consecutive zeros\n        long sum = 0;                              // Accumulates total zero-filled subarrays\n\n        for (long i = 0; i < nums.Length; i++) {   // Iterate through the array\n            if (nums[i] == 0) {                    // If current element is zero\n                currentContinuousZeros++;           // Increment zero streak\n                sum = sum + currentContinuousZeros; // Add streak length to sum\n            }\n            else {\n                currentContinuousZeros = 0;         // Reset streak if non-zero\n            }\n        }\n        return sum;                                // Return total number of zero-filled subarrays\n    }\n}\n"
    },
    {
      "problemNumber": "2381",
      "title": "Shifting Letters I I",
      "language": "C#",
      "filename": "2381-ShiftingLettersII.cs",
      "path": "LeetCode/C#/2381-ShiftingLettersII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2381-ShiftingLettersII.cs",
      "approach": "1. Create a diff array of size s.Length",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a diff array of size s.Length\n2. Create a chars array of size s.Length\n3. Create a StringBuilder\n4. Iterate through the string and populate the chars array\n5. Iterate through the shifts array and populate the diff array\n6. Iterate through the diff array and calculate the cumulative sum\n7. Iterate through the chars array and calculate the new position of the character\n8. Append the new character to the StringBuilder\n9. Return the StringBuilder as string\n\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    public string ShiftingLetters(string s, int[][] shifts) {\n        int[] diff = new int[s.Length];                             // declare an array of size s.Length\n        int[] chars = new int[s.Length];                            // declare an array of size s.Length\n        int index = 0;                                              // declare an index variable\n        int modFactor = 26;                                         // declare a modFactor variable\n        StringBuilder sb = new StringBuilder();                     // declare a StringBuilder\n\n        // Populate the chars array\n        foreach(char c in s) {                                      // iterate through the string and populate the chars array\n            chars[index] = c - 'a';                                 // populate the chars array\n            index++;                                                // increment the index\n        }\n\n        // Populate the diff array\n        foreach(var shift in shifts) {                              // iterate through the shifts array\n            int left = shift[0];                                    // declare a left variable\n            int right = shift[1];                                   // declare a right variable\n            int factor = shift[2] == 0 ? -1 : 1;                    // declare a factor variable\n\n            diff[left] = (diff[left] + factor) ;                    // populate the diff array\n            if ((right+1) < diff.Length) {                          // check if right+1 is less than diff.Length\n                diff[right + 1] = (diff[right + 1] - factor);       // populate the diff array\n            }\n\n        }\n\n        // Calculate the cumulative sum\n        index = 0;                                                  // reset the index\n        int cumSum = 0;                                             // declare a cumSum variable\n        while (index < s.Length) {                                  // iterate through the diff array\n            diff[index] = diff[index] + cumSum;                     // calculate the cumulative sum\n            cumSum = diff[index];                                   // update the cumSum\n            index++;                                                // increment the index\n        }\n\n        // Calculate the new position of the character\n        index=0;                                                    // reset the index\n        while (index < s.Length) {                                  // iterate through the chars array\n            int newPos = chars[index] + diff[index];                // calculate the new position of the character\n            newPos = newPos % modFactor;                            // calculate the new position of the character\n            if(newPos < 0) {                                        // check if newPos is less than 0\n                newPos = newPos + modFactor;                        // calculate the new position of the character\n            }\n            char newChar = (char)(newPos + 'a');                    // calculate the new character\n            sb.Append(newChar);                                     // append the new character to the StringBuilder\n            index++;                                                // increment the index\n        }\n\n        return sb.ToString();                                       // return the StringBuilder as string\n    }\n}"
    },
    {
      "problemNumber": "2390",
      "title": "Removing Stars Froma String",
      "language": "C#",
      "filename": "2390-RemovingStarsFromaString.cs",
      "path": "LeetCode/C#/2390-RemovingStarsFromaString.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2390-RemovingStarsFromaString.cs",
      "approach": "1. Create a stack to store the characters.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Create a stack to store the characters.\n2. Iterate through the string.\n3. If the current character is a star and the stack is not empty, pop the last character from the stack.\n4. If the current character is not a star, push it to the stack.\n5. After iterating through the string, pop all the characters from the stack (also remove the last character from the string when you encounter * by decreasing the length) and return the string.\n\nTime complexity: O(n)\nSpace complexity: O(n)\n*/\npublic class Solution {\n    public string RemoveStars(string s) {\n        Stack<char> stack = new Stack<char>();      // To store the characters\n        StringBuilder sb = new StringBuilder();     // To store the final string\n        for(int i = s.Length-1;i >=0;i--) {         // Iterating through the string\n            stack.Push(s[i]);                       // Push the character to the stack\n        }\n        while(stack.Count() != 0) {                 // Pop all the characters from the stack\n            char ch = stack.Pop();                  // Pop the character from the stack\n            if(ch == '*' && sb.Length > 0) {        // If the current character is a star and the stack is not empty\n                sb.Length = sb.Length-1;            // Remove the last character from the string\n            }\n            else {\n                sb.Append(ch);                      // Append the character to the final string\n            }\n        }\n        return sb.ToString();                       // Return the final string\n    }\n}"
    },
    {
      "problemNumber": "2418",
      "title": "Sortthe People",
      "language": "C#",
      "filename": "2418-SortthePeople.cs",
      "path": "LeetCode/C#/2418-SortthePeople.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2418-SortthePeople.cs",
      "approach": "Using Dictionary and Sorting",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n log n) due to sorting.",
      "spaceComplexity": "O(n) for the dictionary and result list.",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/sort-the-people/solutions/6888177/simplest-solution-c-time-on-log-n-spacen-qcoc/\nApproach: Using Dictionary and Sorting\n1. Create a dictionary to map heights to names.\n2. Sort the heights in descending order.\n3. Iterate through the sorted heights and build the result list using the dictionary.\n4. Convert the result list to an array and return it.\n\nTime Complexity: O(n log n) due to sorting.\nSpace Complexity: O(n) for the dictionary and result list.\n*/\npublic class Solution\n{\n    public string[] SortPeople(string[] names, int[] heights)\n    {\n\n        Dictionary<int, string> dict = new Dictionary<int, string>();   // Dictionary to map heights to names\n        List<string> result = new List<string>();                       // Result list to store sorted names\n\n        for (int i = 0; i < heights.Length; i++)                        // Populate the dictionary with heights as keys and names as values\n        {\n            dict.Add(heights[i], names[i]);                             // Add height and corresponding name to the dictionary\n        }\n\n        Array.Sort(heights);                                             // Sort the heights in ascending order\n        Array.Reverse(heights);                                          // Reverse the sorted heights to get them in descending order\n\n        foreach (int height in heights)                                  // Iterate through the sorted heights\n        {\n            result.Add(dict[height]);                                    // For each height, find the corresponding name in the dictionary and add it to the result list\n        }\n        return result.ToArray();                                         // Convert the result list to an array and return it\n    }\n}"
    },
    {
      "problemNumber": "2520",
      "title": "Counter",
      "language": "JavaScript",
      "filename": "2520-Counter.js",
      "path": "LeetCode/JavaScript/2520-Counter.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2520-Counter.js",
      "approach": "- We can create a function that returns another function that returns a counter value when called.",
      "tags": [],
      "steps": [],
      "timeComplexity": "- O(1)",
      "spaceComplexity": "- O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n- We can create a function that returns another function that returns a counter value when called.\n- We can use the closure property of JavaScript to achieve this.\n\nTime complexity:\n- O(1)\n\nSpace complexity:\n- O(1)\n\n*/\n\n/**\n * @param {number} n\n * @return {Function} counter\n */\nvar createCounter = function(n) {\n    let num = n;\n    return function() {\n        return num++;\n    };\n};\n\n/**\n * const counter = createCounter(10)\n * counter() // 10\n * counter() // 11\n * counter() // 12\n */"
    },
    {
      "problemNumber": "2529",
      "title": "Maximum Countof Positive Integerand Negative Integer",
      "language": "C#",
      "filename": "2529-MaximumCountofPositiveIntegerandNegativeInteger.cs",
      "path": "LeetCode/C#/2529-MaximumCountofPositiveIntegerandNegativeInteger.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2529-MaximumCountofPositiveIntegerandNegativeInteger.cs",
      "approach": "Linear Search",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Linear Search\n1. Count the positive numbers in the array\n2. Count the negative numbers in the array\n3. Return the maximum of the positive and negative numbers count\n\nTime complexity: O(n)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int MaximumCount(int[] nums) {\n       int positive_numbers_count = nums.Where(x=>x>0).Count();             // Count the positive numbers in the array\n       int negative_numbers_count = nums.Where(x=>x<0).Count();             // Count the negative numbers in the array\n       return Math.Max(positive_numbers_count,negative_numbers_count);      // Return the maximum of the positive and negative numbers count\n    }\n}\n\n/*\nApproach: Binary Search as the array is sorted\nTODO: Implement Binary Search\n\n*/\npublic class Solution {\n    public int MaximumCount(int[] nums) {\n\n    }\n}"
    },
    {
      "problemNumber": "2559",
      "title": "Count Vowel Stringsin Ranges",
      "language": "C#",
      "filename": "2559-CountVowelStringsinRanges.cs",
      "path": "LeetCode/C#/2559-CountVowelStringsinRanges.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2559-CountVowelStringsinRanges.cs",
      "approach": "1. Create a bag array of size words.Length.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n + m) where n is the length of the words array and m is the length of the queries array.",
      "spaceComplexity": "O(n) where n is the length of the words array.",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a bag array of size words.Length.\n2. Create a HashSet of vowels.\n3. Iterate through the words array and check if the first and last character of the word is a vowel.\n4. If it is a vowel, increment the currentSum by 1 and store it in the bag array.\n5. If it is not a vowel, store the currentSum in the bag array.\n6. Iterate through the queries array and calculate the number of vowel strings between the given range.\n7. Return the result array.\n\nTime Complexity: O(n + m) where n is the length of the words array and m is the length of the queries array.\nSpace Complexity: O(n) where n is the length of the words array.\n*/\npublic class Solution {\n    public int[] VowelStrings(string[] words, int[][] queries) {\n        int[] bag = new int[words.Length];                                      // bag array to store the number of vowel strings\n        int index = 0;                                                          // index to iterate through the bag array\n        int currentSum = 0;                                                     // currentSum to store the number of vowel strings\n        int[] result = new int[queries.Length];                                 // result array to store the number of vowel strings between the given range\n        HashSet<int> hs = new HashSet<int>();                                   // HashSet to store the vowels\n        hs.Add('a');                                                            // Add vowels to the HashSet\n        hs.Add('e');                                                            // Add vowels to the HashSet\n        hs.Add('i');                                                            // Add vowels to the HashSet\n        hs.Add('o');                                                            // Add vowels to the HashSet\n        hs.Add('u');                                                            // Add vowels to the HashSet\n\n        foreach(string word in words) {                                         // Iterate through the words array\n            if (IfVowelString(word,hs)) {                                       // Check if the first and last character of the word is a vowel\n                bag[index] = currentSum + 1;                                    // Increment the currentSum by 1 and store it in the bag array\n                currentSum = bag[index];                                        // Update the currentSum\n            }\n            else {\n                bag[index] = currentSum;                                        // Store the currentSum in the bag array\n            }\n\n            index++;                                                            // Increment the index\n        }\n\n        index=0;                                                                // Reset the index\n\n        foreach(var arr in queries) {                                           // Iterate through the queries array\n            int numStart = arr[0];                                              // Get the start index of the range\n            int numEnd = arr[1];                                                // Get the end index of the range\n            if(numStart > 0) {                                                  // Check if the start index is greater than 0\n                result[index] = bag[numEnd] - bag[numStart - 1];                // Calculate the number of vowel strings between the given range\n            }\n            else {\n                result[index] = bag[numEnd];                                    // Calculate the number of vowel strings between the given range\n            }\n            index++;                                                            // Increment the index\n        }\n        return result;                                                          // Return the result array\n    }\n\n    public bool IfVowelString(string word, HashSet<int> hs) {                   // Function to check if the first and last character of the word is a vowel\n        bool result = false;                                                    // Initialize the result to false\n        char firstChar = word[0];                                               // Get the first character of the word\n        char lastChar = word[word.Length - 1];                                  // Get the last character of the word\n        if(hs.Contains(firstChar) && hs.Contains(lastChar)) {                   // Check if the first and last character of the word is a vowel\n            result = true;                                                      // Update the result\n        }\n        return result;                                                          // Return the result\n    }\n}"
    },
    {
      "problemNumber": "2579",
      "title": "Count Total Number Of Colored Cells",
      "language": "C#",
      "filename": "2579-CountTotalNumberOfColoredCells.cs",
      "path": "LeetCode/C#/2579-CountTotalNumberOfColoredCells.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2579-CountTotalNumberOfColoredCells.cs",
      "approach": "- For n = 1, there is only 1 colored cell.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n- For n = 1, there is only 1 colored cell.\n- For n > 1, there are 4 * n * (n - 1) / 2 colored cells.\n- So, the total number of colored cells = 1 + 4 * n * (n - 1) / 2. because there is 1 colored cell for n = 1.\n- 1 + 4*1 + 4*2 + 4*3 + ... + 4*(n-1) = 1 + 4 * (1 + 2 + 3 + ... + n - 1) = 1 + 4 * n * (n - 1) / 2\n- So, the total number of colored cells = 1 + 4 * n * (n - 1) / 2. Sum of n natural numbers = n * (n + 1) / 2. Here n = n - 1. So, the sum of n natural numbers = n * (n - 1) / 2.\n- So, the total number of colored cells = 1 + 4 * n * (n - 1) / 2.\nTime complexity: O(1)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public long ColoredCells(int n) {\n        return n == 1 ? 1 : (1 + 4L * n * (n - 1) / 2);\n    }\n}"
    },
    {
      "problemNumber": "2621",
      "title": "Sleep",
      "language": "JavaScript",
      "filename": "2621-Sleep.js",
      "path": "LeetCode/JavaScript/2621-Sleep.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2621-Sleep.js",
      "approach": "1) We can create a function that returns a promise that resolves after a certain amount of time.",
      "tags": [],
      "steps": [
        "1) We can create a function that returns a promise that resolves after a certain amount of time.",
        "2) We can use the setTimeout function to achieve this."
      ],
      "timeComplexity": "- O(1)",
      "spaceComplexity": "- O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) We can create a function that returns a promise that resolves after a certain amount of time.\n2) We can use the setTimeout function to achieve this.\n\nTime complexity:\n- O(1)\n\nSpace complexity:\n- O(1)\n\n\n*/\n\n/**\n * @param {number} millis\n * @return {Promise}\n */\nasync function sleep(millis) {\n    return new Promise((resolve) => {\n     setTimeout(resolve, millis);\n   });\n}\n\n/**\n* let t = Date.now()\n* sleep(100).then(() => console.log(Date.now() - t)) // 100\n*/"
    },
    {
      "problemNumber": "2626",
      "title": "Array Reduce Transformation",
      "language": "JavaScript",
      "filename": "2626-ArrayReduceTransformation.js",
      "path": "LeetCode/JavaScript/2626-ArrayReduceTransformation.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2626-ArrayReduceTransformation.js",
      "approach": "1. Initialize a variable res with the initial value.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Initialize a variable res with the initial value.\n2. Iterate through the array and apply the function fn on the current element and the result.\n3. Update the result with the new value.\n4. Return the result.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n\n*/\n\n/**\n * @param {number[]} nums\n * @param {Function} fn\n * @param {number} init\n * @return {number}\n */\nvar reduce = function(nums, fn, init) {\n    let res = init;\n    for(const n of nums) {\n        res = fn(res,n)\n    }\n    return res;\n};\n"
    },
    {
      "problemNumber": "2629",
      "title": "Function Composition",
      "language": "JavaScript",
      "filename": "2629-FunctionComposition.js",
      "path": "LeetCode/JavaScript/2629-FunctionComposition.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2629-FunctionComposition.js",
      "approach": "1. Return a function that takes a value x as input.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Return a function that takes a value x as input.\n2. Iterate through the functions in reverse order and apply each function on x.\n3. Return the final value.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n\n*/\n\n/**\n * @param {Function[]} functions\n * @return {Function}\n */\nvar compose = function(functions) {\n\n    return function(x) {\n\n        for (const fn of functions.reverse()) {\n            x = fn(x);\n        }\n\n        return x;\n    }\n};\n\n/**\n * const fn = compose([x => x + 1, x => 2 * x])\n * fn(4) // 9\n */"
    },
    {
      "problemNumber": "2634",
      "title": "Filter Elements From Array",
      "language": "JavaScript",
      "filename": "2634-FilterElementsFromArray.js",
      "path": "LeetCode/JavaScript/2634-FilterElementsFromArray.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2634-FilterElementsFromArray.js",
      "approach": "- We can create a function that takes an array and a function as arguments.",
      "tags": [],
      "steps": [],
      "timeComplexity": "- O(n)",
      "spaceComplexity": "- O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n- We can create a function that takes an array and a function as arguments.\n- We can iterate over the array and apply the function to each element.\n- We can return the new array.\n\nTime complexity:\n- O(n)\n\nSpace complexity:\n- O(n)\n\n*/\n/**\n * @param {number[]} arr\n * @param {Function} fn\n * @return {number[]}\n */\nvar filter = function(arr, fn) {\n    let res = [];\n\n    for(let i in arr) {\n        if(fn(arr[i],Number(i))) {\n            res.push(arr[i]);\n        }\n    }\n\n    return res;\n};"
    },
    {
      "problemNumber": "2635",
      "title": "Apply Transform Over Each Elementin Array",
      "language": "JavaScript",
      "filename": "2635-ApplyTransformOverEachElementinArray.js",
      "path": "LeetCode/JavaScript/2635-ApplyTransformOverEachElementinArray.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2635-ApplyTransformOverEachElementinArray.js",
      "approach": "- We can create a function that takes an array and a function as arguments.",
      "tags": [],
      "steps": [],
      "timeComplexity": "- O(n)",
      "spaceComplexity": "- O(n)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n- We can create a function that takes an array and a function as arguments.\n- We can iterate over the array and apply the function to each element.\n- We can return the new array.\n\nTime complexity:\n- O(n)\n\nSpace complexity:\n- O(n)\n\n*/\n/**\n * @param {number[]} arr\n * @param {Function} fn\n * @return {number[]}\n */\nvar map = function(arr, fn) {\n\n    let res = []\n\n    for(let i in arr) {\n        res[i] = fn(arr[i],Number(i));\n    }\n    return res;\n\n};"
    },
    {
      "problemNumber": "2637",
      "title": "Promise Time Limit",
      "language": "JavaScript",
      "filename": "2637-PromiseTimeLimit.js",
      "path": "LeetCode/JavaScript/2637-PromiseTimeLimit.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2637-PromiseTimeLimit.js",
      "approach": "1) We can create a function that returns a function that resolves a promise after a certain amount of time.",
      "tags": [],
      "steps": [
        "1) We can create a function that returns a function that resolves a promise after a certain amount of time.",
        "2) We can use the setTimeout function to achieve this.",
        "3) We can use the async and await keywords to make the function asynchronous.",
        "4) We can use the Promise constructor to create a promise that resolves after a certain amount of time."
      ],
      "timeComplexity": "- O(1)",
      "spaceComplexity": "- O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1) We can create a function that returns a function that resolves a promise after a certain amount of time.\n2) We can use the setTimeout function to achieve this.\n3) We can use the async and await keywords to make the function asynchronous.\n4) We can use the Promise constructor to create a promise that resolves after a certain amount of time.\n\nTime complexity:\n- O(1)\n\nSpace complexity:\n- O(1)\n\n*/\n\n/**\n * @param {Function} fn\n * @param {number} t\n * @return {Function}\n */\nvar timeLimit = function (fn, t) {\n\n    return async function (...args) {\n\n        return new Promise(async (resolve, reject) => {\n\n            const setTimeId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\n\n            try {\n                const result = await fn(...args);\n                resolve(result);\n            } catch (err) {\n                reject(err);\n            }\n\n        });\n\n    }\n};\n\n/**\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\n */"
    },
    {
      "problemNumber": "2665",
      "title": "Counter I I",
      "language": "JavaScript",
      "filename": "2665-CounterII.js",
      "path": "LeetCode/JavaScript/2665-CounterII.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2665-CounterII.js",
      "approach": "- We can create a function that returns an object with three functions: increment, decrement, and reset.",
      "tags": [],
      "steps": [],
      "timeComplexity": "- O(1)",
      "spaceComplexity": "- O(1)",
      "solutionLink": "",
      "code": "/**\n\nApproach:\n- We can create a function that returns an object with three functions: increment, decrement, and reset.\n- We can use the closure property of JavaScript to achieve this.\n\nTime complexity:\n- O(1)\n\nSpace complexity:\n- O(1)\n\n */\n\n\n/**\n * @param {integer} init\n * @return { increment: Function, decrement: Function, reset: Function }\n */\nvar createCounter = function(init) {\n    let num = init;\n    function increment() {\n        return ++num;\n    }\n    function decrement() {\n        return --num;\n    }\n    function reset() {\n        num = init;\n        return num;\n    }\n\n    return {\n        increment:increment,\n        decrement:decrement,\n        reset:reset\n    }\n};\n\n/**\n * const counter = createCounter(5)\n * counter.increment(); // 6\n * counter.reset(); // 5\n * counter.decrement(); // 4\n */"
    },
    {
      "problemNumber": "2666",
      "title": "Allow One Function Call",
      "language": "JavaScript",
      "filename": "2666-AllowOneFunctionCall.js",
      "path": "LeetCode/JavaScript/2666-AllowOneFunctionCall.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2666-AllowOneFunctionCall.js",
      "approach": "1. Initialize a variable alreadyCalled with false.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n1. Initialize a variable alreadyCalled with false.\n2. Return a function which takes any number of arguments.\n3. If alreadyCalled is false, set it to true and call the function with the arguments.\n4. Otherwise, return undefined.\n\nTime complexity: O(1)\nSpace complexity: O(1)\n\n*/\n\n/**\n * @param {Function} fn\n * @return {Function}\n */\nvar once = function(fn) {\n\n    let alreadyCalled = false;\n\n    return function(...args){\n        if (!alreadyCalled)    {\n            alreadyCalled = true;\n            return fn(...args)\n        }\n    }\n};\n\n/**\n * let fn = (a,b,c) => (a + b + c)\n * let onceFn = once(fn)\n *\n * onceFn(1,2,3); // 6\n * onceFn(2,3,6); // returns undefined without calling fn\n */\n"
    },
    {
      "problemNumber": "2667",
      "title": "Create Hello World Function",
      "language": "JavaScript",
      "filename": "2667-CreateHelloWorldFunction.js",
      "path": "LeetCode/JavaScript/2667-CreateHelloWorldFunction.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2667-CreateHelloWorldFunction.js",
      "approach": "- We can create a function that returns another function that returns \"Hello World\" when called.",
      "tags": [],
      "steps": [],
      "timeComplexity": "- O(1)",
      "spaceComplexity": "- O(1)",
      "solutionLink": "",
      "code": "/*\n\nApproach:\n- We can create a function that returns another function that returns \"Hello World\" when called.\n- We can use the closure property of JavaScript to achieve this.\n\nTime complexity:\n- O(1)\n\nSpace complexity:\n- O(1)\n\n*/\n\n\n/**\n * @return {Function}\n */\nvar createHelloWorld = function() {\n\n    return function(...args) {\n        return \"Hello World\"\n    }\n};\n\n/**\n * const f = createHelloWorld();\n * f(); // \"Hello World\"\n */"
    },
    {
      "problemNumber": "2678",
      "title": "Numberof Senior Citizens",
      "language": "C#",
      "filename": "2678-NumberofSeniorCitizens.cs",
      "path": "LeetCode/C#/2678-NumberofSeniorCitizens.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2678-NumberofSeniorCitizens.cs",
      "approach": "1. Declare a variable result and initialize it to 0.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Declare a variable result and initialize it to 0.\n2. Iterate through the details array.\n3. For each detail, get the age by converting the characters at index 11 and 12 to integers.\n4. If the age is greater than 60, increment the result.\n5. Return the result.\nTime complexity: O(n)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int CountSeniors(string[] details) {\n        int result = 0;\n        foreach (string detail in details) {            // iterate through the details array\n            int numberAt11 = detail[11] - '0';          // get the integer value of the character at index 11\n            int numberAt12 = detail[12] - '0';          // get the integer value of the character at index 12\n            int age = (numberAt11*10) + numberAt12;     // calculate the age\n            if (age > 60) result++;                     // check if the age is greater than 60\n        }\n        return result;                                  // return the result\n    }\n}"
    },
    {
      "problemNumber": "2683",
      "title": "Neighboring Bitwise X O R",
      "language": "C#",
      "filename": "2683-NeighboringBitwiseXOR.cs",
      "path": "LeetCode/C#/2683-NeighboringBitwiseXOR.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2683-NeighboringBitwiseXOR.cs",
      "approach": "1. If the array is valid, then the XOR of all the elements in the array should be 0.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. If the array is valid, then the XOR of all the elements in the array should be 0.\n2. So, we can iterate through the array and XOR all the elements.\n3. If the result is 0, then the array is valid.\n4. Else, the array is invalid.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool DoesValidArrayExist(int[] derived) {\n        int result = 0;                 // Initialize the result to 0\n        foreach (int num in derived) {  // Iterate through the array\n            result = result ^ num;      // XOR all the elements\n        }\n        return result == 0;             // Return true if the result is 0, else return false\n    }\n}"
    },
    {
      "problemNumber": "2703",
      "title": "Return Lengthof Arguments Passed",
      "language": "JavaScript",
      "filename": "2703-ReturnLengthofArgumentsPassed.js",
      "path": "LeetCode/JavaScript/2703-ReturnLengthofArgumentsPassed.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2703-ReturnLengthofArgumentsPassed.js",
      "approach": "Use Rest Parameters and Length Property",
      "tags": [
        "JavaScript",
        "Rest Parameters",
        "Array"
      ],
      "steps": [
        "1) Use rest parameters (...args) to collect all arguments into an array.",
        "2) Access the length property of the arguments array.",
        "3) Return the count of arguments passed to the function."
      ],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(n) where n is the number of arguments",
      "solutionLink": "",
      "code": "/*\nSolution: Return Length of Arguments Passed\nApproach: Use Rest Parameters and Length Property\nTags: JavaScript, Rest Parameters, Array\n1) Use rest parameters (...args) to collect all arguments into an array.\n2) Access the length property of the arguments array.\n3) Return the count of arguments passed to the function.\n\nTime Complexity: O(1)\nSpace Complexity: O(n) where n is the number of arguments\n*/\n\n/**\n * @param {...(null|boolean|number|string|Array|Object)} args\n * @return {number}\n */\nvar argumentsLength = function(...args) {\n    return ([...args].length)                       // Return the number of arguments passed\n};\n\n/**\n * argumentsLength(1, 2, 3); // 3\n */"
    },
    {
      "problemNumber": "2704",
      "title": "To Be Or Not To Be",
      "language": "JavaScript",
      "filename": "2704-ToBeOrNotToBe.js",
      "path": "LeetCode/JavaScript/2704-ToBeOrNotToBe.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2704-ToBeOrNotToBe.js",
      "approach": "Object with Methods for Value Comparison",
      "tags": [
        "JavaScript",
        "Object Methods",
        "Error Handling"
      ],
      "steps": [
        "1) Create a function that returns an object with two methods.",
        "2) Implement toBe method that checks strict equality and throws error if not equal.",
        "3) Implement notToBe method that checks strict inequality and throws error if equal.",
        "4) Both methods return true on successful assertion, throw string on failure."
      ],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/to-be-or-not-to-be/solutions/7381921/simplest-solution-javascript-time-o1-spa-s8j0/\nApproach: Object with Methods for Value Comparison\nTags: JavaScript, Object Methods, Error Handling\n1) Create a function that returns an object with two methods.\n2) Implement toBe method that checks strict equality and throws error if not equal.\n3) Implement notToBe method that checks strict inequality and throws error if equal.\n4) Both methods return true on successful assertion, throw string on failure.\n\nTime Complexity: O(1)\nSpace Complexity: O(1)\n*/\n\n/**\n * @param {string} val\n * @return {Object}\n */\nvar expect = function(val) {\n    return {\n        toBe: function(val1) {                      // Method to assert equality\n            if (val === val1) return true;          // Return true if values are strictly equal\n            throw \"Not Equal\";                      // Throw error if not equal\n        },\n        notToBe: function(val1) {                   // Method to assert inequality\n            if (val !== val1) return true;          // Return true if values are not equal\n            throw \"Equal\";                          // Throw error if equal\n        }\n    }\n};\n\n/**\n * expect(5).toBe(5); // true\n * expect(5).notToBe(5); // throws \"Equal\"\n */"
    },
    {
      "problemNumber": "2723",
      "title": "Add Two Promises",
      "language": "JavaScript",
      "filename": "2723-AddTwoPromises.js",
      "path": "LeetCode/JavaScript/2723-AddTwoPromises.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2723-AddTwoPromises.js",
      "approach": "Async/Await to Resolve Promises and Sum Values",
      "tags": [
        "JavaScript",
        "Promises",
        "Async/Await"
      ],
      "steps": [
        "1) Use async function to handle promises asynchronously.",
        "2) Await the resolution of the first promise to get its value.",
        "3) Await the resolution of the second promise to get its value.",
        "4) Return the sum of both resolved values.",
        "5) Alternative: Use Promise.all() to resolve both promises simultaneously."
      ],
      "timeComplexity": "O(1) - depends on promise resolution time",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: Add Two Promises\nApproach: Async/Await to Resolve Promises and Sum Values\nTags: JavaScript, Promises, Async/Await\n1) Use async function to handle promises asynchronously.\n2) Await the resolution of the first promise to get its value.\n3) Await the resolution of the second promise to get its value.\n4) Return the sum of both resolved values.\n5) Alternative: Use Promise.all() to resolve both promises simultaneously.\n\nTime Complexity: O(1) - depends on promise resolution time\nSpace Complexity: O(1)\n*/\n\n/**\n * @param {Promise} promise1\n * @param {Promise} promise2\n * @return {Promise}\n */\nvar addTwoPromises = async function(promise1, promise2) {\n    const val1 = await promise1;                    // Await and get value from first promise\n    const val2 = await promise2;                    // Await and get value from second promise\n    return val1 + val2;                             // Return sum of both values\n};\n\n/**\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\n *   .then(console.log); // 4\n */\n\n\n\n// Approach 2: Using Promise.all() for concurrent resolution\n// var addTwoPromises = function(promise1, promise2) {\n//     return Promise.all([promise1, promise2])    // Resolve both promises concurrently\n//         .then(([a, b]) => a + b);               // Destructure and sum the results\n// };\n"
    },
    {
      "problemNumber": "2724",
      "title": "Sort By",
      "language": "JavaScript",
      "filename": "2724-SortBy.js",
      "path": "LeetCode/JavaScript/2724-SortBy.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2724-SortBy.js",
      "approach": "Custom Sorting with Function-Based Comparison",
      "tags": [
        "JavaScript",
        "Array Sorting",
        "Higher-Order Functions"
      ],
      "steps": [
        "1) Use the built-in sort() method with a custom comparator function.",
        "2) Apply the given function fn to both elements being compared.",
        "3) Return the difference fn(a) - fn(b) to determine sort order.",
        "4) Positive result means a comes after b, negative means a comes before b."
      ],
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(log n) for the sorting algorithm",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/sort-by/solutions/7385305/simplest-solution-javascript-time-on-log-auxs/\nApproach: Custom Sorting with Function-Based Comparison\nTags: JavaScript, Array Sorting, Higher-Order Functions\n1) Use the built-in sort() method with a custom comparator function.\n2) Apply the given function fn to both elements being compared.\n3) Return the difference fn(a) - fn(b) to determine sort order.\n4) Positive result means a comes after b, negative means a comes before b.\n\nTime Complexity: O(n log n)\nSpace Complexity: O(log n) for the sorting algorithm\n*/\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nvar sortBy = function(arr, fn) {\n    return arr.sort((a,b) => fn(a) - fn(b));           // Sort array using custom function for comparison\n};"
    },
    {
      "problemNumber": "2726",
      "title": "Calculatorwith Method Chaining",
      "language": "JavaScript",
      "filename": "2726-CalculatorwithMethodChaining.js",
      "path": "LeetCode/JavaScript/2726-CalculatorwithMethodChaining.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2726-CalculatorwithMethodChaining.js",
      "approach": "Class-based Calculator with Fluent Interface Pattern",
      "tags": [
        "JavaScript",
        "OOP",
        "Method Chaining",
        "Class Design"
      ],
      "steps": [
        "1) Create a Calculator class that stores the current value.",
        "2) Implement arithmetic methods that modify the current value and return 'this'.",
        "3) Each method returns the instance to enable method chaining.",
        "4) Include error handling for division by zero.",
        "5) Provide getResult() method to retrieve the final computed value."
      ],
      "timeComplexity": "O(1) for each operation",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/calculator-with-method-chaining/solutions/7386749/simplest-solution-javascript-time-o1-spa-bik5/\nApproach: Class-based Calculator with Fluent Interface Pattern\nTags: JavaScript, OOP, Method Chaining, Class Design\n1) Create a Calculator class that stores the current value.\n2) Implement arithmetic methods that modify the current value and return 'this'.\n3) Each method returns the instance to enable method chaining.\n4) Include error handling for division by zero.\n5) Provide getResult() method to retrieve the final computed value.\n\nTime Complexity: O(1) for each operation\nSpace Complexity: O(1)\n*/\n\nclass Calculator {\n\n    /**\n     * @param {number} value\n     */\n    constructor(value) {\n        this.value = value;                             // Initialize calculator with starting value\n    }\n\n    /**\n     * @param {number} value\n     * @return {Calculator}\n     */\n    add(value){\n        this.value = this.value + value;                // Add value to current result\n        return this;                                    // Return this for method chaining\n    }\n\n    /**\n     * @param {number} value\n     * @return {Calculator}\n     */\n    subtract(value){\n        this.value = this.value - value;                // Subtract value from current result\n        return this;                                    // Return this for method chaining\n    }\n\n    /**\n     * @param {number} value\n     * @return {Calculator}\n     */\n    multiply(value) {\n        this.value = this.value * value;                // Multiply current result by value\n        return this;                                    // Return this for method chaining\n    }\n\n    /**\n     * @param {number} value\n     * @return {Calculator}\n     */\n    divide(value) {\n        if (value === 0) {                              // Check for division by zero\n            throw new Error(\"Division by zero is not allowed\");\n        }\n        this.value /= value;                            // Divide current result by value\n        return this;                                    // Return this for method chaining\n    }\n\n    /**\n     * @param {number} value\n     * @return {Calculator}\n     */\n    power(value) {\n        this.value = this.value ** value;               // Raise current result to the power of value\n        return this;                                    // Return this for method chaining\n    }\n\n    /**\n     * @return {number}\n     */\n    getResult() {\n        return this.value;                              // Return the final computed value\n    }\n}"
    },
    {
      "problemNumber": "2727",
      "title": "Is Object Empty",
      "language": "JavaScript",
      "filename": "2727-IsObjectEmpty.js",
      "path": "LeetCode/JavaScript/2727-IsObjectEmpty.js",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/JavaScript/2727-IsObjectEmpty.js",
      "approach": "Check Object Keys Length",
      "tags": [
        "JavaScript",
        "Object Manipulation",
        "Array"
      ],
      "steps": [
        "1) Use Object.keys() to get an array of all enumerable property names.",
        "2) Check if the length of the keys array equals 0.",
        "3) Return true if no keys exist (empty), false otherwise.",
        "4) Alternative approaches: JSON.stringify comparison or for...in loop."
      ],
      "timeComplexity": "O(n) where n is the number of keys",
      "spaceComplexity": "O(n) for the keys array",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/is-object-empty/solutions/7385292/simplest-solution-javascript-time-on-spa-b9iu/\nApproach: Check Object Keys Length\nTags: JavaScript, Object Manipulation, Array\n1) Use Object.keys() to get an array of all enumerable property names.\n2) Check if the length of the keys array equals 0.\n3) Return true if no keys exist (empty), false otherwise.\n4) Alternative approaches: JSON.stringify comparison or for...in loop.\n\nTime Complexity: O(n) where n is the number of keys\nSpace Complexity: O(n) for the keys array\n*/\n\n/**\n * @param {Object|Array} obj\n * @return {boolean}\n */\nvar isEmpty = function(obj) {\n     return Object.keys(obj).length === 0;          // Check if object has no enumerable properties\n\n     // Alternative Approach 1: JSON comparison\n     // return JSON.stringify(obj) === JSON.stringify({});\n\n     // Alternative Approach 2: for...in loop (early termination)\n     //  for (let key in obj) {\n     //   return false;   // If any key exists, not empty\n     // }\n    //  return true;        // No keys found\n};"
    },
    {
      "problemNumber": "2877",
      "title": "Createa Data Framefrom List",
      "language": "Python",
      "filename": "2877-CreateaDataFramefromList.py",
      "path": "LeetCode/Python/2877-CreateaDataFramefromList.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2877-CreateaDataFramefromList.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/create-a-dataframe-from-list/solutions/6181300/simplest-solution-python-please-upvote-b-0sq6/\n\nimport pandas as pd\n'''\nUse the pandas library to create a DataFrame from the given list of lists student_data.\nThe DataFrame should have two columns: student_id and age.\nReturn the DataFrame.\n'''\ndef createDataframe(student_data: List[List[int]]) -> pd.DataFrame:\n    df = pd.DataFrame(student_data, columns=[\"student_id\",\"age\"])   # Create a DataFrame from the given list of lists student_data\n    return df                                                       # Return the DataFrame\n"
    },
    {
      "problemNumber": "2878",
      "title": "Getthe Sizeofa Data Frame",
      "language": "Python",
      "filename": "2878-GettheSizeofaDataFrame.py",
      "path": "LeetCode/Python/2878-GettheSizeofaDataFrame.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2878-GettheSizeofaDataFrame.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/get-the-size-of-a-dataframe/solutions/6181317/simplest-solution-python-please-upvote-b-pu21/\n\nimport pandas as pd\n'''\nUsing the pandas library, get the number of rows and columns in the given DataFrame players.\nReturn a list containing the number of rows and columns in the DataFrame.\n\nThe shape property returns a tuple containing the shape of the DataFrame.\nThe shape is the number of rows and columns of the DataFrame in the form (rows, columns).\n\n'''\ndef getDataframeSize(players: pd.DataFrame) -> List[int]:\n    rows = players.shape[0]     # Get the number of rows in the DataFrame players\n    columns = players.shape[1]  # Get the number of columns in the DataFrame players\n    return [rows,columns]       # Return a list containing the number of rows and columns in the DataFrame\n"
    },
    {
      "problemNumber": "2879",
      "title": "Displaythe First Three Rows",
      "language": "Python",
      "filename": "2879-DisplaytheFirstThreeRows.py",
      "path": "LeetCode/Python/2879-DisplaytheFirstThreeRows.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2879-DisplaytheFirstThreeRows.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/display-the-first-three-rows/solutions/6181343/simplest-solution-python-please-upvote-b-2cxy/\n\nimport pandas as pd\n'''\nUsing the head() method, we can select the first n rows of a DataFrame.\nor\nUsing the iloc[] method, we can select the first n rows of a DataFrame.\nor\nUsing the slicing operator, we can select the first n rows of a DataFrame.\n'''\ndef selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:\n    return employees.head(3) # or return employees[:3] or return employees.iloc[:3]"
    },
    {
      "problemNumber": "2880",
      "title": "Select Data",
      "language": "Python",
      "filename": "2880-SelectData.py",
      "path": "LeetCode/Python/2880-SelectData.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2880-SelectData.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/select-data/post-solution/?submissionId=1487712581\nimport pandas as pd\n'''\nUsing the pandas library, select the name and age of the student with student_id 101 from the given DataFrame students.\nReturn a DataFrame containing the name and age of the student with student_id 101.\n\nThe query method is used to select rows from a DataFrame based on a condition.\nThe query method takes a string as an argument that specifies the condition for selecting rows.\nThe query method returns a DataFrame containing the rows that satisfy the condition.\n'''\ndef selectData(students: pd.DataFrame) -> pd.DataFrame:\n    # dt = students.loc[students['student_id']==101,['name','age']] # Alternative solution using the loc method\n    # dt = students[students['student_id']==101][['name','age']] # Alternative solution using boolean indexing\n    # dt = students[students['student_id']==101].loc[:,['name','age']] # Alternative solution using boolean indexing and the loc method\n    # dt = students[students['student_id']==101].iloc[:,[1,2]] # Alternative solution using boolean indexing and the iloc method\n    # dt = students[students['student_id']==101].iloc[:,1:3] # Alternative solution using boolean indexing and the iloc method\n    # dt = students.loc[students[\"student_id\"] == 101, \"name\" :] # Alternative solution using the loc method\n    dt = students.query('student_id == 101')[['name','age']] # Select the name and age of the student with student_id 101 from the DataFrame students\n    return dt\n"
    },
    {
      "problemNumber": "2881",
      "title": "Createa New Column",
      "language": "Python",
      "filename": "2881-CreateaNewColumn.py",
      "path": "LeetCode/Python/2881-CreateaNewColumn.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2881-CreateaNewColumn.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/create-a-new-column/solutions/6184192/simplest-solution-python-time-on-space1-onoy2/\nimport pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of employees and adds a new column called \"Bonus\" that is twice the value of the \"Salary\" column.\n'''\ndef createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['bonus'] = employees['salary'] * 2\n    return employees"
    },
    {
      "problemNumber": "2882",
      "title": "Drop Duplicate Rows",
      "language": "Python",
      "filename": "2882-DropDuplicateRows.py",
      "path": "LeetCode/Python/2882-DropDuplicateRows.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2882-DropDuplicateRows.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "import pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of customers and removes any duplicate rows based on the \"email\" column.\ndrop_duplicates is a pandas function that removes duplicate rows from a DataFrame.\n'''\ndef dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:\n    dup_customers_removed = customers.drop_duplicates(subset=['email']) # drop_duplicates removes duplicate rows from a DataFrame\n    return dup_customers_removed                                        # return the DataFrame with duplicate rows removed"
    },
    {
      "problemNumber": "2883",
      "title": "Drop Missing Data",
      "language": "Python",
      "filename": "2883-DropMissingData.py",
      "path": "LeetCode/Python/2883-DropMissingData.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2883-DropMissingData.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "import pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of students and removes any rows where the \"name\" column is missing.\ndropna is a pandas function that removes rows with missing data from a DataFrame.\n'''\ndef dropMissingData(students: pd.DataFrame) -> pd.DataFrame:\n    dropped_students = students.dropna(subset=[\"name\"]) # dropna removes rows with missing data from a DataFrame\n    return dropped_students                             # return the DataFrame with rows where the \"name\" column is missing removed\n"
    },
    {
      "problemNumber": "2884",
      "title": "Modify Columns",
      "language": "Python",
      "filename": "2884-ModifyColumns.py",
      "path": "LeetCode/Python/2884-ModifyColumns.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2884-ModifyColumns.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/modify-columns/solutions/6184583/simplest-solution-python-please-upvote-b-29ha/\nimport pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of employees and modifies the \"Salary\" column to be twice its original value.\n'''\ndef modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['salary'] = employees['salary'] * 2   # modify the \"salary\" column to be twice its original value\n    # or employees.salary *= 2\n    return employees                                # return the DataFrame with the \"salary\" column modified"
    },
    {
      "problemNumber": "2885",
      "title": "Rename Columns",
      "language": "Python",
      "filename": "2885-RenameColumns.py",
      "path": "LeetCode/Python/2885-RenameColumns.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2885-RenameColumns.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "import pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of students and renames the columns to \"student_id\", \"first_name\", \"last_name\", and \"age_in_years\".\n.columns is a pandas attribute that allows you to rename the columns of a DataFrame.\n'''\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\n    students.columns = ['student_id', 'first_name', 'last_name', 'age_in_years']    # rename the columns of the DataFrame\n    return students                                                                 # return the DataFrame with the columns renamed"
    },
    {
      "problemNumber": "2886",
      "title": "Change Data Type",
      "language": "Python",
      "filename": "2886-ChangeDataType.py",
      "path": "LeetCode/Python/2886-ChangeDataType.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2886-ChangeDataType.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/change-data-type/solutions/6184629/simplest-solution-python-please-upvote-b-ouv7/\nimport pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of students and changes the datatype of the \"grade\" column to int.\nastype is a pandas function that changes the datatype of a column in a DataFrame.\n'''\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\n    students['grade'] = students['grade'].astype(int) # change the datatype of the \"grade\" column to int\n    return students"
    },
    {
      "problemNumber": "2887",
      "title": "Fill Missing Data",
      "language": "Python",
      "filename": "2887-FillMissingData.py",
      "path": "LeetCode/Python/2887-FillMissingData.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2887-FillMissingData.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "import pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of products and fills any missing values with 0.\nfillna is a pandas function that fills missing values in a DataFrame with a specified value.\n'''\ndef fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:\n    products['quantity'] = products['quantity'].fillna(0)   # fillna fills missing values in a DataFrame with a specified value\n"
    },
    {
      "problemNumber": "2888",
      "title": "Reshape Data Concatenate",
      "language": "Python",
      "filename": "2888-ReshapeDataConcatenate.py",
      "path": "LeetCode/Python/2888-ReshapeDataConcatenate.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2888-ReshapeDataConcatenate.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "import pandas as pd\n'''\nUsing the pandas library, create a function that takes two DataFrames and concatenates them into a single DataFrame.\npd.concat is a pandas function that concatenates two DataFrames into a single DataFrame.\nor\npd._append is a pandas function that concatenates two DataFrames into a single DataFrame.\n'''\ndef concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:\n    df1 = df1._append(df2)\n    return df1\n\n    # or return pd.concat([df1,df2])"
    },
    {
      "problemNumber": "2889",
      "title": "Reshape Data Pivot",
      "language": "Python",
      "filename": "2889-ReshapeDataPivot.py",
      "path": "LeetCode/Python/2889-ReshapeDataPivot.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2889-ReshapeDataPivot.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "import pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of weather data and reshapes it into a pivot table.\npivot is a pandas function that reshapes a DataFrame into a pivot table.\nindex is the column to use as the index of the pivot table. The column that we need to keep\ncolumns is the column to use as the columns of the pivot table. The column that we need to spread\nvalues is the column to use as the values of the pivot table. The column that we need to spread\n'''\ndef pivotTable(weather: pd.DataFrame) -> pd.DataFrame:\n    return weather.pivot(index=\"month\", columns=\"city\", values=\"temperature\")\n"
    },
    {
      "problemNumber": "2890",
      "title": "Reshape Data Melt",
      "language": "Python",
      "filename": "2890-ReshapeDataMelt.py",
      "path": "LeetCode/Python/2890-ReshapeDataMelt.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2890-ReshapeDataMelt.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "# https://leetcode.com/problems/reshape-data-melt/solutions/6189074/simplest-solution-python-please-upvote-b-5xgw/\nimport pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of quarterly sales data and reshapes it into a long format.\nmelt is a pandas function that reshapes a DataFrame into a long format.\nid_vars is the column to use as identifier variables.\nvar_name is the name of the column that will contain the variable names.\nvalue_name is the name of the column that will contain the values.\n'''\ndef meltTable(report: pd.DataFrame) -> pd.DataFrame:\n    return pd.melt(report, id_vars=['product'], var_name='quarter', value_name='sales')\n"
    },
    {
      "problemNumber": "2891",
      "title": "Method Chaining",
      "language": "Python",
      "filename": "2891-MethodChaining.py",
      "path": "LeetCode/Python/2891-MethodChaining.py",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/Python/2891-MethodChaining.py",
      "approach": "",
      "tags": [],
      "steps": [],
      "timeComplexity": "",
      "spaceComplexity": "",
      "solutionLink": "",
      "code": "import pandas as pd\n'''\nUsing the pandas library, create a function that takes a DataFrame of animals and returns only the rows where the \"weight\" column is greater than 100, sorted in descending order by weight, and only including the \"name\" column.\nquery is a pandas function that filters a DataFrame based on a query string.\n'''\ndef findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:\n    return animals.query('weight > 100').sort_values(by='weight',ascending=False)[['name']] # query filters the DataFrame to only include rows where the weight column is greater than 100, sort_values sorts the DataFrame by the weight column in descending order, and [['name']] returns a DataFrame with only the name column\n"
    },
    {
      "problemNumber": "2965",
      "title": "Find Missingand Repeated Values",
      "language": "C#",
      "filename": "2965-FindMissingandRepeatedValues.cs",
      "path": "LeetCode/C#/2965-FindMissingandRepeatedValues.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/2965-FindMissingandRepeatedValues.cs",
      "approach": "1. Create a hashset to store the unique elements.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Create a hashset to store the unique elements.\n2. Calculate the sum of all the elements in the grid.\n3. Calculate the sum of the first n natural numbers.\n4. The difference between the sum of the first n natural numbers and the sum of the elements in the grid will give the missing element.\n5. The repeated element is the element that is repeated in the grid.\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n*/\npublic class Solution {\n    public int[] FindMissingAndRepeatedValues(int[][] grid) {\n        HashSet<int> hs = new HashSet<int>();       // Declare a hashset to store the unique elements.\n        int sum = 0;                                // Declare a variable to store the sum of all the elements in the grid.    \n        int[] result = new int[2];                  // Declare an array to store the missing and repeated elements.\n        int n = grid[0].Length * grid[0].Length;    // Calculate the number of elements in the grid.\n\n        foreach(int[] arr in grid) {                // Iterate through the grid.\n            foreach(int num in arr) {               // Iterate through the elements in the grid.\n                if(!hs.Contains(num)) {             // Check if the element is not present in the hashset.\n                    hs.Add(num);                    // Add the element to the hashset.\n                }\n                else {\n                    result[0] = num;                // Store the repeated element in the result array.\n                }\n                sum+=num;                           // Calculate the sum of all the elements in the grid.\n            }\n        }\n        sum -= result[0];                           // Subtract the repeated element from the sum.\n        result[1] = (n*(n+1)/2) - sum;              // Calculate the missing element.\n        return result;                              // Return the result array.\n    }\n}"
    },
    {
      "problemNumber": "3000",
      "title": "Maximum Areaof Longest Diagonal Rectangle",
      "language": "C#",
      "filename": "3000-MaximumAreaofLongestDiagonalRectangle.cs",
      "path": "LeetCode/C#/3000-MaximumAreaofLongestDiagonalRectangle.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3000-MaximumAreaofLongestDiagonalRectangle.cs",
      "approach": "",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "steps": [
        "1) For each rectangle, calculate the squared diagonal (length^2 + breadth^2).",
        "2) Track the maximum diagonal found so far and the corresponding area.",
        "3) If a rectangle has a longer diagonal, update both maxDiagonal and maxArea.",
        "4) If a rectangle has the same diagonal as the current max, update maxArea if its area is larger.",
        "5) Return the area of the rectangle with the longest diagonal (and largest area if tie)."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "\n/*\nSolution: https://leetcode.com/problems/maximum-area-of-longest-diagonal-rectangle/solutions/7123509/simplest-solution-c-time-on-space1-pleas-etb0/\nTags: Array, Math, Geometry\n1) For each rectangle, calculate the squared diagonal (length^2 + breadth^2).\n2) Track the maximum diagonal found so far and the corresponding area.\n3) If a rectangle has a longer diagonal, update both maxDiagonal and maxArea.\n4) If a rectangle has the same diagonal as the current max, update maxArea if its area is larger.\n5) Return the area of the rectangle with the longest diagonal (and largest area if tie).\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int AreaOfMaxDiagonal(int[][] dimensions) {\n        int maxDiagonal = int.MinValue;                  // Tracks the largest diagonal found (squared)\n        int maxArea = int.MinValue;                      // Tracks the largest area for max diagonal\n        foreach(int[] arr in dimensions) {               // Iterate through each rectangle\n            int length = arr[0];                         // Rectangle length\n            int breath = arr[1];                         // Rectangle breadth\n            int diagonal = (length * length) + (breath * breath); // Squared diagonal length\n            if (diagonal > maxDiagonal) {                // If this diagonal is the largest so far\n               maxArea =  length * breath;               // Update max area\n               maxDiagonal = diagonal;                   // Update max diagonal\n            }\n            else if (diagonal == maxDiagonal) {          // If diagonal ties with current max\n                maxArea = Math.Max(maxArea, length * breath); // Take the larger area\n            }\n        }\n        return maxArea;                                 // Return area of rectangle with max diagonal\n    }\n}"
    },
    {
      "problemNumber": "3021",
      "title": "Aliceand Bob Playing Flower Game",
      "language": "C#",
      "filename": "3021-AliceandBobPlayingFlowerGame.cs",
      "path": "LeetCode/C#/3021-AliceandBobPlayingFlowerGame.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3021-AliceandBobPlayingFlowerGame.cs",
      "approach": "Math, Parity Counting",
      "tags": [
        "Math",
        "Combinatorics"
      ],
      "steps": [
        "1) Alice and Bob take turns picking flowers from two rows of n and m flowers.",
        "2) The number of ways Alice can win is the number of pairs (i, j) where i + j is odd.",
        "3) This is equivalent to counting odd-even and even-odd pairs between the two rows.",
        "4) Calculate odd/even counts for both n and m, then multiply accordingly.",
        "5) Return the total number of such pairs."
      ],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/alice-and-bob-playing-flower-game/solutions/7134602/simplest-solution-c-time-o1-space1-pleas-2xa1/\nApproach: Math, Parity Counting\nTags: Math, Combinatorics\n1) Alice and Bob take turns picking flowers from two rows of n and m flowers.\n2) The number of ways Alice can win is the number of pairs (i, j) where i + j is odd.\n3) This is equivalent to counting odd-even and even-odd pairs between the two rows.\n4) Calculate odd/even counts for both n and m, then multiply accordingly.\n5) Return the total number of such pairs.\n\nTime Complexity: O(1)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public long FlowerGame(int n, int m) {\n        long aliceTakesNFirst = ((long)(n + 1) / 2) * (m / 2);   // Cast to long before multiplication\n        long aliceTakesMFirst = ((long)(m + 1) / 2) * (n / 2);   // Cast to long before multiplication\n\n        return aliceTakesNFirst + aliceTakesMFirst;\n    }\n}"
    },
    {
      "problemNumber": "3042",
      "title": "Count Prefixand Suffix Pairs I",
      "language": "C#",
      "filename": "3042-CountPrefixandSuffixPairsI.cs",
      "path": "LeetCode/C#/3042-CountPrefixandSuffixPairsI.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3042-CountPrefixandSuffixPairsI.cs",
      "approach": "Brute Force",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Brute Force\n1. For each word in the array, check if it is prefix and suffix of any other word in the array.\n2. If it is, increment the result.\n3. Return the result.\n\nTime complexity: O(n^2)\nSpace complexity: O(1)\n*/\npublic class Solution {\n    public int CountPrefixSuffixPairs(string[] words) {\n        int result = 0;                                                             // declare result and initialize it to 0\n        for(int i=0; i<words.Length; i++) {                                         // iterate through the words array\n            for(int j=0; j<words.Length; j++) {                                     // iterate through the words array\n                if(i==j || i>j ) continue;                                          // if i is equal to j or i is greater than j, continue\n                if(words[j].StartsWith(words[i]) && words[j].EndsWith(words[i])) {  // check if the word at index j is prefix and suffix of the word at index i\n                    result++;                                                       // increment the result\n                }\n            }\n        }\n        return result;                                                              // return the result\n    }\n}"
    },
    {
      "problemNumber": "3151",
      "title": "Special Array I",
      "language": "C#",
      "filename": "3151-SpecialArrayI.cs",
      "path": "LeetCode/C#/3151-SpecialArrayI.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3151-SpecialArrayI.cs",
      "approach": "1. Iterate through the array from 1 to n-1.",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach:\n1. Iterate through the array from 1 to n-1.\n2. Check if the current element and the previous element are both even or both odd.\n3. If they are, return false.\n4. If the loop completes, return true.\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public bool IsArraySpecial(int[] nums) {\n        for(int i=1; i<nums.Length; i++) {      //  Iterating through the array from 1 to n-1\n            if(nums[i]%2 == nums[i-1]%2)        //  Checking if the current element and the previous element are both even or both odd\n                return false;                   //  If they are, return false\n        }\n        return true;                            //  If the loop completes, return true\n    }\n}"
    },
    {
      "problemNumber": "3169",
      "title": "Count Days Without Meetings",
      "language": "C#",
      "filename": "3169-CountDaysWithoutMeetings.cs",
      "path": "LeetCode/C#/3169-CountDaysWithoutMeetings.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3169-CountDaysWithoutMeetings.cs",
      "approach": "Greedy",
      "tags": [],
      "steps": [],
      "timeComplexity": "O(nlogn) where n is the number of meetings. Sorting the meetings takes O(nlogn) time.",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/count-days-without-meetings/solutions/6578015/simplest-solution-c-time-onlogn-space1-p-bvp4/\nApproach: Greedy\n1. Sort the meetings based on the start time.\n2. Initialize freedays to 0 and prevEnd to 0.\n3. Iterate through the meetings.\n4. If the previous end time is less than the current meeting start time, add the difference between the start time and previous end time to freedays.\n5. Update the previous end time to the maximum of the end time of the current meeting and the previous end time.\n6. Return the sum of freedays and the difference between the days and the previous end time.\n\nTime complexity: O(nlogn) where n is the number of meetings. Sorting the meetings takes O(nlogn) time.\nSpace complexity: O(1)\n\n*/\npublic class Solution {\n    public int CountDays(int days, int[][] meetings) {\n        Array.Sort(meetings, (a,b) => a[0] - b[0]);         // Sort the meetings based on the start time\n        int freedays = 0;                                   // Initialize freedays to 0\n        int prevEnd = 0;                                    // Initialize prevEnd to 0\n        foreach (int[] meeting in meetings) {               // Iterate through the meetings\n\n            int meetingStart = meeting[0];                  // Get the start time of the meeting\n            int meetingEnd = meeting[1];                    // Get the end time of the meeting\n\n            if (prevEnd < meetingStart) {                   // If the previous end time is less than the current meeting start time\n                freedays += meetingStart - prevEnd - 1;     // Add the difference between the start time and previous end time to freedays\n            }\n            prevEnd = Math.Max(meetingEnd, prevEnd);        // Update the previous end time to the maximum of the end time of the current meeting and the previous end time\n        }\n\n        return freedays + (days - prevEnd);                 // Return the sum of freedays and the difference between the days and the previous end time\n    }\n}"
    },
    {
      "problemNumber": "3190",
      "title": "Find Minimum Operationsto Make All Elements Divisibleby Three",
      "language": "C#",
      "filename": "3190-FindMinimumOperationstoMakeAllElementsDivisiblebyThree.cs",
      "path": "LeetCode/C#/3190-FindMinimumOperationstoMakeAllElementsDivisiblebyThree.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3190-FindMinimumOperationstoMakeAllElementsDivisiblebyThree.cs",
      "approach": "Calculate Remainder and Determine Minimum Operations",
      "tags": [
        "Array",
        "Math",
        "Greedy"
      ],
      "steps": [
        "1) For each number, calculate the remainder when divided by 3.",
        "2) If remainder is 0, no operation needed (already divisible by 3).",
        "3) If remainder is 1, need 1 operation (add 2 or subtract 1).",
        "4) If remainder is 2, need 1 operation (add 1 or subtract 2).",
        "5) Use Math.Min(num % 3, 1) to get 0 or 1 operation count.",
        "6) Sum all operations needed for all elements."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/solutions/7366777/simplest-solution-c-time-on-space1-pleas-rz6e/\nApproach: Calculate Remainder and Determine Minimum Operations\nTags: Array, Math, Greedy\n1) For each number, calculate the remainder when divided by 3.\n2) If remainder is 0, no operation needed (already divisible by 3).\n3) If remainder is 1, need 1 operation (add 2 or subtract 1).\n4) If remainder is 2, need 1 operation (add 1 or subtract 2).\n5) Use Math.Min(num % 3, 1) to get 0 or 1 operation count.\n6) Sum all operations needed for all elements.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int MinimumOperations(int[] nums) {\n        int result = 0;                                         // Counter for total operations\n        foreach (int num in nums) {                             // Iterate through each number\n            result = result + Math.Min(num % 3, 1);             // Add 0 if divisible by 3, else add 1\n        }\n        return result;                                          // Return total minimum operations needed\n    }\n}"
    },
    {
      "problemNumber": "3264",
      "title": "Final Array State After K Multiplication Operations I",
      "language": "C#",
      "filename": "3264-FinalArrayStateAfterKMultiplicationOperationsI.cs",
      "path": "LeetCode/C#/3264-FinalArrayStateAfterKMultiplicationOperationsI.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3264-FinalArrayStateAfterKMultiplicationOperationsI.cs",
      "approach": "Brute Force",
      "tags": [],
      "steps": [
        "1) Find the minimum element in the array.",
        "2) Multiply the minimum element by the multiplier.",
        "3) Repeat the above steps k times.",
        "4) Return the final state of the array."
      ],
      "timeComplexity": "O(k*n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nApproach: Brute Force\n1) Find the minimum element in the array.\n2) Multiply the minimum element by the multiplier.\n3) Repeat the above steps k times.\n4) Return the final state of the array.\n\nTime Complexity: O(k*n)\nSpace Complexity: O(1)\n\n*/\npublic class Solution {\n    public int[] GetFinalState(int[] nums, int k, int multiplier) {\n        int min = int.MaxValue;                                 // Initialize the minimum element to the maximum value\n        int minIndex = -1;                                      // Initialize the index of the minimum element to -1\n        for(int i=0; i<k; i++) {                                // Repeat the above steps k times\n            for(int j=nums.Length-1; j>=0; j--) {               // Find the minimum element in the array\n                if(nums[j] <= min) {                            // Check if the current element is less than or equal to the minimum element\n                    min = nums[j];                              // Update the minimum element\n                    minIndex = j;                               // Update the index of the minimum element\n                }\n            }\n            nums[minIndex] = nums[minIndex] * multiplier;       // Multiply the minimum element by the multiplier\n            min = int.MaxValue;                                 // Reset the minimum element to the maximum value\n        }\n\n        return nums;                                            // Return the final state of the array\n    }\n}\n\n// Better Approach: Using Priority Queue\n// TODO"
    },
    {
      "problemNumber": "3370",
      "title": "Smallest Number With All Set Bits",
      "language": "C#",
      "filename": "3370-SmallestNumberWithAllSetBits.cs",
      "path": "LeetCode/C#/3370-SmallestNumberWithAllSetBits.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3370-SmallestNumberWithAllSetBits.cs",
      "approach": "Bit Manipulation - Check for Numbers of Form (2^k - 1)",
      "tags": [
        "Bit Manipulation",
        "Math",
        "Brute Force"
      ],
      "steps": [
        "1) Start from the given number n and iterate upwards.",
        "2) For each number, check if it has all bits set (form 2^k - 1).",
        "3) Use bit trick: n & (n+1) == 0 to check if all bits are set.",
        "4) Return the first number that satisfies this condition.",
        "5) Numbers with all set bits: 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023..."
      ],
      "timeComplexity": "O(m) where m is the difference between n and result",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/smallest-number-with-all-set-bits/solutions/7310831/simplest-solution-c-time-on-space1-pleas-p9i9/\nApproach: Bit Manipulation - Check for Numbers of Form (2^k - 1)\nTags: Bit Manipulation, Math, Brute Force\n1) Start from the given number n and iterate upwards.\n2) For each number, check if it has all bits set (form 2^k - 1).\n3) Use bit trick: n & (n+1) == 0 to check if all bits are set.\n4) Return the first number that satisfies this condition.\n5) Numbers with all set bits: 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023...\n\nTime Complexity: O(m) where m is the difference between n and result\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int SmallestNumber(int n) {\n        int result = n;                                         // Store original n (unused variable)\n        while(true) {                                           // Iterate indefinitely until solution found\n            if ((n & (n + 1)) == 0) {                            // Check if n has all bits set (2^k - 1 form) ex 7 & 8 == 0. 111 & 1000 == 0000\n                return n;                                       // Return first number with all set bits\n            }\n            n++;                                                // Move to next number\n        }\n        return -1;                                              // This line is unreachable since solution always exists\n    }\n}"
    },
    {
      "problemNumber": "3392",
      "title": "Count Subarraysof Length Three Witha Condition",
      "language": "C#",
      "filename": "3392-CountSubarraysofLengthThreeWithaCondition.cs",
      "path": "LeetCode/C#/3392-CountSubarraysofLengthThreeWithaCondition.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3392-CountSubarraysofLengthThreeWithaCondition.cs",
      "approach": "Sliding Window",
      "tags": [],
      "steps": [
        "1) We need to find the number of subarrays of length 3 such that the sum of the first and last elements is equal to twice the middle element.",
        "2) We can use a sliding window of size 3 to check each subarray.",
        "3) We will maintain three pointers: a, b, and c.",
        "4) a will point to the first element of the subarray, b will point to the middle element, and c will point to the last element.",
        "5) We will check if the sum of the first and last elements is equal to twice the middle element.",
        "6) If it is, we will increment the count.",
        "7) We will move the window by incrementing a, b, and c.",
        "8) We will return the count at the end."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/count-subarrays-of-length-three-with-a-condition/solutions/6691977/simplest-solution-c-time-on-space1-pleas-0ee5/\nApproach: Sliding Window\n1) We need to find the number of subarrays of length 3 such that the sum of the first and last elements is equal to twice the middle element.\n2) We can use a sliding window of size 3 to check each subarray.\n3) We will maintain three pointers: a, b, and c.\n4) a will point to the first element of the subarray, b will point to the middle element, and c will point to the last element.\n5) We will check if the sum of the first and last elements is equal to twice the middle element.\n6) If it is, we will increment the count.\n7) We will move the window by incrementing a, b, and c.\n8) We will return the count at the end.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int CountSubarrays(int[] nums) {\n        int a=0;                                    // First element of the subarray\n        int c=2;                                    // Last element of the subarray\n        int b=1;                                    // Middle element of the subarray\n        int count=0;                                // Count of subarrays satisfying the condition\n        while(c < nums.Length) {                    // Loop until the last element of the array\n            if (2*(nums[a]+nums[c]) == nums[b]) {   // Check if the sum of the first and last elements is equal to twice the middle element. Not dividing because of decimal comparison\n                count++;                            // Increment the count if the condition is satisfied\n            }\n            a++;                                    // Move the first element of the subarray\n            b++;                                    // Move the middle element of the subarray\n            c++;                                    // Move the last element of the subarray\n        }\n        return count;                               // Return the count of subarrays satisfying the condition\n    }\n}"
    },
    {
      "problemNumber": "3396",
      "title": "Minimum Numberof Operationsto Make Elementsin Array Distinct",
      "language": "C#",
      "filename": "3396-MinimumNumberofOperationstoMakeElementsinArrayDistinct.cs",
      "path": "LeetCode/C#/3396-MinimumNumberofOperationstoMakeElementsinArrayDistinct.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3396-MinimumNumberofOperationstoMakeElementsinArrayDistinct.cs",
      "approach": "Using HashSet and Reverse Iteration",
      "tags": [],
      "steps": [
        "1) We will use a HashSet to store the unique elements of the array.",
        "2) We will iterate through the array in reverse order.",
        "3) For each element, we will check if it is already in the HashSet.",
        "4) If it is, we will return the number of operations needed to make the elements distinct.",
        "5) If it is not, we will add it to the HashSet.",
        "6) If we finish iterating through the array without finding any duplicates, we will return 0."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/solutions/6630129/simplest-solution-c-time-on-spacen-pleas-29rf/\nApproach: Using HashSet and Reverse Iteration\n1) We will use a HashSet to store the unique elements of the array.\n2) We will iterate through the array in reverse order.\n3) For each element, we will check if it is already in the HashSet.\n4) If it is, we will return the number of operations needed to make the elements distinct.\n5) If it is not, we will add it to the HashSet.\n6) If we finish iterating through the array without finding any duplicates, we will return 0.\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n*/\npublic class Solution {\n    public int MinimumOperations(int[] nums) {\n        HashSet<int> hs = new HashSet<int>();         // HashSet to store unique elements\n        for(int i=nums.Length - 1; i>=0; i--) {       // Reverse iterate through the array\n            if (hs.Contains(nums[i])) {               // If the element is already in the HashSet\n                return (int)Math.Ceiling((i+1)/3.0);  // Return the number of operations needed\n            }\n            hs.Add(nums[i]);                          // Add the element to the HashSet\n        }\n        return 0;                                     // If all elements are unique, return 0\n    }\n}\n"
    },
    {
      "problemNumber": "3432",
      "title": "Count Partitionswith Even Sum Difference",
      "language": "C#",
      "filename": "3432-CountPartitionswithEvenSumDifference.cs",
      "path": "LeetCode/C#/3432-CountPartitionswithEvenSumDifference.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3432-CountPartitionswithEvenSumDifference.cs",
      "approach": "Prefix Sum with Two Pointers Technique",
      "tags": [
        "Array",
        "Prefix Sum",
        "Math"
      ],
      "steps": [
        "1) Calculate the total sum of all elements (initial right sum).",
        "2) Iterate through the array, treating each position as a partition point.",
        "3) For each position, update left sum by adding current element.",
        "4) Update right sum by removing current element.",
        "5) Calculate the absolute difference between left and right sums.",
        "6) If the difference is even, increment the count."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/count-partitions-with-even-sum-difference/solutions/7394579/simplest-solution-c-time-on-space1-pleas-7joj/\nApproach: Prefix Sum with Two Pointers Technique\nTags: Array, Prefix Sum, Math\n1) Calculate the total sum of all elements (initial right sum).\n2) Iterate through the array, treating each position as a partition point.\n3) For each position, update left sum by adding current element.\n4) Update right sum by removing current element.\n5) Calculate the absolute difference between left and right sums.\n6) If the difference is even, increment the count.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int CountPartitions(int[] nums) {\n\n        int result = 0;                                         // Counter for valid partitions\n        int rightCurrentSum = 0;                                // Sum of elements on the right side\n        int leftCurrentSum = 0;                                 // Sum of elements on the left side\n\n        foreach(int num in nums) {                              // Calculate total sum (initial right sum)\n            rightCurrentSum += num;\n        }\n\n        for(int i = 0; i < nums.Length - 1; i++) {             // Iterate through partition points\n            leftCurrentSum = nums[i] + leftCurrentSum;          // Add current element to left sum\n            rightCurrentSum = rightCurrentSum - nums[i];        // Remove current element from right sum\n            int diff = leftCurrentSum - rightCurrentSum;        // Calculate difference between sums\n            if (Math.Abs(diff) % 2 == 0) {                      // Check if absolute difference is even\n                result++;                                       // Increment count for valid partition\n            }\n        }\n\n        return result;                                          // Return total count of valid partitions\n    }\n}"
    },
    {
      "problemNumber": "3477",
      "title": "Fruits Into Baskets I I",
      "language": "C#",
      "filename": "3477-FruitsIntoBasketsII.cs",
      "path": "LeetCode/C#/3477-FruitsIntoBasketsII.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3477-FruitsIntoBasketsII.cs",
      "approach": "Iteration with Greedy Matching",
      "tags": [
        "Array",
        "Greedy",
        "Simulation"
      ],
      "steps": [
        "1) Initialize counter for placed fruits.",
        "2) Iterate through each fruit in the fruits array.",
        "3) For each fruit, find the first basket that can accommodate it (fruit <= basket capacity).",
        "4) If a suitable basket is found, place the fruit and mark basket as used (-1).",
        "5) Count total placed fruits during the process.",
        "6) Return the number of unplaced fruits (total fruits - placed fruits)."
      ],
      "timeComplexity": "O(n * m) where n = fruits.length, m = baskets.length",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/fruits-into-baskets-ii/solutions/7047747/simplest-solution-c-time-onm-space1-plea-gfdo/\nApproach: Iteration with Greedy Matching\nTags: Array, Greedy, Simulation\n1) Initialize counter for placed fruits.\n2) Iterate through each fruit in the fruits array.\n3) For each fruit, find the first basket that can accommodate it (fruit <= basket capacity).\n4) If a suitable basket is found, place the fruit and mark basket as used (-1).\n5) Count total placed fruits during the process.\n6) Return the number of unplaced fruits (total fruits - placed fruits).\n\nTime Complexity: O(n * m) where n = fruits.length, m = baskets.length\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int NumOfUnplacedFruits(int[] fruits, int[] baskets) {\n\n        int placedFruits = 0;                                       // Counter for successfully placed fruits\n\n        foreach(int fruit in fruits) {                              // Iterate through each fruit\n\n            for(int i=0; i<baskets.Length; i++) {                   // Check each basket for placement\n                if (fruit <= baskets[i]) {                          // If fruit fits in current basket\n                    placedFruits++;                                 // Increment placed fruits counter\n                    baskets[i] = -1;                                // Mark basket as used (set to -1)\n                    break;                                          // Move to next fruit\n                }\n            }\n        }\n\n        return fruits.Length - placedFruits;                        // Return number of unplaced fruits\n    }\n}"
    },
    {
      "problemNumber": "3487",
      "title": "Maximum Unique Subarray Sum After Deletion",
      "language": "C#",
      "filename": "3487-MaximumUniqueSubarraySumAfterDeletion.cs",
      "path": "LeetCode/C#/3487-MaximumUniqueSubarraySumAfterDeletion.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3487-MaximumUniqueSubarraySumAfterDeletion.cs",
      "approach": "Iteration",
      "tags": [
        "Array",
        "Greedy",
        "Iteration",
        "Dictionary",
        "Hash-Table"
      ],
      "steps": [
        "1) Iterate through the array and maintain a sum of positive unique numbers.",
        "2) Use an array to track seen numbers (from 0 to 100).",
        "3) If a number is negative or zero, keep track of the maximum negative number.",
        "4) If the sum of positive numbers is zero, return the maximum negative number.",
        "5) Otherwise, return the sum of positive unique numbers."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/maximum-unique-subarray-sum-after-deletion/solutions/7016748/simplest-solution-c-time-on-space1-pleas-in2n/\nApproach: Iteration\nVideo: https://www.youtube.com/watch?v=0Q4cqxmR0qc\nTags: Array, Greedy, Iteration, Dictionary, Hash-Table\n1) Iterate through the array and maintain a sum of positive unique numbers.\n2) Use an array to track seen numbers (from 0 to 100).\n3) If a number is negative or zero, keep track of the maximum negative number.\n4) If the sum of positive numbers is zero, return the maximum negative number.\n5) Otherwise, return the sum of positive unique numbers.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution\n{\n    public int MaxSum(int[] nums)\n    {\n        int sum = 0;                                // Initialize sum of positive unique numbers\n        int[] seen = new int[101];                  // Array to track seen numbers (0 to 100)\n        int maxNeg = int.MinValue;                  // Initialize max negative number\n\n        foreach (int num in nums)                   // Iterate through each number in the array\n        {\n            if (num > 0 && seen[num] == 0)          // If the number is positive and not seen before\n            {\n                seen[num] = 1;                      // Mark the number as seen\n                sum = sum + num;                    // Add the number to the sum\n            }\n            else if (num <= 0)                      // If the number is negative or zero\n            {\n                maxNeg = Math.Max(maxNeg, num);     // Update the maximum negative number\n            }\n        }\n\n        return sum == 0 ? maxNeg : sum;             // Return the sum of positive unique numbers or the maximum negative number if sum is zero\n    }\n}"
    },
    {
      "problemNumber": "3512",
      "title": "Minimum Operationsto Make Array Sum Divisibleby K",
      "language": "C#",
      "filename": "3512-MinimumOperationstoMakeArraySumDivisiblebyK.cs",
      "path": "LeetCode/C#/3512-MinimumOperationstoMakeArraySumDivisiblebyK.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3512-MinimumOperationstoMakeArraySumDivisiblebyK.cs",
      "approach": "Calculate Sum Remainder and Determine Operations Needed",
      "tags": [
        "Array",
        "Math",
        "Modular Arithmetic"
      ],
      "steps": [
        "1) Calculate the total sum of all elements in the array.",
        "2) Find the remainder when the sum is divided by k.",
        "3) The remainder represents the minimum operations needed.",
        "4) If remainder is 0, no operations are needed (sum is already divisible by k).",
        "5) Otherwise, we need to remove 'remainder' amount to make sum divisible by k."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: Minimum Operations to Make Array Sum Divisible by K\nApproach: Calculate Sum Remainder and Determine Operations Needed\nTags: Array, Math, Modular Arithmetic\n1) Calculate the total sum of all elements in the array.\n2) Find the remainder when the sum is divided by k.\n3) The remainder represents the minimum operations needed.\n4) If remainder is 0, no operations are needed (sum is already divisible by k).\n5) Otherwise, we need to remove 'remainder' amount to make sum divisible by k.\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int MinOperations(int[] nums, int k) {\n        int sum = 0;                                            // Initialize sum counter\n        foreach (int num in nums) {                             // Iterate through each element\n            sum += num;                                         // Add each element to total sum\n        }\n        return sum % k;                                         // Return remainder (minimum operations needed)\n    }\n}"
    },
    {
      "problemNumber": "3516",
      "title": "Find Closest Person",
      "language": "C#",
      "filename": "3516-FindClosestPerson.cs",
      "path": "LeetCode/C#/3516-FindClosestPerson.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3516-FindClosestPerson.cs",
      "approach": "Calculate Manhattan Distance and Compare",
      "tags": [
        "Math",
        "Distance Calculation"
      ],
      "steps": [
        "1) Calculate the absolute distance from person at position x to position z.",
        "2) Calculate the absolute distance from person at position y to position z.",
        "3) If both distances are equal, return 0 (tie).",
        "4) If first person is closer, return 1; otherwise return 2."
      ],
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/find-closest-person/solutions/7155756/simplest-solution-c-time-o1-space1-pleas-nyhr/\nApproach: Calculate Manhattan Distance and Compare\nTags: Math, Distance Calculation\n1) Calculate the absolute distance from person at position x to position z.\n2) Calculate the absolute distance from person at position y to position z.\n3) If both distances are equal, return 0 (tie).\n4) If first person is closer, return 1; otherwise return 2.\n\nTime Complexity: O(1)\nSpace Complexity: O(1)\n*/\npublic class Solution {\n    public int FindClosest(int x, int y, int z) {\n        int firstPersonDistance = Math.Abs(z - x);              // Distance from person at x to position z\n        int secondPersonDistance = Math.Abs(z - y);             // Distance from person at y to position z\n        if (firstPersonDistance == secondPersonDistance) {      // If distances are equal\n            return 0;                                           // Return 0 for tie\n        }\n\n        return firstPersonDistance < secondPersonDistance ? 1 : 2;  // Return 1 if first person closer, 2 otherwise\n    }\n}"
    },
    {
      "problemNumber": "3541",
      "title": "Find Most Frequent Voweland Consonant",
      "language": "C#",
      "filename": "3541-FindMostFrequentVowelandConsonant.cs",
      "path": "LeetCode/C#/3541-FindMostFrequentVowelandConsonant.cs",
      "githubUrl": "https://github.com/vermavarun/coding/blob/main/LeetCode/C%23/3541-FindMostFrequentVowelandConsonant.cs",
      "approach": "Frequency Counting with Character Classification",
      "tags": [
        "String",
        "Hash Table",
        "Frequency Count"
      ],
      "steps": [
        "1) Initialize counters for maximum vowel and consonant frequencies.",
        "2) Create a list of vowels for classification and an array to track character frequencies.",
        "3) Iterate through each character in the string.",
        "4) Update character frequency and track maximum frequencies for vowels and consonants separately.",
        "5) Return the sum of maximum vowel frequency and maximum consonant frequency."
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1) - fixed size arrays and vowel list",
      "solutionLink": "",
      "code": "/*\nSolution: https://leetcode.com/problems/find-most-frequent-vowel-and-consonant/solutions/7185563/simplest-solution-c-time-on-space1-pleas-0nnb/\nApproach: Frequency Counting with Character Classification\nTags: String, Hash Table, Frequency Count\n1) Initialize counters for maximum vowel and consonant frequencies.\n2) Create a list of vowels for classification and an array to track character frequencies.\n3) Iterate through each character in the string.\n4) Update character frequency and track maximum frequencies for vowels and consonants separately.\n5) Return the sum of maximum vowel frequency and maximum consonant frequency.\n\nTime Complexity: O(n)\nSpace Complexity: O(1) - fixed size arrays and vowel list\n*/\npublic class Solution {\n    public int MaxFreqSum(string s) {\n        int maxVowelFreq = 0;                                           // Maximum frequency among vowels\n        int maxConsonantFreq = 0;                                       // Maximum frequency among consonants\n        List<char> vowels = new List<char>(){'a','e','i','o','u'};      // List of vowel characters\n        int[] charFreq = new int[27];                                   // Frequency array for each character (a-z)\n\n        foreach(char ch in s) {                                         // Iterate through each character in string\n            int chatAt = (int)ch - 'a';                                 // Convert character to array index (0-25)\n\n            charFreq[chatAt]++;                                         // Increment frequency of current character\n\n            if (vowels.Contains(ch)) {                                  // If character is a vowel\n                maxVowelFreq = Math.Max(maxVowelFreq, charFreq[chatAt]); // Update maximum vowel frequency\n            }\n            else {                                                      // If character is a consonant\n                maxConsonantFreq = Math.Max(maxConsonantFreq, charFreq[chatAt]); // Update maximum consonant frequency\n            }\n        }\n\n        return maxConsonantFreq + maxVowelFreq;                         // Return sum of max frequencies\n    }\n}"
    }
  ]
}